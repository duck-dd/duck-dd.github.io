[{"content":"说明：\n持续更新(标题含TODO关键字的小节，都会以topic开始，后续会持续完善topic)。记录内容是一些对我而言：\n小的骚操作(可能有些tricky) 容易理解偏差的点 冷门的点(没啥用的点) Golang代码执行顺序 没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。\n了解更多可查看Golang内存模型规范。\ninternal包 internal包，只能被和internal目录有同一个父目录的包所导入。 例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。\n变量交换 i, j = j, i // 交换 i 和 j 的值 for循环有其他识别break的关键字 for循环内有其他识别break的关键字时，其他关键字内的break会被其识别而不会跳出for，以下用select举例，switch同理。\nfor { select { case \u0026lt;-sigChan: // exit for break default: // do something } } 以上break并不能退出for循环，可以使用标签或goto解决：\n// 1 标签 FOR: for { select { case \u0026lt;-sigChan: // exit for break FOR default: // do something } } ---------------------------- // 2 goto for { select { case \u0026lt;-sigChan: // exit for goto ENDFOR default: // do something } } ENDFOR: 读取stdin(刷题别再因为stdin踩坑了喂) fmt包内 Scan系列 SScan系列 Fscan系列如下：\n系列 无后缀 f后缀 ln后缀 Scan系列 Scan() Scanf() Scanln Sscan系列 Sscan() Sscanf() Sscanln() Fscan系列 Fscan() Fscanf() Fscanln() 将换行符当空格处理 根据给定的format读取 遇到换行符停止 他们的定义：\nfunc Scan(a ...interface{}) (n int, err error) func Scanf(format string, a ...interface{}) (n int, err error) func Scanln(a ...interface{}) (n int, err error) func Sscan(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) 从定义可见，Scanln(其他同理)直接读取一行然后结束，但是从函数入参...interface{}就能知道，你需要明确的知道这一行空格会分隔出多少个你需要的值；可是平时做题最多的场景，一般是每一行有多少个值是个变量，需要先将一行按string读入，然后strings.Fields()直接获得一个[]string再慢慢处理。所以你应该这样做：\n// each line in stdin corresponding to a string in lines lines := make([]string, 0, anExpectedCap) scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { line := scanner.Text() lines = append(lines, line) } PS: 命令行 ctrl+d == EOF，结束输入。\n初始化顺序 任意文件可以有多个init函数用来做初始化工作。 Golang包初始化顺序为 全局变量\u0026gt;init函数。 全局变量初始化顺序由他们之间的依赖关系决定(所以全局变量、type等的声明可忽略顺序)，无依赖关系时按声明顺序执行。 init函数的初始化顺序按init()函数声明顺序执行。\nfunc init(){ ... } func init(){ ... } func main(){ ... } // 复杂的初始化工作除了可以用init()函数解决外，还可以使用匿名函数 var ComplexTable [][]int = func()([][]int){ ... ... ... }() *指针 = 表达式 \u0026ldquo;*指针 = 表达式\u0026rdquo; 形式可以直接修改指针指向的变量的值：\nx := 1 p := \u0026amp;x // p, of type *int, points to x fmt.Println(*p) // \u0026#34;1\u0026#34; *p = 2 // equivalent to x = 2 fmt.Println(*p) // \u0026#34;2\u0026#34; fmt.Println(x) // \u0026#34;2\u0026#34; ,与} 使用逗号处理多item（函数参数，结构体成员等）时，结束的 )或} 可以跟在最后一行，也可以另起一行，当另起一行时，为避免编译器行尾自动补充分号导致编译错误，应在末尾的参数后显示插入逗号。\nfunc tt(a,b,c string)(){ ... } tt( \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, ) == tt( \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) ------------------------------------------------------------- type TT struct{ A string B string C string } tt := TT{ A: \u0026#34;a\u0026#34;, B: \u0026#34;b\u0026#34;, C: \u0026#34;c\u0026#34;, } == tt := TT{ A: \u0026#34;a\u0026#34;, B: \u0026#34;b\u0026#34;, C: \u0026#34;c\u0026#34;} map查找、类型断言、通道接收 的返回值 map查找\u0026amp;类型断言\u0026amp;通道接收，既可以返回两个值，也可以返回一个值。\nv, ok = m[key] // map lookup v, ok = x.(T) // type assertion v, ok = \u0026lt;-ch // channel receive v = m[key] // map查找，失败时返回零值 v = x.(T) // type断言，失败时panic异常 v = \u0026lt;-ch // 管道接收，失败时返回零值（阻塞不算是失败） 支持中文名称，默认不导出 Golang支持中文变量和类型名，对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出。\ntype 测试人员 struct { name string age int } func main(){ 测试人员_某某某 := \u0026amp;测试人员{\u0026#34;test\u0026#34;, 1} fmt.Printf(\u0026#34;%v,%T,%+v\\n\u0026#34;, 测试人员_某某某, 测试人员_某某某, 测试人员_某某某) // 输出：\u0026amp;{test 1},*main.测试人员,\u0026amp;{name:test age:1} } 包注释写法 一个包通常只有一个源文件有包注释，如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释；如果某个包注释很大，通常会放到一个独立的doc.go文件中。\n{}包含的部分为一个句法块，可以显示的使用{}做 作用域 隔离：\nfunc main(){ tmp := 10 { tmp2 := 20 fmt.Println(tmp, tmp2) } fmt.Println(tmp) // can not recognize tmp2 here } if而不是if+else Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进：\n// right res,err := doSomething() if err != nil{ printErr(err) } res.DoSomething() // wrong if res,err := doSomething(); err != nil{ printErr(err) } else { // res.DoSomething() 应该在主执行逻辑中，不建议缩进 res.DoSomething() } 格式化输出的[n]副词 fmt包Printf函数格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后添加[n]副词告诉Printf函数再次使用第n个操作数。\nfmt.Printf(\u0026#34;%d, %d\\n\u0026#34;, 1, 2) // 1, 2 fmt.Printf(\u0026#34;%d, %[1]d\\n\u0026#34;, 1) // 1, 1 \u0026ldquo;变量\u0026rdquo; 和 \u0026ldquo;值\u0026rdquo; 老罗语录： 要区分变量和值有个很简单的方法就是对它取地址，看看编译器会不会报错。 变量就是有地址的值。 值没有地址，值不能放在等式的左边。\n查看数字的二进制 fmt.Println(strconv.FormatInt(int64(123), 2)) // \u0026#34;1111011\u0026#34; fmt.Printf(\u0026#34;%b\u0026#34;, 123) // \u0026#34;1111011\u0026#34; 创建slice 创建长度和容量都是100的string slice的简洁方法：\n// 正常 testSlice := make([]string, 100, 100) // 简洁版 testSlice := []string{99: \u0026#34;\u0026#34;} slice切割 当使用[:]切割int数组创建slice时，slice底层数组共用原数组，新slice的cap为切割起始位置至原数组末尾；因此，修改切割出的slice内元素时，将同时修改原数组，且修改slice的len以外cap以内的值时，也同时修改原数组：\ntestArray := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} cutTestArray := testArray[5:9] fmt.Println(cutTestArray, len(cutTestArray), cap(cutTestArray)) // [5 6 7 8] 4 7 cutTestArray[0] = 50 fmt.Println(cutTestArray, testArray) // [50 6 7 8] [0 1 2 3 4 50 6 7 8 9 10 11] cutTestArray = append(cutTestArray, 90) fmt.Println(cutTestArray, testArray) // [50 6 7 8 90] [0 1 2 3 4 50 6 7 8 90 10 11] 使用[:]切割字符串时，获得一个字符串且发生一次拷贝：\ntestStr := \u0026#34;hello world\u0026#34; cutTestStr := testStr[6:] // var cutTestStr string = testStr[6:] fmt.Println(testStr, \u0026amp;testStr, cutTestStr, \u0026amp;cutTestStr) // hello world 0xc000010240 world 0xc000010250 \u0026hellip; in Golang Golang \u0026hellip;(3 dots) 用法: 参考 3 dots in Go\nslice操作考虑内存 给定一个string slice，去除其中\u0026quot;\u0026ldquo;项：\n// 你可能想这么写： func filterEmptyStr(input []string) []string { ret := make([]string, 0) for _, item := range input { if item != \u0026#34;\u0026#34; { ret = append(ret, item) } } return ret } // 再想想，为了避免发生扩容拷贝，你可能会这么写： func filterEmptyStr(input []string) []string { ret := make([]string, 0, len(input)) for _, item := range input { if item != \u0026#34;\u0026#34; { ret = append(ret, item) } } return ret } // 其实，可以共用底层数据结构，这么写（问题是，输入的[]string被修改了）： // nonempty returns a slice holding only the non-empty strings. // The underlying array is modified during the call. func nonempty(strings []string) []string { i := 0 for _, s := range strings { if s != \u0026#34;\u0026#34; { strings[i] = s i++ } } return strings[:i] } // 再思考下，共用底层结构也可以这么写： func nonempty2(strings []string) []string { out := strings[:0] // zero-length slice of original for _, s := range strings { if s != \u0026#34;\u0026#34; { out = append(out, s) } } return out } set (Golang没有set类型) Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。 通常使用map[string]bool创建一个string的set，但是bool占一字节，如需更加节省空间，可以使用map[string]struct{}, struct{}大小为0：\nseen := make(map[string]struct{}) // set of strings // ... if _, ok := seen[s]; !ok { seen[s] = struct{}{} // ...first time seeing s... } 构造struct建议声明字段名 尽量不要使用如下方法初始化结构体：\ntype Point struct{ X, Y int } p := Point{1, 2} // 建议： p := Point{ X: 1, Y: 2, } 因为这对结构体的成员顺序有强依赖，当结构体做调整时，将导致编译不通过。（有利有弊，个人认为，这样可以避免结构体增加字段时，忘记为新增字段做初始化）\njson.MarshalIndent json.MarshalIndent函数将产生整齐缩进的输出，该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：\ntype JsonTest struct { Item1 string Item2 string } jt1 := JsonTest{\u0026#34;item1\u0026#34;, \u0026#34;item2\u0026#34;} msg, _ := json.Marshal(jt1) msgIndent, _ := json.MarshalIndent(jt1, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) fmt.Println(string(msg)) fmt.Println(string(msgIndent)) --------------------------------------------------- output: {\u0026#34;Item1\u0026#34;:\u0026#34;item1\u0026#34;,\u0026#34;Item2\u0026#34;:\u0026#34;item2\u0026#34;} { \u0026#34;Item1\u0026#34;: \u0026#34;item1\u0026#34;, \u0026#34;Item2\u0026#34;: \u0026#34;item2\u0026#34; } \u0026ldquo;函数值\u0026quot;使用前先判空 当使用“函数值”作为函数参数时，函数内部调用传入的函数值时记得先判空，函数值零值为nil，直接调用nil的函数值会引发panic。\n扩展来看，引用类型，能够与nil做==判断的，使用前都应该判空。\n捕获迭代变量 for循环(尤其需要在for循环内开goroutine)时，使用循环变量之前需要先将循环变量赋值给循环体内的一个局部变量，如下例。\n问题的原因在于循环变量的作用域。在下面的例子中，for循环语句引入了新的词法块，循环变量name\u0026amp;age在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以name为例，后续的迭代会不断更新name的值，当最终printer操作执行时，for循环已完成，name中存储的值等于最后一次迭代的值。这意味着，每次printer的调用输出的都是相同的最后那一个名字。\n为了解决这个问题，可以引入一个与循环变量同名的局部变量，作为循环变量的副本。\n// wrong, output: /* Pike 13 Pike 13 */ var printers []func() name2Age := map[string]string{\u0026#34;Rob\u0026#34;: \u0026#34;12\u0026#34;, \u0026#34;Pike\u0026#34;: \u0026#34;13\u0026#34;} for name, age := range name2Age { printers = append(printers, func() { fmt.Println(name, age) }) } for _, printer := range printers { printer() } -------------------------------------------------------------- // right, output: /* Rob 12 Pike 13 */ var printers []func() name2Age := map[string]string{\u0026#34;Rob\u0026#34;: \u0026#34;12\u0026#34;, \u0026#34;Pike\u0026#34;: \u0026#34;13\u0026#34;} for name, age := range name2Age { name := name age := age printers = append(printers, func() { fmt.Println(name, age) }) } for _, printer := range printers { printer() } --------------------------------------------------------------- // 下面两个例子的输出是一致的，因为fmt.Println()在每次循环内部即时调用 // 1 name2Age := map[string]string{\u0026#34;Rob\u0026#34;: \u0026#34;12\u0026#34;, \u0026#34;Pike\u0026#34;: \u0026#34;13\u0026#34;} for name, age := range name2Age { fmt.Println(name, age) } // 2 name2Age := map[string]string{\u0026#34;Rob\u0026#34;: \u0026#34;12\u0026#34;, \u0026#34;Pike\u0026#34;: \u0026#34;13\u0026#34;} for name, age := range name2Age { name := name age := age fmt.Println(name, age) } defer 被延迟执行的匿名函数可以修改函数返回给调用者的返回值：\nfunc add(x int) (result int) { defer func() { result += x }() return x + x } fmt.Println(add(4)) // \u0026#34;12\u0026#34; // 如果是参数那么将无法成功修改返回值: func add(x int) (result int) { defer func(result int) { result += x }(result) return x + x } fmt.Println(add(4)) // \u0026#34;8\u0026#34; 这里首先必须显示声明了返回值，以下方法不能成功修改返回值：\nfunc add(x int) int { result := x + x defer func() { result += x }() return result } fmt.Println(add(4)) // \u0026#34;8\u0026#34; 这是为什么呢？看下面例子，显示声明的返回值，defer中直接修改时，其实修改的是同一个地址，所以能够成功修改返回值。但是在上面的例子中，defer修改的仅仅是函数内的局部变量，而函数在return时将该局部变量拷贝到了调用栈的返回值中，所以defer修改局部变量成功，但是并不会体现在返回值上。\n上面的例子能说明defer的执行时机是返回值返回给调用者之后吗？ 不能，其实defer的执行时机是return之后，且返回值返回给调用方之前，看下面的例子，也正是因为defer执行在返回值真正返回给调用方之前，所以才能成功修改返回值。\nfunc add(x int) (result int) { fmt.Println(\u0026#34;addr of result in add: \u0026#34;, \u0026amp;result) defer func() { fmt.Println(\u0026#34;addr of result in defer: \u0026#34;, \u0026amp;result) result += x }() return x + x } fmt.Println(add(4)) // \u0026#34;12\u0026#34; ------------------------------------------------------ output: addr of result in add: 0xc00009e018 addr of result in defer: 0xc00009e018 12 为了证明 “defer执行在return之后，且返回值返回给调用方之前”，可以看下面的例子，可以看到调用方获得返回值紧跟defer完成以后。 因此啊，defer里面逻辑写不好，也会严重影响性能啊，如果是一些可并发的逻辑，可以defer里开新的goroutine去搞。\nfunc add(x int) (result int) { defer func() { fmt.Println(\u0026#34;defer start \u0026#34;, time.Now()) time.Sleep(time.Second) result += x fmt.Println(time.Now(), \u0026#34;result value in defer: \u0026#34;, result) time.Sleep(10 * time.Second) fmt.Println(\u0026#34;defer end \u0026#34;, time.Now()) }() return x + x } x := add(4) fmt.Println(\u0026#34;caller time: \u0026#34;, time.Now(), \u0026#34;caller got: \u0026#34;, x) ------------------------------------------------------ output: defer start 2021-07-23 15:19:35.264078 +0800 CST m=+0.000999863 2021-07-23 15:19:36.265726 +0800 CST m=+1.002653773 result value in defer: 12 defer end 2021-07-23 15:19:46.270896 +0800 CST m=+11.007876743 caller time: 2021-07-23 15:19:46.270939 +0800 CST m=+11.007920326 caller got: 12 循环体中的defer 在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭：\nfor _, filename := range filenames { f, err := os.Open(filename) if err != nil { return err } defer f.Close() // NOTE: risky; could run out of file descriptors // ...process f… } 方法接收者(类型or其指针)一致性 如果某个struct有一个指针作为接收器的方法，那么该struct的所有方法都必须有一个指针接收器，即使并不需要。 换句话说，一个struct T，他的方法集要么都是func(t *T)DoSomething(){}，要么都是func (t T)DoSomething(){}。 Why？ 我的理解，保持类型方法集的一致性，能够规范化某个类型的拷贝行为，即该类型的拷贝是否是安全的。 举个例子，看下面，A的加减法都不会影响接收者，B的加减法都会影响接收者，可能适用于不同的场景，但是C，加法不会影响接收者，但是减法会影响接收者，这让人很懵逼。\ntype A struct{Item int} func (a A)Add(s int){ a.Item += s } func (a A)Subtrace(s int){ a.Item -= s } ////// type B struct{Item int} func (b *B)Add(s int){ b.Item += s } func (b *B)Subtrace(s int){ b.Item -= s } ////// type C struct{Item int} func (c C)Add(s int){ c.Item += s } func (c *C)Subtrace(s int){ c.Item -= s } 引用类型作为参数 函数参数是引用类型时，虽然仍可修改相同的底层数据，但是引用本身却是一份拷贝，当函数内修改引用本身时不会影响原值（比如赋值nil，或将引用指向其他对象）。 方法表达式中，接收者是表达式函数的第一个参数，所以该说明同样适用于方法；类型方法其接收者是类型的拷贝，类型指针方法其接收者是拷贝出的一份指向该类型的指针。\nfunc clearMap(input map[string]bool) { input = nil } func main() { tm := map[string]bool{\u0026#34;test\u0026#34;: true, \u0026#34;test1\u0026#34;: true} fmt.Println(tm) clearMap(tm) fmt.Println(tm) } ------------------------------------------------------- output: map[test:true test1:true] map[test:true test1:true] 内嵌使匿名struct拥有方法 Golang方法的接收者只能是命名类型或者其指针，但是由于内嵌这一特性，匿名struct也有手段可以拥有方法：\n// 两个包级别变量实现缓存 var ( mu sync.Mutex // guards mapping mapping = make(map[string]string) ) func Lookup(key string) string { mu.Lock() v := mapping[key] mu.Unlock() return v } ------------------------------------------------- // 匿名struct存储在变量cache中，并且具备其内嵌struct Mutex的所有方法 var cache = struct { sync.Mutex mapping map[string]string }{ mapping: make(map[string]string), } func Lookup(key string) string { cache.Lock() v := cache.mapping[key] cache.Unlock() return v } 方法表达式使用场景 当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法：\ntype Point struct{ X, Y float64 } func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} } func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} } type Path []Point func (path Path) TranslateBy(offset Point, add bool) { var op func(p, q Point) Point if add { op = Point.Add } else { op = Point.Sub } for i := range path { // Call either path[i].Add(offset) or path[i].Sub(offset). path[i] = op(path[i], offset) } } bit数组 Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。(再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组)。 一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第i位被设置时，我们才说这个集合包含元素i：\n// An IntSet is a set of small non-negative integers. // Its zero value represents the empty set. type IntSet struct { words []uint64 } // Has reports whether the set contains the non-negative value x. func (s *IntSet) Has(x int) bool { word, bit := x/64, uint(x%64) return word \u0026lt; len(s.words) \u0026amp;\u0026amp; s.words[word]\u0026amp;(1\u0026lt;\u0026lt;bit) != 0 } // Add adds the non-negative value x to the set. func (s *IntSet) Add(x int) { word, bit := x/64, uint(x%64) for word \u0026gt;= len(s.words) { s.words = append(s.words, 0) } s.words[word] |= 1 \u0026lt;\u0026lt; bit } // UnionWith sets s to the union of s and t. func (s *IntSet) UnionWith(t *IntSet) { for i, tword := range t.words { if i \u0026lt; len(s.words) { s.words[i] |= tword } else { s.words = append(s.words, tword) } } } // String returns the set as a string of the form \u0026#34;{1 2 3}\u0026#34;. func (s *IntSet) String() string { var buf bytes.Buffer buf.WriteByte(\u0026#39;{\u0026#39;) for i, word := range s.words { if word == 0 { continue } for j := 0; j \u0026lt; 64; j++ { if word\u0026amp;(1\u0026lt;\u0026lt;uint(j)) != 0 { if buf.Len() \u0026gt; len(\u0026#34;{\u0026#34;) { buf.WriteByte(\u0026#39; \u0026#39;) } fmt.Fprintf(\u0026amp;buf, \u0026#34;%d\u0026#34;, 64*i+j) } } } buf.WriteByte(\u0026#39;}\u0026#39;) return buf.String() } 接口命名 Golang接口命名一般\u0026quot;er\u0026quot;结尾，例如：Loser。 er的含义一般都是什么什么人，是一个类，而这个类一般有一些典型的行为，例如程序员，Coder:\ntype Coder interface { WriteBug() SloveBug() } 如果是组合的接口，一般这样：\n// 和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法 type ReadWriter interface { Reader Writer } 接口赋值接口 var w io.Writer var rwc io.ReadWriteCloser w = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.Writer lacks Close method 实现接口 若某类型指针接收者的方法实现了接口，那么该类型的指针实现了接口，但是该类型变量并没有：\ntype InterfaceTest interface { Read(string) Write() string } type interfaceTestImpl struct { Name string } func (i *interfaceTestImpl) Read(name string) { i.Name = name } func (i *interfaceTestImpl) Write() string { return i.Name } var it InterfaceTest iti := interfaceTestImpl{\u0026#34;name\u0026#34;} it = iti // Cannot use \u0026#39;iti\u0026#39; (type interfaceTestImpl) as type testpac.InterfaceTest Type does not implement \u0026#39;testpac.InterfaceTest\u0026#39; as \u0026#39;Read\u0026#39; method has a pointer receiver it = \u0026amp;iti // ok 编译期检查接口的实现 // *bytes.Buffer must satisfy io.Writer var _ io.Writer = (*bytes.Buffer)(nil) 突破Golang的导出限制 参考鸟窝：突破限制,访问其它Go package中的私有函数\n此外，reflect可以访问其他struct的私有成员变量(只能访问不能修改)。\n//go:xxx 参考：//go:xxx 是什么？\n两个接口值的比较可能会panic 接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。 然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:\nvar x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int 考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较非常确定它们的动态值是可比较类型的接口值。\n一个包含nil指针的接口不是nil接口 一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。 例：\nconst debug = true func main() { var buf *bytes.Buffer if debug { buf = new(bytes.Buffer) // enable collection of output } f(buf) // NOTE: subtly incorrect! if debug { // ...use buf... } } // If out is non-nil, output will be written to it. func f(out io.Writer) { // ...do something... if out != nil { out.Write([]byte(\u0026#34;done!\\n\u0026#34;)) } } 当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：\nif out != nil { out.Write([]byte(\u0026#34;done!\\n\u0026#34;)) // panic: nil pointer dereference } 当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口，所以防御性检查out!=nil的结果依然是true。 动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者，但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。]\n问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：\nvar buf io.Writer if debug { buf = new(bytes.Buffer) // enable collection of output } f(buf) // OK 通过断言询问行为(询问一个接口的\u0026quot;动态类型\u0026quot;是否具备某些接口定义外的行为) 看例子：\nfunc writeHeader(w io.Writer, contentType string) error { if _, err := w.Write([]byte(\u0026#34;Content-Type: \u0026#34;)); err != nil { return err } if _, err := w.Write([]byte(contentType)); err != nil { return err } // ... } io.Writer接口有方法func Write([]byte)(int, error)，但是这里做[]byte(string)的类型转换会引入开销：分配内存并拷贝。新分配的这块空间除了向io.Writer内写入就没有其他作用了，那么如果是在高并发场景这个操作可能会成为性能瓶颈，如何优化呢？\nio.Writer接口告诉我们关于w持有的具体类型的唯一东西：就是可以向它写入字节切片。查看net/http包源码，可以看到在这个程序中的w变量持有的动态类型也有一个允许字符串高效写入的WriteString方法(许多满足io.Writer接口的重要类型都有WriteString方法，包括*bytes.Buffer，*os.File和*bufio.Writer)。如何使用WriteString方法避免[]byte(string)类型转换的拷贝呢：\n// writeString writes s to w. // If w has a WriteString method, it is invoked instead of w.Write. func writeString(w io.Writer, s string) (n int, err error) { type stringWriter interface { WriteString(string) (n int, err error) } if sw, ok := w.(stringWriter); ok { return sw.WriteString(s) // avoid a copy } return w.Write([]byte(s)) // allocate temporary copy } func writeHeader(w io.Writer, contentType string) error { if _, err := writeString(w, \u0026#34;Content-Type: \u0026#34;); err != nil { return err } if _, err := writeString(w, contentType); err != nil { return err } // ... } 关于接口 当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。可以使用导出机制来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。\n当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。\n因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）\nfmt.Printf + \\r 实现动态输出 \\r == 返回行首，覆盖之前的文字，可以实现动态滚动输出\nfor _, r := range `-\\|/` { fmt.Printf(\u0026#34;\\r%c\u0026#34;, r) time.Sleep(100 * time.Millisecond) } ---------------------------- output: -转圈圈 happens before 在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，可以放心依赖这些已完成的事件。\n所以为啥不叫 happened and done before\u0026hellip;\nchannel 与 (for range, select case) 无论是有缓存还是无缓存，可以for range持续从channel获取值：\nfor i := range someChan { println(i) } 对于无缓存channel, for range读取后且channel关闭，则循环结束。 对于有缓存channel, 即使channel关闭，for range也会继续读取直到读取完毕。 总结：for range监听channel，结束条件为 channel关闭且channel内容读取完毕。\nselect和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身或者包含在一个简短的变量声明中:\nselect { case \u0026lt;-ch1: // ... case x := \u0026lt;-ch2: // ...use x... case ch3 \u0026lt;- y: // ... default: // ... } select特性：\n如果某个case代码块准备好发送或接收，执行对应内容 如果多个(\u0026gt;1)case代码块准备好发送或接收，随机选取一个并执行对应内容 如果所有case代码块都没有准备好 无default，等待 有default，执行default select{}永远等待 一个没有任何case的select语句写作select{}，会永远地等待下去。\nselect 与 time.After time.After函数会立即返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句包含了一个超时保护：\nselect { case \u0026lt;-time.After(10 * time.Second): // 超时时间10s，若超时什么都不做，退出select case \u0026lt;-aSigChan: doSomething() } ... select的一个骚操作 ch := make(chan int, 1) for i := 0; i \u0026lt; 10; i++ { select { case x := \u0026lt;-ch: fmt.Println(x) // \u0026#34;0\u0026#34; \u0026#34;2\u0026#34; \u0026#34;4\u0026#34; \u0026#34;6\u0026#34; \u0026#34;8\u0026#34; case ch \u0026lt;- i: } } 轮询channel 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。\nselect { case \u0026lt;-abort: fmt.Printf(\u0026#34;Launch aborted!\\n\u0026#34;) return default: // do nothing } time.Tick time.Tick通常用作定时器：\nfunc main() { tick := time.Tick(time.Second) for { \u0026lt;-tick fmt.Println(\u0026#34;hello\u0026#34;) } } 以上例子每秒输出一个hello，但是time.Tick如果像下面这样使用：\ntick := time.Tick(time.Second) select { case \u0026lt;-tick: // do something case \u0026lt;-aChanSig: // do something } 当select逻辑执行完毕后，tick的goroutine仍然存活着，周期性的尝试向tick中发送值，导致goroutine泄露。 只有当程序整个生命周期都需要时才适合使用time.Tick。否则的话，可以这样用：\nticker := time.NewTicker(1 * time.Second) \u0026lt;-ticker.C // receive from the ticker\u0026#39;s channel ticker.Stop() // cause the ticker\u0026#39;s goroutine to terminate 单方向channel 例如：\nchan\u0026lt;- int:只发送 \u0026lt;-chan int:只接收 通常一个函数参数的channel，参数输入(in)是一个只接受的channel，结果输出(out)是一个只发送的channel：\nfunc doSomeCalc(in \u0026lt;-chan int, out chan\u0026lt;- int){ for input := range in{ out \u0026lt;- calc(input) } } 对一个只接收的channel调用close是一个编译错误。\nmake(chan int) 和 make(chan int, 1) 的区别 test := make(chan int)无缓存，无接收时，test \u0026lt;- 1阻塞。 test := make(chan int, 1)带缓存，容量1，无接收时，test \u0026lt;- 1不阻塞。\n如何判断channel关闭 a := make(chan int) // a没有关闭，以下语句会阻塞，直到a有值输入，intV==值，ok==true intV, ok := \u0026lt;-a --------------------------------------------------------- a := make(chan int) close(a) // a关闭，以下语句不会阻塞，intV==0(int零值)，ok==false intV, ok := \u0026lt;-a 避免将一个channel用在唯一一个goroutine中 无缓存channel当然不能只在同一个goroutine使用，这必然会导致该goroutine阻塞。 有缓存的channel可以用在一个goroutine中，可以作队列用，但是不建议这样使用。 channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。\n带缓存channel的竞速 下面例子并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。 多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法。\nfunc mirroredQuery() string { responses := make(chan string, 3) go func() { responses \u0026lt;- request(\u0026#34;asia.gopl.io\u0026#34;) }() go func() { responses \u0026lt;- request(\u0026#34;europe.gopl.io\u0026#34;) }() go func() { responses \u0026lt;- request(\u0026#34;americas.gopl.io\u0026#34;) }() return \u0026lt;-responses // return the quickest response } func request(hostname string) (response string) { /* ... */ } 上面的竞速和下面有什么区别呢？下面的竞速使用了无缓存的channel，两个比较慢的goroutine将因为channel无人接收而永远卡住，并且不会被自动回收，从而导致goroutine泄漏。\nfunc mirroredQuery() string { responses := make(chan string) go func() { responses \u0026lt;- request(\u0026#34;asia.gopl.io\u0026#34;) }() go func() { responses \u0026lt;- request(\u0026#34;europe.gopl.io\u0026#34;) }() go func() { responses \u0026lt;- request(\u0026#34;americas.gopl.io\u0026#34;) }() return \u0026lt;-responses // return the quickest response } func request(hostname string) (response string) { /* ... */ } pipeline(串联channels) channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline），见下例和图：\nfunc main() { naturals := make(chan int) squares := make(chan int) // Counter go func() { for x := 0; x \u0026lt; 100; x++ { naturals \u0026lt;- x } close(naturals) }() // Squarer go func() { for x := range naturals { squares \u0026lt;- x * x } close(squares) }() // Printer (in main goroutine) for x := range squares { fmt.Println(x) } } counter是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给squarer求平方，squarer将平方结果通过第二个channel发送给printer。\n并发的非阻塞缓存(内包含重复抑制概念) 场景：缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了。 需求：并发安全，且避免对整个缓存加锁而导致所有操作都去争一个锁。\n函数例程：\n// 进行HTTP GET请求并且获取http响应body, 开销大, 应避免在不必要的时候反复调用 func httpGetBody(url string) (interface{}, error) { resp, err := http.Get(url) if err != nil { return nil, err } defer resp.Body.Close() return ioutil.ReadAll(resp.Body) } 缓存实现：\n// Package memo provides a concurrency-unsafe // memoization of a function of type Func. package memo // A Memo caches the results of calling a Func. type Memo struct { f Func cache map[string]result } // Func is the type of the function to memoize. type Func func(key string) (interface{}, error) type result struct { value interface{} err error } func New(f Func) *Memo { return \u0026amp;Memo{f: f, cache: make(map[string]result)} } // NOTE: not concurrency-safe! func (memo *Memo) Get(key string) (interface{}, error) { res, ok := memo.cache[key] if !ok { res.value, res.err = memo.f(key) memo.cache[key] = res } return res.value, res.err } 顺序的测试缓存：\nm := memo.New(httpGetBody) for url := range incomingURLs() { start := time.Now() value, err := m.Get(url) if err != nil { log.Print(err) } fmt.Printf(\u0026#34;%s, %s, %d bytes\\n\u0026#34;, url, time.Since(start), len(value.([]byte))) } ------------------------------------------------ output: https://golang.org, 175.026418ms, 7537 bytes https://godoc.org, 172.686825ms, 6878 bytes https://play.golang.org, 115.762377ms, 5767 bytes http://gopl.io, 749.887242ms, 2856 bytes https://golang.org, 721ns, 7537 bytes https://godoc.org, 152ns, 6878 bytes https://play.golang.org, 205ns, 5767 bytes http://gopl.io, 326ns, 2856 bytes 那么如果像下面这样并发的测试缓存，由于Get函数不是concurrency-safe，所有会有数据竞争。\nm := memo.New(httpGetBody) var n sync.WaitGroup for url := range incomingURLs() { n.Add(1) go func(url string) { start := time.Now() value, err := m.Get(url) if err != nil { log.Print(err) } fmt.Printf(\u0026#34;%s, %s, %d bytes\\n\u0026#34;, url, time.Since(start), len(value.([]byte))) n.Done() }(url) } n.Wait() 使用-race来观察数据竞争会看到：\n... WARNING: DATA RACE Write by goroutine 36: runtime.mapassign1() ~/go/src/runtime/hashmap.go:411 +0x0 *** *** ... Previous write by goroutine 35: runtime.mapassign1() ~/go/src/runtime/hashmap.go:411 +0x0 *** *** ... Found 1 data race(s) 消除数据竞争最简单的方法就是加锁：\ntype Memo struct { f Func mu sync.Mutex // guards cache cache map[string]result } // Get is concurrency-safe. func (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() res, ok := memo.cache[key] if !ok { res.value, res.err = memo.f(key) memo.cache[key] = res } memo.mu.Unlock() return res.value, res.err } 但是加了这个锁，Get就将本来可以并行的I/O操作串行化了。\n怎么优化呢？上面Lock锁的范围太大了，考虑缩小临界区，下面的优化把开销最大的I/O操作从临界区分离出来，使得I/O操作可并发，但是，对于相同的key，memo.f(key)可能会重复执行。\nfunc (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() res, ok := memo.cache[key] memo.mu.Unlock() if !ok { res.value, res.err = memo.f(key) // Between the two critical sections, several goroutines // may race to compute f(key) and update the map. memo.mu.Lock() memo.cache[key] = res memo.mu.Unlock() } return res.value, res.err } 上述的重复工作是应该避免的，这也有个专业名词，叫duplicate suppression(重复抑制)。看下面的优化。获取互斥锁来保护共享变量cache map，查询map中是否存在指定条目，如果没有找到那么分配空间插入一个新条目，释放互斥锁。如果存在条目的话且其值没有写入完成(也就是有其它的goroutine在调用f这个慢函数)时，goroutine必须等待值ready之后才能读到条目的结果。而想知道是否ready的话，可以直接从ready channel中读取，由于这个读取操作在channel关闭之前一直是阻塞。 如果没有条目的话，需要向map中插入一个没有准备好的条目，当前正在调用的goroutine就需要负责调用慢函数、更新条目以及向其它所有goroutine广播条目已经ready可读的消息了。 条目中的e.res.value和e.res.err变量是在多个goroutine之间共享的。创建条目的goroutine同时也会设置条目的值，其它goroutine在收到\u0026quot;ready\u0026quot;的广播消息之后立刻会去读取条目的值。尽管会被多个goroutine同时访问，但却并不需要互斥锁。ready channel的关闭一定会发生在其它goroutine接收到广播事件之前，因此第一个goroutine对这些变量的写操作是一定发生在这些读操作之前的。不会发生数据竞争。 这样并发、不重复、无阻塞的cache就完成了。\ntype entry struct { res result ready chan struct{} // closed when res is ready } func New(f Func) *Memo { return \u0026amp;Memo{f: f, cache: make(map[string]*entry)} } type Memo struct { f Func mu sync.Mutex // guards cache cache map[string]*entry } func (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() e := memo.cache[key] if e == nil { // This is the first request for this key. // This goroutine becomes responsible for computing // the value and broadcasting the ready condition. e = \u0026amp;entry{ready: make(chan struct{})} memo.cache[key] = e memo.mu.Unlock() e.res.value, e.res.err = memo.f(key) close(e.ready) // broadcast ready condition } else { // This is a repeat request for this key. memo.mu.Unlock() \u0026lt;-e.ready // wait for ready condition } return e.res.value, e.res.err } 上面的例子使用互斥量来保护多个goroutine调用Get时的共享map变量。接下来使用monitor goroutine(把map变量限制在一个单独goroutine)方案再实现一遍，使用monitor goroutine是需要使用到消息。（即对比下共享内存通信和消息通信）\n// Func is the type of the function to memoize. type Func func(key string) (interface{}, error) // A result is the result of calling a Func. type result struct { value interface{} err error } type entry struct { res result ready chan struct{} // closed when res is ready } // A request is a message requesting that the Func be applied to key. type request struct { key string response chan\u0026lt;- result // the client wants a single result } type Memo struct{ requests chan request } // New returns a memoization of f. Clients must subsequently call Close. func New(f Func) *Memo { memo := \u0026amp;Memo{requests: make(chan request)} go memo.server(f) return memo } func (memo *Memo) Get(key string) (interface{}, error) { response := make(chan result) memo.requests \u0026lt;- request{key, response} res := \u0026lt;-response return res.value, res.err } func (memo *Memo) Close() { close(memo.requests) } func (memo *Memo) server(f Func) { cache := make(map[string]*entry) for req := range memo.requests { e := cache[req.key] if e == nil { // This is the first request for this key. e = \u0026amp;entry{ready: make(chan struct{})} cache[req.key] = e go e.call(f, req.key) // call f(key) } go e.deliver(req.response) } } func (e *entry) call(f Func, key string) { // Evaluate the function. e.res.value, e.res.err = f(key) // Broadcast the ready condition. close(e.ready) } func (e *entry) deliver(response chan\u0026lt;- result) { // Wait for the ready condition. \u0026lt;-e.ready // Send the result to the client. response \u0026lt;- e.res } context context翻译：\n上下文;语境;(事情发生的)背景，环境 上下文，按我个人通俗的理解，就是一段代码(线程、协程等调度单元)在CPU的寄存器状态集，运行代码就把这段状态加载到寄存器，切出代码就把寄存器的状态保存到缓存或内存。\ngo的context本质上也是goroutine间通信的工具，用于在多个goroutine之间共享消息。channel是goroutine之间传递消息的桥梁，当然也可以用来传递一个关闭信号(channel+select实现)，但是如果需要“广播”，可以使用close channel的方式发送一个“广播”信号；context其实就是帮助做了“广播”，其Done方法就是利用一个 \u0026lt;-chan struct{} 的关闭来实现“广播”效果；此外，context还能存储一些信息，用来在多个goroutine之间共享。\n关于context的几点说明：\n不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx 不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo 不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据，例如：登陆的 session、cookie 等 同一个 context 可能会被传递到多个 goroutine，但 context 是并发安全，所以没关系 几个关键函数：\n// Background returns a non-nil, empty Context. It is never canceled, has no // values, and has no deadline. It is typically used by the main function, // initialization, and tests, and as the top-level Context for incoming // requests. func Background() Context // TODO returns a non-nil, empty Context. Code should use context.TODO when // it\u0026#39;s unclear which Context to use or it is not yet available (because the // surrounding function has not yet been extended to accept a Context // parameter). func TODO() Context // 与共享信息有关的 WithValue // WithValue returns a copy of parent in which the value associated with key is // val. // // Use context Values only for request-scoped data that transits processes and // APIs, not for passing optional parameters to functions. // // The provided key must be comparable and should not be of type // string or any other built-in type to avoid collisions between // packages using context. Users of WithValue should define their own // types for keys. To avoid allocating when assigning to an // interface{}, context keys often have concrete type // struct{}. Alternatively, exported context key variables\u0026#39; static // type should be a pointer or interface. func WithValue(parent Context, key, val interface{}) Context // 与“广播”控制有关的 WithCancel WithDeadline WithTimeout // WithCancel returns a copy of parent with a new Done channel. The returned // context\u0026#39;s Done channel is closed when the returned cancel function is called // or when the parent context\u0026#39;s Done channel is closed, whichever happens first. // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this Context complete. func WithCancel(parent Context) (ctx Context, cancel CancelFunc) // WithDeadline returns a copy of the parent context with the deadline adjusted // to be no later than d. If the parent\u0026#39;s deadline is already earlier than d, // WithDeadline(parent, d) is semantically equivalent to parent. The returned // context\u0026#39;s Done channel is closed when the deadline expires, when the returned // cancel function is called, or when the parent context\u0026#39;s Done channel is // closed, whichever happens first. // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this Context complete. func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) // WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)). func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 从上面函数的定义可以看到，context的cancelFunc是与context一同分开返回的，context 本身并没有取消函数，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：由父节点 context 流向子节点 context。\n举个简单栗子：\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { background := context.Background() // input values values := map[string]string{ \u0026#34;key1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;value2\u0026#34;, } ctxWithValue, _ := context.WithCancel(background) for k, v := range values { ctxWithValue = context.WithValue(ctxWithValue, k, v) } // timeout: 10s, protect usage ctxWithTimeout, cancelFunc := context.WithTimeout(ctxWithValue, time.Second*10) goroutineCount := 10 for i := 0; i \u0026lt; goroutineCount; i++ { go func(ctx context.Context, index int) { count := 0 for { fmt.Println(\u0026#34;gouroutine index: \u0026#34;, index, \u0026#34; \u0026#34;, \u0026#34;count: \u0026#34;, count, \u0026#34; \u0026#34;, \u0026#34;key1: \u0026#34;, ctx.Value(\u0026#34;key1\u0026#34;)) count++ time.Sleep(time.Millisecond * 500) } }(ctxWithTimeout, i) } // sleep 3s, actually should do something time.Sleep(time.Second * 3) cancelFunc() } context可能不是很完美：\nctx放在函数第一个参数，导致代码中ctx泛滥 ctx创建子节点，底层实际是在链表中创建节点，链表的O(n)有些时候会降低效率 但是，context简便的解决了\u0026quot;cancelation\u0026quot;的问题。只能说任何东西都有两面吧。\natomic(TODO) topic1: atomic用法总结 原子操作是在执行中不能被中断的操作，通常由CPU芯片级能力来保证，并由操作系统提供调用，golang基于操作系统的能力，也提供了基于原子操作的支持。\natomic与mutex的区别：原子操作是能保证执行期间连续的，不会被中断；临界区只能保证访问共享数据是按顺序访问的，但不保证访问期间不会被切换context。\n*_test包 包net/url(例子)同路径可以再声明一个net/url_test包。包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。 可以将这个外部测试包的导入路径视作是net/url_test会，但是实际上，它并不能被其他任何包导入。\n包内测试函数就可以测试逻辑，为啥还要搞外部测试包？ 外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包，包内的测试代码无法做到这点。 在设计层面，外部测试包是在所有它依赖的包的上层。 举个具体的例子，B包依赖的A包，A包在进行测试时，希望使用B包的功能，可是如果A直接importB，那么就发生了循环依赖，将导致编译报错。此时就可以在A内开一个A_test的外部测试包，这个测试包可以以一个第三方包的角色同时import A B，这样就可以测试了。\n别写脆弱的测试代码 避免脆弱测试代码的方法是只检测真正关心的属性。\n保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串（很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试）。\ngo test 配合 go tool cover 查看单测覆盖情况(HTML) 关于go test, go tool cover可具体查看命令文档。\n实践：\n// 生成测试文件test-tmp.out // -coverprofile 通过在测试代码中插入生成钩子来统计覆盖率数据 // 在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入输出文件，并打印一部分执行的语句的一个总结 // 如果只需要摘要，可以使用 -cover go test -covermode=count -coverprofile=test-tmp.out ./... // 浏览器html形式查看测试报告 go tool cover -html=test-tmp.out go test 与 性能分析 go test -cpuprofile=cpu.out // cpu go test -blockprofile=block.out // 阻塞：记录阻塞goroutine最久的操作 go test -memprofile=mem.out // 内存 使用reflect访问(仅访问无法修改)struct非导出成员 package testpac type ReflectTestStruct struct { Name string // export age int // not export } func (r *ReflectTestStruct) SetAge(age int) { r.age = age } ------------------------------------------- package main func main() { rts1 := testpac.ReflectTestStruct{ Name: \u0026#34;test1\u0026#34;, } rts1e := reflect.ValueOf(\u0026amp;rts1).Elem() rts1.SetAge(28) fmt.Println(\u0026#34;ReflectTestStruct.age: \u0026#34;, rts1e.FieldByName(\u0026#34;age\u0026#34;)) 高效的使用reflect(TODO) topic1: reflect用法总结 topic2: 分析反射导致性能下降的理论原因，关于reflect导致性能下滑有鸟窝的blog记载： Go Reflect 性能 topic3: 调研golang原生序列化/反序列化和几个其他实现的区别，看看大家的优化思路，和优化点适用的场景 topic4: 总结下反射使用过程中一些能减轻性能下滑的小tips(可能需要跑大量的benchmark测试各个反射函数的性能对比分析) 例如预先通过字段名或者方法名获取到对应的字段序号，使用Field(n)/Method(n)，而不是频繁使用FieldByName()/MethodByName() 首先，日常代码是不建议使用反射的。然后，使用反射必然会导致性能下降，但是还是能通过恰当的使用方法做到性能下滑少一些。\n内存对齐 例：\ntype demo1 struct { a int8 b int16 c int32 } type demo2 struct { a int8 c int32 b int16 } type demo3 struct { a int8 c int32 b int16 d int16 } func main() { fmt.Println(unsafe.Sizeof(demo1{})) // 8 fmt.Println(unsafe.Sizeof(demo2{})) // 12 fmt.Println(unsafe.Sizeof(demo3{})) // 12 } demo1:\na 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节 c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可 demo2:\na 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节 b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节 最终，demo2 的对齐倍数由 c 的对齐倍数决定，也是 4，因此，demo2还要占据 2 字节 ，内存占用为 12 字节 demo3:\na 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节 c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节 b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节 d 是第四个字段，对齐倍数为 2，从第 10 个位置开始占据 2 字节 空 struct{} 的内存对齐 空 struct{} 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）：\ntype demo3 struct { c int32 a struct{} } type demo4 struct { a struct{} c int32 } func main() { fmt.Println(unsafe.Sizeof(demo3{})) // 8 fmt.Println(unsafe.Sizeof(demo4{})) // 4 } Golang指针运算 Go的指针是不支持运算的，但是借助unsafe.Pointer和uintptr可以实现这个骚操作。\n类型 概念 持有对象(即指针不释放，其持有的对象GC无法回收) 指针运算 转换 * 普通的指针，传递对象的地址 可持有 不支持 与unsafe.Pointer相互转换 unsafe.Pointer 类似C的void*，可以包含任意类型变量的地址 可持有 不支持 与 *和uintptr 相互转换 uintptr 可以理解为一个纯数值?(字节长度与int一致，uintptr is an integer type that is large enough to hold the bit pattern of any pointer) 不可持有(GC 不把 uintptr 当指针，uintptr 类型的目标会被回收) 支持 与unsafe.Pointer相互转换 如上表，unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算。\n举个栗子：\npackage main ​ import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) ​ func main() { //定义一个长度为3的int8类型数组 a:=[3]int8{6,8,9} //取出数组第一个位置的地址 a_first_point:=\u0026amp;a[0] a_first_unsafe_point:=unsafe.Pointer(a_first_point) fmt.Println(\u0026#34;a[0]的地址为：\u0026#34;,a_first_unsafe_point) //指针只能一个字节字节取，int8占一个字节，所以看到值只加了1 fmt.Println(\u0026#34;a[1]的地址为：\u0026#34;,unsafe.Pointer(\u0026amp;a[1])) //把a_first_unsafe_point转成uintptr类型，就可以指针运算了 a_uintptr_first_unsafe_point:=uintptr(a_first_unsafe_point) //指针+1 表示到了数组的第二个位置 a_uintptr_first_unsafe_point++ fmt.Println(\u0026#34;a[0]位置指针自增1后，的指针位置：\u0026#34;,a_uintptr_first_unsafe_point) //打印出来可以看到跟\u0026amp;a[1]的地址是一样的 a_uintptr_second_unsafe_point:=unsafe.Pointer(a_uintptr_first_unsafe_point) fmt.Println(\u0026#34;a[0]位置指针自增1后，的指针位置，转成unsafe_Pointer类型：\u0026#34;,a_uintptr_second_unsafe_point) //将该指针转换成 *int8类型（因为它本身就是*int8类型） int8_point:=(*int8)(a_uintptr_second_unsafe_point) //解引用，得到指针对应的结果，就是数组的第二个值，8 fmt.Println(*int8_point) ​ } -------------------------- output: a[0]的地址为： 0xc000118000 a[1]的地址为： 0xc000118001 a[0]位置指针自增1后，的指针位置： 824634867713 a[0]位置指针自增1后，的指针位置，转成unsafe_Pointer类型： 0xc000118001 8 再举个正反栗：\n// right var x struct { a bool b int16 c []int } // 和 pb := \u0026amp;x.b 等价 pb := (*int16)(unsafe.Pointer( uintptr(unsafe.Pointer(\u0026amp;x)) + unsafe.Offsetof(x.b))) *pb = 42 fmt.Println(x.b) // \u0026#34;42\u0026#34; ------------------------------------ // wrong // NOTE: subtly incorrect! // 错误的原因是引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针 // 当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的\u0026amp;x.b地址 // 第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序 tmp := uintptr(unsafe.Pointer(\u0026amp;x)) + unsafe.Offsetof(x.b) pb := (*int16)(unsafe.Pointer(tmp)) *pb = 42 ------------------------------------ // 错误的原因是，并没有指针引用new新创建的变量，因此该语句执行完成之后， // 垃圾收集器有权马上回收其内存空间，所以返回的pT将是无效的地址 pT := uintptr(unsafe.Pointer(new(T))) 看了上面的例子，当从其他地方获取到了uintptr以后，为了避免GC回收其对应地址的变量，应该尽快将uintptr转化为unsafe.Pointer。\ncgo(TODO) topic1: cgo用法总结 cgo如果c代码在go文件同目录下的c文件内，必须go run .或者go build才能在编译阶段把.c文件编译进来，go run main.go不行\n错误处理 优先使用 errors.New 来创建错误变量，如果有格式化需求，可以使用 fmt.Errorf 在 fmt.Errorf 中使用 : %w 关键字来将一个错误 wrap 至其错误链中 使用 errors.Unwrap 来获得其错误链的上一个错误 使用 errors.Is 而非 == 来判定一个错误是否为特定错误(能够追溯错误链) 在错误链上获取特定种类的错误，使用 errors.As ","permalink":"https://duck-dd.github.io/posts/go-tips/","summary":"\u003cp\u003e说明：\u003c/p\u003e\n\u003cp\u003e持续更新(标题含TODO关键字的小节，都会以topic开始，后续会持续完善topic)。记录内容是一些对我而言：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e小的骚操作(可能有些tricky)\u003c/li\u003e\n\u003cli\u003e容易理解偏差的点\u003c/li\u003e\n\u003cli\u003e冷门的点(没啥用的点)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"golang代码执行顺序\"\u003eGolang代码执行顺序\u003c/h2\u003e\n\u003cp\u003e没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。\u003c/p\u003e\n\u003cp\u003e了解更多可查看Golang内存模型规范。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"internal包\"\u003einternal包\u003c/h2\u003e\n\u003cp\u003einternal包，只能被和internal目录有同一个父目录的包所导入。\n例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"变量交换\"\u003e变量交换\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ei, j = j, i // 交换 i 和 j 的值\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2 id=\"for循环有其他识别break的关键字\"\u003efor循环有其他识别break的关键字\u003c/h2\u003e\n\u003cp\u003efor循环内有其他识别break的关键字时，其他关键字内的break会被其识别而不会跳出for，以下用select举例，switch同理。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003efor {\n\t\tselect {\n\t\tcase \u0026lt;-sigChan:\n\t\t\t// exit for  \n\t\t\tbreak\n\t\tdefault:\n\t\t  // do something\n\t\t}\n\t}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以上break并不能退出for循环，可以使用标签或goto解决：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 1 标签\nFOR:\n\tfor {\n\t\tselect {\n\t\tcase \u0026lt;-sigChan:\n\t\t\t// exit for  \n\t\t\tbreak FOR\n\t\tdefault:\n\t\t  // do something\n\t\t}\n\t}\n\n----------------------------\n// 2 goto\n\tfor {\n\t\tselect {\n\t\tcase \u0026lt;-sigChan:\n\t\t\t// exit for  \n\t\t\tgoto ENDFOR\n\t\tdefault:\n\t\t  // do something\n\t\t}\n\t}\nENDFOR:\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2 id=\"读取stdin刷题别再因为stdin踩坑了喂\"\u003e读取stdin(刷题别再因为stdin踩坑了喂)\u003c/h2\u003e\n\u003cp\u003efmt包内 Scan系列 SScan系列 Fscan系列如下：\u003c/p\u003e","title":"Golang Tips"},{"content":"关于我 我为什么叫duck? duck=大可=奇, 即奇奇怪怪, 也对应这里的内容, 杂七杂八都会写一些 我从事的工作? 新时代民工, 不杰出的码农; 摸爬滚打(摸鱼)已超七载了, 还是没有找到方向 我的爱好? 好吧你可能也不会想知道我有什么爱好, 而且也没什么拿的出手的爱好 联系我? Email: dianxinztq@126.com 关于这里 本空间内容按 目录=\u0026gt;标签 层级分类\n目录 Category 内容 About 简介 CS 计算机方向内容 Read 读 书/博客/论文/文章 等的笔记 Life-Note 生活相关的杂记 Investment 理财/投资的杂记 Anything 乱七八糟的记录 标签 Tag Category 内容 About About 简介 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; Golang CS go语言专栏 Rust CS rust语言专栏 Python CS python语言专栏 Leetcode CS leetcode刷题记录 Algorithm CS 算法记录\u0026amp;总结 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; Read-note Read 读书笔记, 一般是短篇内容的精细记录 Read-summary Read 读书思考, 一般是长篇内容的概括总结 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; Family Life-Note 关于家庭 Car Life-Note 关于车 House Life-Note 关于房 \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; Investment Investment - \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash; Anything Anything - ","permalink":"https://duck-dd.github.io/about/","summary":"\u003ch1 id=\"关于我\"\u003e关于我\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e我为什么叫duck? duck=大可=奇, 即奇奇怪怪, 也对应这里的内容, 杂七杂八都会写一些\u003c/li\u003e\n\u003cli\u003e我从事的工作? 新时代民工, 不杰出的码农; 摸爬滚打(摸鱼)已超七载了, 还是没有找到方向\u003c/li\u003e\n\u003cli\u003e我的爱好? 好吧你可能也不会想知道我有什么爱好, 而且也没什么拿的出手的爱好\u003c/li\u003e\n\u003cli\u003e联系我? Email: \u003ca href=\"mailto:dianxinztq@126.com\"\u003edianxinztq@126.com\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"关于这里\"\u003e关于这里\u003c/h1\u003e\n\u003cp\u003e本空间内容按 目录=\u0026gt;标签 层级分类\u003c/p\u003e\n\u003ch2 id=\"目录\"\u003e目录\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003cstrong\u003eCategory\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003e内容\u003c/strong\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAbout\u003c/td\u003e\n          \u003ctd\u003e简介\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCS\u003c/td\u003e\n          \u003ctd\u003e计算机方向内容\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRead\u003c/td\u003e\n          \u003ctd\u003e读 书/博客/论文/文章 等的笔记\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eLife-Note\u003c/td\u003e\n          \u003ctd\u003e生活相关的杂记\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eInvestment\u003c/td\u003e\n          \u003ctd\u003e理财/投资的杂记\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAnything\u003c/td\u003e\n          \u003ctd\u003e乱七八糟的记录\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"标签\"\u003e标签\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003cstrong\u003eTag\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003eCategory\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003e内容\u003c/strong\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAbout\u003c/td\u003e\n          \u003ctd\u003eAbout\u003c/td\u003e\n          \u003ctd\u003e简介\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGolang\u003c/td\u003e\n          \u003ctd\u003eCS\u003c/td\u003e\n          \u003ctd\u003ego语言专栏\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRust\u003c/td\u003e\n          \u003ctd\u003eCS\u003c/td\u003e\n          \u003ctd\u003erust语言专栏\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePython\u003c/td\u003e\n          \u003ctd\u003eCS\u003c/td\u003e\n          \u003ctd\u003epython语言专栏\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eLeetcode\u003c/td\u003e\n          \u003ctd\u003eCS\u003c/td\u003e\n          \u003ctd\u003eleetcode刷题记录\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAlgorithm\u003c/td\u003e\n          \u003ctd\u003eCS\u003c/td\u003e\n          \u003ctd\u003e算法记录\u0026amp;总结\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRead-note\u003c/td\u003e\n          \u003ctd\u003eRead\u003c/td\u003e\n          \u003ctd\u003e读书笔记, 一般是短篇内容的精细记录\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRead-summary\u003c/td\u003e\n          \u003ctd\u003eRead\u003c/td\u003e\n          \u003ctd\u003e读书思考, 一般是长篇内容的概括总结\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eFamily\u003c/td\u003e\n          \u003ctd\u003eLife-Note\u003c/td\u003e\n          \u003ctd\u003e关于家庭\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCar\u003c/td\u003e\n          \u003ctd\u003eLife-Note\u003c/td\u003e\n          \u003ctd\u003e关于车\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eHouse\u003c/td\u003e\n          \u003ctd\u003eLife-Note\u003c/td\u003e\n          \u003ctd\u003e关于房\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eInvestment\u003c/td\u003e\n          \u003ctd\u003eInvestment\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n          \u003ctd\u003e\u0026mdash;\u0026ndash;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAnything\u003c/td\u003e\n          \u003ctd\u003eAnything\u003c/td\u003e\n          \u003ctd\u003e-\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"About"}]