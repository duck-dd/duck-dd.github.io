<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home Page</title>
    <link>https://tianqizhang93.github.io/</link>
    <description>Recent content on Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>ztq.</copyright>
    <lastBuildDate>Fri, 02 Jul 2021 22:35:37 +0800</lastBuildDate>
    
        <atom:link href="https://tianqizhang93.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Golang Tips For Me (continuously updated)</title>
        <link>https://tianqizhang93.github.io/posts/go-tips/</link>
        <pubDate>Fri, 02 Jul 2021 22:35:37 +0800</pubDate>
        
        <guid>https://tianqizhang93.github.io/posts/go-tips/</guid>
        <description>Home Page https://tianqizhang93.github.io/posts/go-tips/ -&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;持续更新(标题含TODO关键字的小节，都会以topic开始，后续会持续完善topic)。记录内容是一些对我而言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小的骚操作(可能也包含其背后的实现原理)&lt;/li&gt;
&lt;li&gt;经常理解偏差或容易忽略的知识点&lt;/li&gt;
&lt;li&gt;冷门的知识点&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;golang代码执行顺序&#34;&gt;Golang代码执行顺序&lt;/h2&gt;
&lt;p&gt;没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。。。应该不会被打破？&lt;/p&gt;
&lt;p&gt;了解更多可查看Golang内存模型规范。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;internal包&#34;&gt;internal包&lt;/h2&gt;
&lt;p&gt;internal包，只能被和internal目录有同一个父目录的包所导入。
例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;变量交换&#34;&gt;变量交换&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;i, j = j, i // 交换 i 和 j 的值
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;for循环有其他识别break的关键字&#34;&gt;for循环有其他识别break的关键字&lt;/h2&gt;
&lt;p&gt;for循环内有其他识别break的关键字时，其他关键字内的break会被其识别而不会跳出for，以下用select举例，switch同理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for {
		select {
		case &amp;lt;-sigChan:
			// exit for  
			break
		default:
		  // do something
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上break并不能退出for循环，可以使用标签或goto解决：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1 标签
FOR:
	for {
		select {
		case &amp;lt;-sigChan:
			// exit for  
			break FOR
		default:
		  // do something
		}
	}

----------------------------
// 2 goto
	for {
		select {
		case &amp;lt;-sigChan:
			// exit for  
			goto ENDFOR
		default:
		  // do something
		}
	}
ENDFOR:
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;读取stdin刷题别再因为stdin踩坑了喂&#34;&gt;读取stdin(刷题别再因为stdin踩坑了喂)&lt;/h2&gt;
&lt;p&gt;fmt包内 Scan系列 SScan系列 Fscan系列如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;系列&lt;/th&gt;
&lt;th&gt;无后缀&lt;/th&gt;
&lt;th&gt;f后缀&lt;/th&gt;
&lt;th&gt;ln后缀&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Scan系列&lt;/td&gt;
&lt;td&gt;Scan()&lt;/td&gt;
&lt;td&gt;Scanf()&lt;/td&gt;
&lt;td&gt;Scanln&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Sscan系列&lt;/td&gt;
&lt;td&gt;Sscan()&lt;/td&gt;
&lt;td&gt;Sscanf()&lt;/td&gt;
&lt;td&gt;Sscanln()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fscan系列&lt;/td&gt;
&lt;td&gt;Fscan()&lt;/td&gt;
&lt;td&gt;Fscanf()&lt;/td&gt;
&lt;td&gt;Fscanln()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;将换行符当空格处理&lt;/td&gt;
&lt;td&gt;根据给定的format读取&lt;/td&gt;
&lt;td&gt;遇到换行符停止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;他们的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func Scan(a ...interface{}) (n int, err error)
func Scanf(format string, a ...interface{}) (n int, err error)
func Scanln(a ...interface{}) (n int, err error)

func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)

func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从定义可见，Scanln(其他同理)直接读取一行然后结束，但是从函数入参&lt;code&gt;...interface{}&lt;/code&gt;就能知道，你需要明确的知道这一行空格会分隔出多少个你需要的值；可是平时做题最多的场景，一般是每一行有多少个值是个变量，需要先将一行按&lt;code&gt;string&lt;/code&gt;读入，然后&lt;code&gt;strings.Fields()&lt;/code&gt;直接获得一个&lt;code&gt;[]string&lt;/code&gt;再慢慢处理。所以你应该这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// each line in stdin corresponding to a string in lines
lines := make([]string, 0, anExpectedCap)
scanner := bufio.NewScanner(os.Stdin)
for scanner.Scan() {
	line := scanner.Text()
	lines = append(lines, line)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PS: 命令行 &lt;code&gt;ctrl+d == EOF&lt;/code&gt;，结束输入。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;初始化顺序&#34;&gt;初始化顺序&lt;/h2&gt;
&lt;p&gt;任意文件可以有多个init函数用来做初始化工作。
&lt;strong&gt;Golang包初始化顺序为 全局变量&amp;gt;init函数。
全局变量初始化顺序由他们之间的依赖关系决定(所以全局变量、type等的声明可忽略顺序)，无依赖关系时按声明顺序执行。
init函数的初始化顺序按init()函数声明顺序执行。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func init(){
    ...
}

func init(){
    ...
}

func main(){
    ...
}

// 复杂的初始化工作除了可以用init()函数解决外，还可以使用匿名函数
var ComplexTable [][]int = func()([][]int){
    ...
    ...
    ...
}()
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;指针--表达式&#34;&gt;*指针 = 表达式&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;*指针 = 表达式&amp;rdquo; 形式可以直接修改指针指向的变量的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x := 1
p := &amp;amp;x         // p, of type *int, points to x
fmt.Println(*p) // &amp;quot;1&amp;quot;
*p = 2          // equivalent to x = 2
fmt.Println(*p) // &amp;quot;2&amp;quot;
fmt.Println(x)  // &amp;quot;2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;与&#34;&gt;,与}&lt;/h2&gt;
&lt;p&gt;使用逗号处理多item（函数参数，结构体成员等）时，结束的 )或} 可以跟在最后一行，也可以另起一行，当另起一行时，为避免编译器行尾自动补充分号导致编译错误，应在末尾的参数后显示插入逗号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func tt(a,b,c string)(){
    ...
}

tt(
    &amp;quot;a&amp;quot;,
    &amp;quot;b&amp;quot;,
    &amp;quot;c&amp;quot;,
)
==
tt(
    &amp;quot;a&amp;quot;,
    &amp;quot;b&amp;quot;,
    &amp;quot;c&amp;quot;)
    
-------------------------------------------------------------

type TT struct{
    A string
    B string
    C string
}

tt := TT{
    A: &amp;quot;a&amp;quot;,
    B: &amp;quot;b&amp;quot;,
    C: &amp;quot;c&amp;quot;,
}
==
tt := TT{
    A: &amp;quot;a&amp;quot;,
    B: &amp;quot;b&amp;quot;,
    C: &amp;quot;c&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;map查找类型断言通道接收-的返回值&#34;&gt;map查找、类型断言、通道接收 的返回值&lt;/h2&gt;
&lt;p&gt;map查找&amp;amp;类型断言&amp;amp;通道接收，既可以返回两个值，也可以返回一个值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v, ok = m[key]             // map lookup
v, ok = x.(T)              // type assertion
v, ok = &amp;lt;-ch               // channel receive

v = m[key]                // map查找，失败时返回零值
v = x.(T)                 // type断言，失败时panic异常
v = &amp;lt;-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;支持中文名称默认不导出&#34;&gt;支持中文名称，默认不导出&lt;/h2&gt;
&lt;p&gt;Golang支持中文变量和类型名，对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type 测试人员 struct {
	name string
	age  int
}

func main(){
    测试人员_某某某 := &amp;amp;测试人员{&amp;quot;test&amp;quot;, 1}
    fmt.Printf(&amp;quot;%v,%T,%+v\n&amp;quot;, 测试人员_某某某, 测试人员_某某某, 测试人员_某某某)
    // 输出：&amp;amp;{test 1},*main.测试人员,&amp;amp;{name:test age:1}
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;包注释写法&#34;&gt;包注释写法&lt;/h2&gt;
&lt;p&gt;一个包通常只有一个源文件有包注释，如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释；如果某个包注释很大，通常会放到一个独立的doc.go文件中。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;{}包含的部分为一个句法块，可以显示的使用{}做 作用域 隔离：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main(){
    tmp := 10
    
    {
        tmp2 := 20
        fmt.Println(tmp, tmp2)
    }
    
    fmt.Println(tmp) // can not recognize tmp2 here
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;if而不是ifelse&#34;&gt;if而不是if+else&lt;/h2&gt;
&lt;p&gt;Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// right
res,err := doSomething()
if err != nil{
    printErr(err)
}
res.DoSomething()

// wrong
if res,err := doSomething(); err != nil{
    printErr(err)
} else {
    // res.DoSomething() 应该在主执行逻辑中，不建议缩进
    res.DoSomething()
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;格式化输出的n副词&#34;&gt;格式化输出的[n]副词&lt;/h2&gt;
&lt;p&gt;fmt包Printf函数格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后添加[n]副词告诉Printf函数再次使用第n个操作数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;%d, %d\n&amp;quot;, 1, 2)    // 1, 2
fmt.Printf(&amp;quot;%d, %[1]d\n&amp;quot;, 1)    // 1, 1
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;变量-和-值&#34;&gt;&amp;ldquo;变量&amp;rdquo; 和 &amp;ldquo;值&amp;rdquo;&lt;/h2&gt;
&lt;p&gt;老罗语录：
要区分变量和值有个很简单的方法就是对它取地址，看看编译器会不会报错。
变量就是有地址的值。
值没有地址，值不能放在等式的左边。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;查看数字的二进制&#34;&gt;查看数字的二进制&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fmt.Println(strconv.FormatInt(int64(123), 2))   // &amp;quot;1111011&amp;quot;
fmt.Printf(&amp;quot;%b&amp;quot;, 123)                           // &amp;quot;1111011&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;创建slice&#34;&gt;创建slice&lt;/h2&gt;
&lt;p&gt;创建长度和容量都是100的string slice的简洁方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 正常
testSlice := make([]string, 100, 100)
// 简洁版
testSlice := []string{99: &amp;quot;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;slice切割&#34;&gt;slice切割&lt;/h2&gt;
&lt;p&gt;当使用[:]切割int数组创建slice时，slice底层数组共用原数组，新slice的cap为切割起始位置至原数组末尾；因此，修改切割出的slice内元素时，将同时修改原数组，且修改slice的len以外cap以内的值时，也同时修改原数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;testArray := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
cutTestArray := testArray[5:9]
fmt.Println(cutTestArray, len(cutTestArray), cap(cutTestArray)) // [5 6 7 8] 4 7

cutTestArray[0] = 50
fmt.Println(cutTestArray, testArray) // [50 6 7 8] [0 1 2 3 4 50 6 7 8 9 10 11]


cutTestArray = append(cutTestArray, 90)
fmt.Println(cutTestArray, testArray) // [50 6 7 8 90] [0 1 2 3 4 50 6 7 8 90 10 11]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用[:]切割字符串时，获得一个字符串且发生一次拷贝：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;testStr := &amp;quot;hello world&amp;quot;
cutTestStr := testStr[6:] // var cutTestStr string = testStr[6:]
fmt.Println(testStr, &amp;amp;testStr, cutTestStr, &amp;amp;cutTestStr) // hello world 0xc000010240 world 0xc000010250
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;-in-golang&#34;&gt;&amp;hellip; in Golang&lt;/h2&gt;
&lt;p&gt;Golang &amp;hellip;(3 dots) 用法:
参考 &lt;a href=&#34;https://www.bookstack.cn/read/golang_development_notes/zh-9.14.md&#34;&gt;3 dots in Go&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;slice操作考虑内存&#34;&gt;slice操作考虑内存&lt;/h2&gt;
&lt;p&gt;给定一个string slice，去除其中&amp;quot;&amp;ldquo;项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 你可能想这么写：
func filterEmptyStr(input []string) []string {
	ret := make([]string, 0)

	for _, item := range input {
		if item != &amp;quot;&amp;quot; {
			ret = append(ret, item)
		}
	}

	return ret
}
// 再想想，为了避免发生扩容拷贝，你可能会这么写：
func filterEmptyStr(input []string) []string {
	ret := make([]string, 0, len(input))

	for _, item := range input {
		if item != &amp;quot;&amp;quot; {
			ret = append(ret, item)
		}
	}

	return ret
}
// 其实，可以共用底层数据结构，这么写（问题是，输入的[]string被修改了）：
// nonempty returns a slice holding only the non-empty strings.
// The underlying array is modified during the call.
func nonempty(strings []string) []string {
    i := 0
    for _, s := range strings {
        if s != &amp;quot;&amp;quot; {
            strings[i] = s
            i++
        }
    }
    return strings[:i]
}
// 再思考下，共用底层结构也可以这么写：
func nonempty2(strings []string) []string {
    out := strings[:0] // zero-length slice of original
    for _, s := range strings {
        if s != &amp;quot;&amp;quot; {
            out = append(out, s)
        }
    }
    return out
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;set-golang没有set类型&#34;&gt;set (Golang没有set类型)&lt;/h2&gt;
&lt;p&gt;Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。
通常使用map[string]bool创建一个string的set，但是bool占一字节，如需更加节省空间，可以使用map[string]struct{}, struct{}大小为0：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seen := make(map[string]struct{}) // set of strings
// ...
if _, ok := seen[s]; !ok {
    seen[s] = struct{}{}
    // ...first time seeing s...
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;构造struct建议声明字段名&#34;&gt;构造struct建议声明字段名&lt;/h2&gt;
&lt;p&gt;尽量不要使用如下方法初始化结构体：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Point struct{ X, Y int }

p := Point{1, 2}

// 建议：
p := Point{
    X: 1,
    Y: 2,
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为这对结构体的成员顺序有强依赖，当结构体做调整时，将导致编译不通过。（有利有弊，个人认为，这样可以避免结构体增加字段时，忘记为新增字段做初始化）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jsonmarshalindent&#34;&gt;json.MarshalIndent&lt;/h2&gt;
&lt;p&gt;json.MarshalIndent函数将产生整齐缩进的输出，该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type JsonTest struct {
	Item1 string
	Item2 string
}

jt1 := JsonTest{&amp;quot;item1&amp;quot;, &amp;quot;item2&amp;quot;}
msg, _ := json.Marshal(jt1)
msgIndent, _ := json.MarshalIndent(jt1, &amp;quot;&amp;quot;, &amp;quot;    &amp;quot;)
fmt.Println(string(msg))
fmt.Println(string(msgIndent))

---------------------------------------------------
output:

{&amp;quot;Item1&amp;quot;:&amp;quot;item1&amp;quot;,&amp;quot;Item2&amp;quot;:&amp;quot;item2&amp;quot;}
{
    &amp;quot;Item1&amp;quot;: &amp;quot;item1&amp;quot;,
    &amp;quot;Item2&amp;quot;: &amp;quot;item2&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;函数值使用前先判空&#34;&gt;&amp;ldquo;函数值&amp;quot;使用前先判空&lt;/h2&gt;
&lt;p&gt;当使用“函数值”作为函数参数时，函数内部调用传入的函数值时记得先判空，函数值零值为nil，直接调用nil的函数值会引发panic。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;捕获迭代变量&#34;&gt;捕获迭代变量&lt;/h2&gt;
&lt;p&gt;for循环(尤其需要在for循环内开goroutine)时，使用循环变量之前需要先将循环变量赋值给循环体内的一个局部变量，如下例。&lt;/p&gt;
&lt;p&gt;问题的原因在于循环变量的作用域。在下面的例子中，for循环语句引入了新的词法块，循环变量name&amp;amp;age在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以name为例，后续的迭代会不断更新name的值，当最终printer操作执行时，for循环已完成，name中存储的值等于最后一次迭代的值。这意味着，每次printer的调用输出的都是相同的最后那一个名字。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，可以&lt;strong&gt;引入一个与循环变量同名的局部变量，作为循环变量的副本&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// wrong, output: 
/*
Pike 13
Pike 13
*/

var printers []func()

name2Age := map[string]string{&amp;quot;Rob&amp;quot;: &amp;quot;12&amp;quot;, &amp;quot;Pike&amp;quot;: &amp;quot;13&amp;quot;}
for name, age := range name2Age {
	printers = append(printers, func() { fmt.Println(name, age) })
}

for _, printer := range printers {
	printer()
}
--------------------------------------------------------------
// right, output:
/*
Rob 12
Pike 13
*/

var printers []func()

name2Age := map[string]string{&amp;quot;Rob&amp;quot;: &amp;quot;12&amp;quot;, &amp;quot;Pike&amp;quot;: &amp;quot;13&amp;quot;}
for name, age := range name2Age {
	name := name
	age := age
	printers = append(printers, func() { fmt.Println(name, age) })
}

for _, printer := range printers {
	printer()
}

---------------------------------------------------------------
// 下面两个例子的输出是一致的，因为fmt.Println()在每次循环内部即时调用

// 1
name2Age := map[string]string{&amp;quot;Rob&amp;quot;: &amp;quot;12&amp;quot;, &amp;quot;Pike&amp;quot;: &amp;quot;13&amp;quot;}
for name, age := range name2Age {
	fmt.Println(name, age)
}
// 2
name2Age := map[string]string{&amp;quot;Rob&amp;quot;: &amp;quot;12&amp;quot;, &amp;quot;Pike&amp;quot;: &amp;quot;13&amp;quot;}
for name, age := range name2Age {
	name := name
	age := age
	fmt.Println(name, age)
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;defer&#34;&gt;defer&lt;/h2&gt;
&lt;p&gt;被延迟执行的匿名函数可以修改函数返回给调用者的返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(x int) (result int) {
    defer func() { result += x }()
    return x + x
}
fmt.Println(add(4)) // &amp;quot;12&amp;quot;

// 如果是参数那么将无法成功修改返回值:
func add(x int) (result int) {
    defer func(result int) { result += x }(result)
    return x + x
}
fmt.Println(add(4)) // &amp;quot;8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里首先必须显示声明了返回值，以下方法不能成功修改返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(x int) int {
    result := x + x
    defer func() { result += x }()
    return result
}
fmt.Println(add(4)) // &amp;quot;8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是为什么呢？看下面例子，显示声明的返回值，defer中直接修改时，其实修改的是同一个地址，所以能够成功修改返回值。但是在上面的例子中，defer修改的仅仅是函数内的局部变量，而函数在return时将该局部变量拷贝到了调用栈的返回值中，所以defer修改局部变量成功，但是并不会体现在返回值上。&lt;/p&gt;
&lt;p&gt;上面的例子能说明defer的执行时机是返回值返回给调用者之后吗？
不能，其实defer的执行时机是&lt;strong&gt;return之后，且返回值返回给调用方之前&lt;/strong&gt;，看下面的例子，也正是因为defer执行在返回值真正返回给调用方之前，所以才能成功修改返回值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(x int) (result int) {
    fmt.Println(&amp;quot;addr of result in add: &amp;quot;, &amp;amp;result)
    
    defer func() { 
      fmt.Println(&amp;quot;addr of result in defer: &amp;quot;, &amp;amp;result)
      result += x 
    }()
      
    return x + x
}
fmt.Println(add(4)) // &amp;quot;12&amp;quot;
------------------------------------------------------
output:

addr of result in add:  0xc00009e018
addr of result in defer:  0xc00009e018
12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了证明 “&lt;strong&gt;defer执行在return之后，且返回值返回给调用方之前&lt;/strong&gt;”，可以看下面的例子，可以看到调用方获得返回值紧跟defer完成以后。 &lt;strong&gt;因此啊，defer里面逻辑写不好，也会严重影响性能啊，如果是一些可并发的逻辑，可以defer里开新的goroutine去搞&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(x int) (result int) {
		defer func() {
		fmt.Println(&amp;quot;defer start &amp;quot;, time.Now())
		time.Sleep(time.Second)

		result += x
		fmt.Println(time.Now(), &amp;quot;result value in defer: &amp;quot;, result)

		time.Sleep(10 * time.Second)

		fmt.Println(&amp;quot;defer end &amp;quot;, time.Now())
	}()

	return x + x
}

x := add(4)
fmt.Println(&amp;quot;caller time: &amp;quot;, time.Now(), &amp;quot;caller got: &amp;quot;, x)
------------------------------------------------------
output:

defer start  2021-07-23 15:19:35.264078 +0800 CST m=+0.000999863
2021-07-23 15:19:36.265726 +0800 CST m=+1.002653773 result value in defer:  12
defer end  2021-07-23 15:19:46.270896 +0800 CST m=+11.007876743
caller time:  2021-07-23 15:19:46.270939 +0800 CST m=+11.007920326 caller got:  12
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;循环体中的defer&#34;&gt;循环体中的defer&lt;/h2&gt;
&lt;p&gt;在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for _, filename := range filenames {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close() // NOTE: risky; could run out of file descriptors
    // ...process f…
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;方法接收者类型or其指针一致性&#34;&gt;方法接收者(类型or其指针)一致性&lt;/h2&gt;
&lt;p&gt;如果某个struct有一个指针作为接收器的方法，那么该struct的所有方法都必须有一个指针接收器，即使并不需要。
换句话说，一个struct T，他的方法集要么都是&lt;code&gt;func(t *T)DoSomething(){}&lt;/code&gt;，要么都是&lt;code&gt;func (t T)DoSomething(){}&lt;/code&gt;。
Why？
我的理解，保持类型方法集的一致性，能够规范化某个类型的拷贝行为，即该类型的拷贝是否是安全的。
举个例子，看下面，A的加减法都不会影响接收者，B的加减法都会影响接收者，可能适用于不同的场景，但是C，加法不会影响接收者，但是减法会影响接收者，这让人很懵逼。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type A struct{Item int}

func (a A)Add(s int){
    a.Item += s
}

func (a A)Subtrace(s int){
    a.Item -= s
}

//////

type B struct{Item int}

func (b *B)Add(s int){
    b.Item += s
}

func (b *B)Subtrace(s int){
    b.Item -= s
}

//////

type C struct{Item int}

func (c C)Add(s int){
    c.Item += s
}

func (c *C)Subtrace(s int){
    c.Item -= s
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;引用类型作为参数&#34;&gt;引用类型作为参数&lt;/h2&gt;
&lt;p&gt;函数参数是引用类型时，虽然仍可修改相同的底层数据，但是引用本身却是一份拷贝，当函数内修改引用本身时不会影响原值（比如赋值nil，或将引用指向其他对象）。
方法表达式中，接收者是表达式函数的第一个参数，所以该说明同样适用于方法；类型方法其接收者是类型的拷贝，类型指针方法其接收者是拷贝出的一份指向该类型的指针。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func clearMap(input map[string]bool) {
	input = nil
}

func main() {
	tm := map[string]bool{&amp;quot;test&amp;quot;: true, &amp;quot;test1&amp;quot;: true}
	fmt.Println(tm)
	clearMap(tm)
	fmt.Println(tm)
}

-------------------------------------------------------
output:

map[test:true test1:true]
map[test:true test1:true]
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;内嵌使匿名struct拥有方法&#34;&gt;内嵌使匿名struct拥有方法&lt;/h2&gt;
&lt;p&gt;Golang方法的接收者只能是命名类型或者其指针，但是由于内嵌这一特性，匿名struct也有手段可以拥有方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 两个包级别变量实现缓存
var (
    mu sync.Mutex // guards mapping
    mapping = make(map[string]string)
)

func Lookup(key string) string {
    mu.Lock()
    v := mapping[key]
    mu.Unlock()
    return v
}

-------------------------------------------------
// 匿名struct存储在变量cache中，并且具备其内嵌struct Mutex的所有方法
var cache = struct {
    sync.Mutex
    mapping map[string]string
}{
    mapping: make(map[string]string),
}


func Lookup(key string) string {
    cache.Lock()
    v := cache.mapping[key]
    cache.Unlock()
    return v
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;方法表达式使用场景&#34;&gt;方法表达式使用场景&lt;/h2&gt;
&lt;p&gt;当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Point struct{ X, Y float64 }

func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) {
    var op func(p, q Point) Point
    if add {
        op = Point.Add
    } else {
        op = Point.Sub
    }
    for i := range path {
        // Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] = op(path[i], offset)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;bit数组&#34;&gt;bit数组&lt;/h2&gt;
&lt;p&gt;Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。(再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组)。
一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第i位被设置时，我们才说这个集合包含元素i：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// An IntSet is a set of small non-negative integers.
// Its zero value represents the empty set.
type IntSet struct {
    words []uint64
}

// Has reports whether the set contains the non-negative value x.
func (s *IntSet) Has(x int) bool {
    word, bit := x/64, uint(x%64)
    return word &amp;lt; len(s.words) &amp;amp;&amp;amp; s.words[word]&amp;amp;(1&amp;lt;&amp;lt;bit) != 0
}

// Add adds the non-negative value x to the set.
func (s *IntSet) Add(x int) {
    word, bit := x/64, uint(x%64)
    for word &amp;gt;= len(s.words) {
        s.words = append(s.words, 0)
    }
    s.words[word] |= 1 &amp;lt;&amp;lt; bit
}

// UnionWith sets s to the union of s and t.
func (s *IntSet) UnionWith(t *IntSet) {
    for i, tword := range t.words {
        if i &amp;lt; len(s.words) {
            s.words[i] |= tword
        } else {
            s.words = append(s.words, tword)
        }
    }
}

// String returns the set as a string of the form &amp;quot;{1 2 3}&amp;quot;.
func (s *IntSet) String() string {
    var buf bytes.Buffer
    buf.WriteByte(&#39;{&#39;)
    for i, word := range s.words {
        if word == 0 {
            continue
        }
        for j := 0; j &amp;lt; 64; j++ {
            if word&amp;amp;(1&amp;lt;&amp;lt;uint(j)) != 0 {
                if buf.Len() &amp;gt; len(&amp;quot;{&amp;quot;) {
                    buf.WriteByte(&#39; &#39;)
                }
                fmt.Fprintf(&amp;amp;buf, &amp;quot;%d&amp;quot;, 64*i+j)
            }
        }
    }
    buf.WriteByte(&#39;}&#39;)
    return buf.String()
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;接口命名&#34;&gt;接口命名&lt;/h2&gt;
&lt;p&gt;Golang接口命名一般&amp;quot;er&amp;quot;结尾，例如：Loser。
er的含义一般都是什么什么人，是一个类，而这个类一般有一些典型的行为，例如程序员，Coder:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Coder interface {
    WriteBug()
    SloveBug()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是组合的接口，一般这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法
type ReadWriter interface {
    Reader
    Writer
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;接口赋值接口&#34;&gt;接口赋值接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var w io.Writer
var rwc io.ReadWriteCloser

w = rwc                 // OK: io.ReadWriteCloser has Write method
rwc = w                 // compile error: io.Writer lacks Close method
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;实现接口&#34;&gt;实现接口&lt;/h2&gt;
&lt;p&gt;若某类型指针接收者的方法实现了接口，那么该类型的指针实现了接口，但是该类型变量并没有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type InterfaceTest interface {
	Read(string)
	Write() string
}

type interfaceTestImpl struct {
	Name string
}

func (i *interfaceTestImpl) Read(name string) {
	i.Name = name
}

func (i *interfaceTestImpl) Write() string {
	return i.Name
}

var it InterfaceTest
iti := interfaceTestImpl{&amp;quot;name&amp;quot;}
it = iti    // Cannot use &#39;iti&#39; (type interfaceTestImpl) as type testpac.InterfaceTest Type does not implement &#39;testpac.InterfaceTest&#39; as &#39;Read&#39; method has a pointer receiver
it = &amp;amp;iti   // ok
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;编译期检查接口的实现&#34;&gt;编译期检查接口的实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// *bytes.Buffer must satisfy io.Writer
var _ io.Writer = (*bytes.Buffer)(nil)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;突破golang的导出限制&#34;&gt;突破Golang的导出限制&lt;/h2&gt;
&lt;p&gt;参考鸟窝：&lt;a href=&#34;https://colobu.com/2017/05/12/call-private-functions-in-other-packages/&#34;&gt;突破限制,访问其它Go package中的私有函数&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;goxxx&#34;&gt;//go:xxx&lt;/h2&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://maiyang.me/post/2020-07-21-go-nosplit/&#34;&gt;//go:xxx 是什么？&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口值是可比较的&#34;&gt;接口值是可比较的&lt;/h2&gt;
&lt;p&gt;接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。
&lt;strong&gt;然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较非常确定它们的动态值是可比较类型的接口值。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一个包含nil指针的接口不是nil接口&#34;&gt;一个包含nil指针的接口不是nil接口&lt;/h2&gt;
&lt;p&gt;一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。
例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const debug = true

func main() {
    var buf *bytes.Buffer
    if debug {
        buf = new(bytes.Buffer) // enable collection of output
    }
    f(buf) // NOTE: subtly incorrect!
    if debug {
        // ...use buf...
    }
}

// If out is non-nil, output will be written to it.
func f(out io.Writer) {
    // ...do something...
    if out != nil {
        out.Write([]byte(&amp;quot;done!\n&amp;quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if out != nil {
    out.Write([]byte(&amp;quot;done!\n&amp;quot;)) // panic: nil pointer dereference
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口，所以防御性检查out!=nil的结果依然是true。
动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者，但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。]&lt;/p&gt;
&lt;p&gt;问题在于&lt;strong&gt;尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求&lt;/strong&gt;。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var buf io.Writer
if debug {
    buf = new(bytes.Buffer) // enable collection of output
}
f(buf) // OK
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;通过断言询问行为询问一个接口的动态类型是否具备某些接口定义外的行为&#34;&gt;通过断言询问行为(询问一个接口的&amp;quot;动态类型&amp;quot;是否具备某些接口定义外的行为)&lt;/h2&gt;
&lt;p&gt;看例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func writeHeader(w io.Writer, contentType string) error {
    if _, err := w.Write([]byte(&amp;quot;Content-Type: &amp;quot;)); err != nil {
        return err
    }
    if _, err := w.Write([]byte(contentType)); err != nil {
        return err
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;io.Writer&lt;/code&gt;接口有方法&lt;code&gt;func Write([]byte)(int, error)&lt;/code&gt;，但是这里做&lt;code&gt;[]byte(string)&lt;/code&gt;的类型转换会引入开销：分配内存并拷贝。新分配的这块空间除了向&lt;code&gt;io.Writer&lt;/code&gt;内写入就没有其他作用了，那么如果是在高并发场景这个操作可能会成为性能瓶颈，如何优化呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;io.Writer&lt;/code&gt;接口告诉我们关于&lt;code&gt;w&lt;/code&gt;持有的具体类型的唯一东西：就是可以向它写入字节切片。查看net/http包源码，可以看到在这个程序中的&lt;code&gt;w&lt;/code&gt;变量持有的动态类型也有一个允许字符串高效写入的&lt;code&gt;WriteString&lt;/code&gt;方法(许多满足&lt;code&gt;io.Writer&lt;/code&gt;接口的重要类型都有&lt;code&gt;WriteString&lt;/code&gt;方法，包括&lt;code&gt;*bytes.Buffer&lt;/code&gt;，&lt;code&gt;*os.File&lt;/code&gt;和&lt;code&gt;*bufio.Writer&lt;/code&gt;)。如何使用&lt;code&gt;WriteString&lt;/code&gt;方法避免&lt;code&gt;[]byte(string)&lt;/code&gt;类型转换的拷贝呢：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// writeString writes s to w.
// If w has a WriteString method, it is invoked instead of w.Write.
func writeString(w io.Writer, s string) (n int, err error) {
    type stringWriter interface {
        WriteString(string) (n int, err error)
    }
    if sw, ok := w.(stringWriter); ok {
        return sw.WriteString(s) // avoid a copy
    }
    return w.Write([]byte(s)) // allocate temporary copy
}

func writeHeader(w io.Writer, contentType string) error {
    if _, err := writeString(w, &amp;quot;Content-Type: &amp;quot;); err != nil {
        return err
    }
    if _, err := writeString(w, contentType); err != nil {
        return err
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;关于接口&#34;&gt;关于接口&lt;/h2&gt;
&lt;p&gt;当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。可以使用导出机制来限制一个类型的方法或一个结构体的字段是否在包外可见。&lt;strong&gt;接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中&lt;/strong&gt;。这种情况下，一个接口是解耦这两个包的一个好方式。&lt;/p&gt;
&lt;p&gt;因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;fmtprintf--r-实现动态输出&#34;&gt;fmt.Printf + \r 实现动态输出&lt;/h2&gt;
&lt;p&gt;\r == 返回行首，覆盖之前的文字，可以实现动态滚动输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for _, r := range `-\|/` {
    fmt.Printf(&amp;quot;\r%c&amp;quot;, r)
    time.Sleep(100 * time.Millisecond)
}

----------------------------
output: -转圈圈
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;happens-before&#34;&gt;happens before&lt;/h2&gt;
&lt;p&gt;在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，可以放心依赖这些已完成的事件。&lt;/p&gt;
&lt;p&gt;所以为啥不叫 happened and done before&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;channel-与-for-range-select-case&#34;&gt;channel 与 (for range, select case)&lt;/h2&gt;
&lt;p&gt;无论是有缓存还是无缓存，可以&lt;code&gt;for range&lt;/code&gt;持续从channel获取值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i := range someChan {
	println(i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于无缓存channel, for range读取后且channel关闭，则循环结束。
对于有缓存channel, 即使channel关闭，for range也会继续读取直到读取完毕。
总结：for range监听channel，结束条件为 channel关闭且channel内容读取完毕。&lt;/p&gt;
&lt;p&gt;select和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身或者包含在一个简短的变量声明中:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select {
case &amp;lt;-ch1:
    // ...
case x := &amp;lt;-ch2:
    // ...use x...
case ch3 &amp;lt;- y:
    // ...
default:
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;select特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果某个case代码块准备好发送或接收，执行对应内容&lt;/li&gt;
&lt;li&gt;如果多个(&amp;gt;1)case代码块准备好发送或接收，随机选取一个并执行对应内容&lt;/li&gt;
&lt;li&gt;如果所有case代码块都没有准备好
&lt;ul&gt;
&lt;li&gt;无default，等待&lt;/li&gt;
&lt;li&gt;有default，执行default&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;p&gt;一个没有任何case的select语句写作select{}，会永远地等待下去。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;select-与-timeafter&#34;&gt;select 与 time.After&lt;/h2&gt;
&lt;p&gt;time.After函数会立即返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句包含了一个超时保护：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select {
case &amp;lt;-time.After(10 * time.Second):
    // 超时时间10s，若超时什么都不做，退出select
case &amp;lt;-aSigChan:
    doSomething()
}
...

&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;select的一个骚操作&#34;&gt;select的一个骚操作&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ch := make(chan int, 1)
for i := 0; i &amp;lt; 10; i++ {
    select {
    case x := &amp;lt;-ch:
        fmt.Println(x) // &amp;quot;0&amp;quot; &amp;quot;2&amp;quot; &amp;quot;4&amp;quot; &amp;quot;6&amp;quot; &amp;quot;8&amp;quot;
    case ch &amp;lt;- i:
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;轮询channel&#34;&gt;轮询channel&lt;/h2&gt;
&lt;p&gt;下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select {
case &amp;lt;-abort:
    fmt.Printf(&amp;quot;Launch aborted!\n&amp;quot;)
    return
default:
    // do nothing
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;timetick&#34;&gt;time.Tick&lt;/h2&gt;
&lt;p&gt;time.Tick通常用作定时器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main() {
	tick := time.Tick(time.Second)
	for {
		&amp;lt;-tick
		fmt.Println(&amp;quot;hello&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上例子每秒输出一个hello，但是time.Tick如果像下面这样使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tick := time.Tick(time.Second)

select {
case &amp;lt;-tick:
    // do something
case &amp;lt;-aChanSig:
    // do something
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当select逻辑执行完毕后，tick的goroutine仍然存活着，周期性的尝试向tick中发送值，导致goroutine泄露。
&lt;strong&gt;只有当程序整个生命周期都需要时才适合使用time.Tick&lt;/strong&gt;。否则的话，可以这样用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ticker := time.NewTicker(1 * time.Second)
&amp;lt;-ticker.C    // receive from the ticker&#39;s channel
ticker.Stop() // cause the ticker&#39;s goroutine to terminate
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;单方向channel&#34;&gt;单方向channel&lt;/h2&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chan&amp;lt;- int:只发送&lt;/li&gt;
&lt;li&gt;&amp;lt;-chan int:只接收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常一个函数参数的channel，参数输入(in)是一个只接受的channel，结果输出(out)是一个只发送的channel：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func doSomeCalc(in &amp;lt;-chan int, out chan&amp;lt;- int){
    for input := range in{
        out &amp;lt;- calc(input)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对一个只接收的channel调用close是一个编译错误。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;makechan-int-和-makechan-int-1-的区别&#34;&gt;make(chan int) 和 make(chan int, 1) 的区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;test := make(chan int)&lt;/code&gt;无缓存，无接收时，&lt;code&gt;test &amp;lt;- 1&lt;/code&gt;阻塞。
&lt;code&gt;test := make(chan int, 1)&lt;/code&gt;带缓存，容量1，无接收时，&lt;code&gt;test &amp;lt;- 1&lt;/code&gt;不阻塞。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;如何判断channel关闭&#34;&gt;如何判断channel关闭&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;a := make(chan int)

// a没有关闭，以下语句会阻塞，直到a有值输入，intV==值，ok==true
intV, ok := &amp;lt;-a

---------------------------------------------------------

a := make(chan int)
close(a)

// a关闭，以下语句不会阻塞，intV==0(int零值)，ok==false
intV, ok := &amp;lt;-a
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;避免将一个channel用在唯一一个goroutine中&#34;&gt;避免将一个channel用在唯一一个goroutine中&lt;/h2&gt;
&lt;p&gt;无缓存channel当然不能只在同一个goroutine使用，这必然会导致该goroutine阻塞。
有缓存的channel可以用在一个goroutine中，可以作队列用，但是不建议这样使用。
channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;带缓存channel的竞速&#34;&gt;带缓存channel的竞速&lt;/h2&gt;
&lt;p&gt;下面例子并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。
&lt;strong&gt;多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func mirroredQuery() string {
    responses := make(chan string, 3)
    go func() { responses &amp;lt;- request(&amp;quot;asia.gopl.io&amp;quot;) }()
    go func() { responses &amp;lt;- request(&amp;quot;europe.gopl.io&amp;quot;) }()
    go func() { responses &amp;lt;- request(&amp;quot;americas.gopl.io&amp;quot;) }()
    return &amp;lt;-responses // return the quickest response
}

func request(hostname string) (response string) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的竞速和下面有什么区别呢？下面的竞速使用了无缓存的channel，两个比较慢的goroutine将因为channel无人接收而永远卡住，并且不会被自动回收，从而导致goroutine泄漏。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func mirroredQuery() string {
    responses := make(chan string)
    go func() { responses &amp;lt;- request(&amp;quot;asia.gopl.io&amp;quot;) }()
    go func() { responses &amp;lt;- request(&amp;quot;europe.gopl.io&amp;quot;) }()
    go func() { responses &amp;lt;- request(&amp;quot;americas.gopl.io&amp;quot;) }()
    return &amp;lt;-responses // return the quickest response
}

func request(hostname string) (response string) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;pipeline串联channels&#34;&gt;pipeline(串联channels)&lt;/h2&gt;
&lt;p&gt;channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline），见下例和图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main() {
    naturals := make(chan int)
    squares := make(chan int)

    // Counter
    go func() {
        for x := 0; x &amp;lt; 100; x++ {
            naturals &amp;lt;- x
        }
        close(naturals)
    }()

    // Squarer
    go func() {
        for x := range naturals {
            squares &amp;lt;- x * x
        }
        close(squares)
    }()

    // Printer (in main goroutine)
    for x := range squares {
        fmt.Println(x)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://tianqizhang93.github.io/images/Golang-Tips/pipeline.png&#34; alt=&#34;pipeline&#34;&gt;
counter是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给squarer求平方，squarer将平方结果通过第二个channel发送给printer。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;并发的非阻塞缓存&#34;&gt;并发的非阻塞缓存&lt;/h2&gt;
&lt;p&gt;场景：缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了。
需求：并发安全，且避免对整个缓存加锁而导致所有操作都去争一个锁。&lt;/p&gt;
&lt;p&gt;函数例程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 进行HTTP GET请求并且获取http响应body, 开销大, 应避免在不必要的时候反复调用
func httpGetBody(url string) (interface{}, error) {
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    return ioutil.ReadAll(resp.Body)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;缓存实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Package memo provides a concurrency-unsafe
// memoization of a function of type Func.
package memo

// A Memo caches the results of calling a Func.
type Memo struct {
    f     Func
    cache map[string]result
}

// Func is the type of the function to memoize.
type Func func(key string) (interface{}, error)

type result struct {
    value interface{}
    err   error
}

func New(f Func) *Memo {
    return &amp;amp;Memo{f: f, cache: make(map[string]result)}
}

// NOTE: not concurrency-safe!
func (memo *Memo) Get(key string) (interface{}, error) {
    res, ok := memo.cache[key]
    if !ok {
        res.value, res.err = memo.f(key)
        memo.cache[key] = res
    }
    return res.value, res.err
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;顺序的测试缓存：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m := memo.New(httpGetBody)
for url := range incomingURLs() {
    start := time.Now()
    value, err := m.Get(url)
    if err != nil {
        log.Print(err)
    }
    fmt.Printf(&amp;quot;%s, %s, %d bytes\n&amp;quot;,
    url, time.Since(start), len(value.([]byte)))
}
------------------------------------------------
output:

https://golang.org, 175.026418ms, 7537 bytes
https://godoc.org, 172.686825ms, 6878 bytes
https://play.golang.org, 115.762377ms, 5767 bytes
http://gopl.io, 749.887242ms, 2856 bytes
https://golang.org, 721ns, 7537 bytes
https://godoc.org, 152ns, 6878 bytes
https://play.golang.org, 205ns, 5767 bytes
http://gopl.io, 326ns, 2856 bytes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么如果像下面这样并发的测试缓存，由于Get函数不是concurrency-safe，所有会有数据竞争。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m := memo.New(httpGetBody)
var n sync.WaitGroup
for url := range incomingURLs() {
    n.Add(1)
    go func(url string) {
        start := time.Now()
        value, err := m.Get(url)
        if err != nil {
            log.Print(err)
        }
        fmt.Printf(&amp;quot;%s, %s, %d bytes\n&amp;quot;,
        url, time.Since(start), len(value.([]byte)))
        n.Done()
    }(url)
}
n.Wait()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用-race来观察数据竞争会看到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
WARNING: DATA RACE
Write by goroutine 36:
  runtime.mapassign1()
      ~/go/src/runtime/hashmap.go:411 +0x0
  ***
      ***
  ...
Previous write by goroutine 35:
  runtime.mapassign1()
      ~/go/src/runtime/hashmap.go:411 +0x0
  ***
      ***
...
Found 1 data race(s)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;消除数据竞争最简单的方法就是加锁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Memo struct {
    f     Func
    mu    sync.Mutex // guards cache
    cache map[string]result
}

// Get is concurrency-safe.
func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    res, ok := memo.cache[key]
    if !ok {
        res.value, res.err = memo.f(key)
        memo.cache[key] = res
    }
    memo.mu.Unlock()
    return res.value, res.err
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是加了这个锁，Get就将本来可以并行的I/O操作串行化了。&lt;/p&gt;
&lt;p&gt;怎么优化呢？上面Lock锁的范围太大了，考虑缩小临界区，下面的优化把开销最大的I/O操作从临界区分离出来，使得I/O操作可并发，但是，对于相同的&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;memo.f(key)&lt;/code&gt;可能会重复执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    res, ok := memo.cache[key]
    memo.mu.Unlock()
    if !ok {
        res.value, res.err = memo.f(key)

        // Between the two critical sections, several goroutines
        // may race to compute f(key) and update the map.
        
        memo.mu.Lock()
        memo.cache[key] = res
        memo.mu.Unlock()
    }
    return res.value, res.err
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述的重复工作是应该避免的，这也有个专业名词，叫&lt;strong&gt;duplicate suppression(重复抑制)&lt;/strong&gt;。看下面的优化。获取互斥锁来保护共享变量cache map，查询map中是否存在指定条目，如果没有找到那么分配空间插入一个新条目，释放互斥锁。如果存在条目的话且其值没有写入完成(也就是有其它的goroutine在调用f这个慢函数)时，goroutine必须等待值ready之后才能读到条目的结果。而想知道是否ready的话，可以直接从ready channel中读取，由于这个读取操作在channel关闭之前一直是阻塞。
如果没有条目的话，需要向map中插入一个没有准备好的条目，当前正在调用的goroutine就需要负责调用慢函数、更新条目以及向其它所有goroutine广播条目已经ready可读的消息了。
条目中的e.res.value和e.res.err变量是在多个goroutine之间共享的。创建条目的goroutine同时也会设置条目的值，其它goroutine在收到&amp;quot;ready&amp;quot;的广播消息之后立刻会去读取条目的值。尽管会被多个goroutine同时访问，但却并不需要互斥锁。ready channel的关闭一定会发生在其它goroutine接收到广播事件之前，因此第一个goroutine对这些变量的写操作是一定发生在这些读操作之前的。不会发生数据竞争。
这样&lt;strong&gt;并发、不重复、无阻塞&lt;/strong&gt;的cache就完成了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type entry struct {
    res   result
    ready chan struct{} // closed when res is ready
}

func New(f Func) *Memo {
    return &amp;amp;Memo{f: f, cache: make(map[string]*entry)}
}

type Memo struct {
    f     Func
    mu    sync.Mutex // guards cache
    cache map[string]*entry
}

func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    e := memo.cache[key]
    if e == nil {
        // This is the first request for this key.
        // This goroutine becomes responsible for computing
        // the value and broadcasting the ready condition.
        e = &amp;amp;entry{ready: make(chan struct{})}
        memo.cache[key] = e
        memo.mu.Unlock()

        e.res.value, e.res.err = memo.f(key)

        close(e.ready) // broadcast ready condition
    } else {
        // This is a repeat request for this key.
        memo.mu.Unlock()

        &amp;lt;-e.ready // wait for ready condition
    }
    return e.res.value, e.res.err
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的例子使用互斥量来保护多个goroutine调用Get时的共享map变量。接下来使用monitor goroutine(把map变量限制在一个单独goroutine)方案再实现一遍，使用monitor goroutine是需要使用到消息。（&lt;strong&gt;即对比下共享内存通信和消息通信&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Func is the type of the function to memoize.
type Func func(key string) (interface{}, error)

// A result is the result of calling a Func.
type result struct {
    value interface{}
    err   error
}

type entry struct {
    res   result
    ready chan struct{} // closed when res is ready
}

// A request is a message requesting that the Func be applied to key.
type request struct {
    key      string
    response chan&amp;lt;- result // the client wants a single result
}

type Memo struct{ requests chan request }
// New returns a memoization of f.  Clients must subsequently call Close.
func New(f Func) *Memo {
    memo := &amp;amp;Memo{requests: make(chan request)}
    go memo.server(f)
    return memo
}

func (memo *Memo) Get(key string) (interface{}, error) {
    response := make(chan result)
    memo.requests &amp;lt;- request{key, response}
    res := &amp;lt;-response
    return res.value, res.err
}

func (memo *Memo) Close() { close(memo.requests) }

func (memo *Memo) server(f Func) {
    cache := make(map[string]*entry)
    for req := range memo.requests {
        e := cache[req.key]
        if e == nil {
            // This is the first request for this key.
            e = &amp;amp;entry{ready: make(chan struct{})}
            cache[req.key] = e
            go e.call(f, req.key) // call f(key)
        }
        go e.deliver(req.response)
    }
}

func (e *entry) call(f Func, key string) {
    // Evaluate the function.
    e.res.value, e.res.err = f(key)
    // Broadcast the ready condition.
    close(e.ready)
}

func (e *entry) deliver(response chan&amp;lt;- result) {
    // Wait for the ready condition.
    &amp;lt;-e.ready
    // Send the result to the client.
    response &amp;lt;- e.res
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;context&#34;&gt;context&lt;/h2&gt;
&lt;p&gt;context翻译：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;上下文;语境;(事情发生的)背景，环境
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上下文，按我个人通俗的理解，就是一段代码(线程、协程等调度单元)在CPU的寄存器状态集，运行代码就把这段状态加载到寄存器，切出代码就把寄存器的状态保存到缓存或内存。&lt;/p&gt;
&lt;p&gt;go的context本质上也是goroutine间通信的工具，用于在多个goroutine之间共享消息。channel是goroutine之间传递消息的桥梁，当然也可以用来传递一个关闭信号(channel+select实现)，但是如果需要“广播”，可以使用close channel的方式发送一个“广播”信号；context其实就是帮助做了“广播”，其Done方法就是利用一个 &lt;code&gt;&amp;lt;-chan struct{}&lt;/code&gt; 的关闭来实现“广播”效果；此外，context还能存储一些信息，用来在多个goroutine之间共享。&lt;/p&gt;
&lt;p&gt;关于context的几点说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx&lt;/li&gt;
&lt;li&gt;不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo&lt;/li&gt;
&lt;li&gt;不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据，例如：登陆的 session、cookie 等&lt;/li&gt;
&lt;li&gt;同一个 context 可能会被传递到多个 goroutine，但 context 是并发安全，所以没关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几个关键函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Background returns a non-nil, empty Context. It is never canceled, has no
// values, and has no deadline. It is typically used by the main function,
// initialization, and tests, and as the top-level Context for incoming
// requests.
func Background() Context

// TODO returns a non-nil, empty Context. Code should use context.TODO when
// it&#39;s unclear which Context to use or it is not yet available (because the
// surrounding function has not yet been extended to accept a Context
// parameter).
func TODO() Context

// 与共享信息有关的 WithValue

// WithValue returns a copy of parent in which the value associated with key is
// val.
//
// Use context Values only for request-scoped data that transits processes and
// APIs, not for passing optional parameters to functions.
//
// The provided key must be comparable and should not be of type
// string or any other built-in type to avoid collisions between
// packages using context. Users of WithValue should define their own
// types for keys. To avoid allocating when assigning to an
// interface{}, context keys often have concrete type
// struct{}. Alternatively, exported context key variables&#39; static
// type should be a pointer or interface.
func WithValue(parent Context, key, val interface{}) Context

// 与“广播”控制有关的 WithCancel WithDeadline WithTimeout

// WithCancel returns a copy of parent with a new Done channel. The returned
// context&#39;s Done channel is closed when the returned cancel function is called
// or when the parent context&#39;s Done channel is closed, whichever happens first.
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this Context complete.
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

// WithDeadline returns a copy of the parent context with the deadline adjusted
// to be no later than d. If the parent&#39;s deadline is already earlier than d,
// WithDeadline(parent, d) is semantically equivalent to parent. The returned
// context&#39;s Done channel is closed when the deadline expires, when the returned
// cancel function is called, or when the parent context&#39;s Done channel is
// closed, whichever happens first.
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this Context complete.
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)

// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;从上面函数的定义可以看到，context的cancelFunc是与context一同分开返回的，context 本身并没有取消函数，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：由父节点 context 流向子节点 context&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举个简单栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	background := context.Background()

	// input values
	values := map[string]string{
		&amp;quot;key1&amp;quot;: &amp;quot;value1&amp;quot;,
		&amp;quot;key2&amp;quot;: &amp;quot;value2&amp;quot;,
	}
	ctxWithValue, _ := context.WithCancel(background)
	for k, v := range values {
		ctxWithValue = context.WithValue(ctxWithValue, k, v)
	}

	// timeout: 10s, protect usage
	ctxWithTimeout, cancelFunc := context.WithTimeout(ctxWithValue, time.Second*10)

	goroutineCount := 10
	for i := 0; i &amp;lt; goroutineCount; i++ {
		go func(ctx context.Context, index int) {

			count := 0

			for {
				fmt.Println(&amp;quot;gouroutine index: &amp;quot;, index, &amp;quot; &amp;quot;, &amp;quot;count: &amp;quot;, 
				count, &amp;quot; &amp;quot;, &amp;quot;key1: &amp;quot;, ctx.Value(&amp;quot;key1&amp;quot;))

				count++
				time.Sleep(time.Millisecond * 500)
			}

		}(ctxWithTimeout, i)
	}

	// sleep 3s, actually should do something
	time.Sleep(time.Second * 3)

	cancelFunc()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;context可能不是很完美：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ctx放在函数第一个参数，导致代码中ctx泛滥&lt;/li&gt;
&lt;li&gt;ctx创建子节点，底层实际是在链表中创建节点，链表的O(n)有些时候会降低效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，context简便的解决了&amp;quot;cancelation&amp;quot;的问题。只能说任何东西都有两面吧。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;atomictodo&#34;&gt;atomic(TODO)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;topic1: atomic用法总结&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原子操作是在执行中不能被中断的操作，通常由CPU芯片级能力来保证，并由操作系统提供调用，golang基于操作系统的能力，也提供了基于原子操作的支持。&lt;/p&gt;
&lt;p&gt;atomic与mutex的区别：原子操作是能保证执行期间连续的，不会被中断；临界区只能保证访问共享数据是按顺序访问的，但不保证访问期间不会被切换context。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;_test包&#34;&gt;*_test包&lt;/h2&gt;
&lt;p&gt;包net/url(例子)同路径可以再声明一个net/url_test包。包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。
可以将这个外部测试包的导入路径视作是net/url_test会，但是实际上，它并不能被其他任何包导入。&lt;/p&gt;
&lt;p&gt;包内测试函数就可以测试逻辑，为啥还要搞外部测试包？
&lt;strong&gt;外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包，包内的测试代码无法做到这点&lt;/strong&gt;。
在设计层面，外部测试包是在所有它依赖的包的上层。
举个具体的例子，B包依赖的A包，A包在进行测试时，希望使用B包的功能，可是如果A直接importB，那么就发生了循环依赖，将导致编译报错。此时就可以在A内开一个A_test的外部测试包，这个测试包可以以一个第三方包的角色同时import A B，这样就可以测试了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;别写脆弱的测试代码&#34;&gt;别写脆弱的测试代码&lt;/h2&gt;
&lt;p&gt;避免脆弱测试代码的方法是只检测真正关心的属性。&lt;/p&gt;
&lt;p&gt;保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串（很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试）。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;go-test-配合-go-tool-cover-检查代码测试覆盖率&#34;&gt;go test 配合 go tool cover 检查代码测试覆盖率&lt;/h2&gt;
&lt;p&gt;关于&lt;code&gt;go test&lt;/code&gt;, &lt;code&gt;go tool cover&lt;/code&gt;可具体查看命令文档。&lt;/p&gt;
&lt;p&gt;实践：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 生成测试文件test-tmp.out
// -coverprofile 通过在测试代码中插入生成钩子来统计覆盖率数据
// 在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入输出文件，并打印一部分执行的语句的一个总结
// 如果只需要摘要，可以使用 -cover
go test -covermode=count -coverprofile=test-tmp.out ./...

// 浏览器html形式查看测试报告
go tool cover -html=test-tmp.out
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;go-test-性能分析&#34;&gt;go test 性能分析&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;go test -cpuprofile=cpu.out         // cpu
go test -blockprofile=block.out     // 阻塞：记录阻塞goroutine最久的操作
go test -memprofile=mem.out         // 内存
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;使用reflect访问仅访问无法修改struct非导出成员&#34;&gt;使用reflect访问(仅访问无法修改)struct非导出成员&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package testpac

type ReflectTestStruct struct {
	Name string // export
	age  int    // not export
}

func (r *ReflectTestStruct) SetAge(age int) {
	r.age = age
}

-------------------------------------------

package main

func main() {
	rts1 := testpac.ReflectTestStruct{
		Name: &amp;quot;test1&amp;quot;,
	}
	
	rts1e := reflect.ValueOf(&amp;amp;rts1).Elem()

	rts1.SetAge(28)
	
	fmt.Println(&amp;quot;ReflectTestStruct.age: &amp;quot;, rts1e.FieldByName(&amp;quot;age&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;高效的使用reflecttodo&#34;&gt;高效的使用reflect(TODO)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;topic1: reflect用法总结&lt;/li&gt;
&lt;li&gt;topic2: 分析反射导致性能下降的理论原因&lt;/li&gt;
&lt;li&gt;topic3: 调研golang原生序列化/反序列化和几个其他实现的区别，看看大家的优化思路，和优化点适用的场景&lt;/li&gt;
&lt;li&gt;topic4: 总结下反射使用过程中一些能减轻性能下滑的小tips(可能需要跑大量的benchmark测试各个反射函数的性能对比分析)
&lt;ul&gt;
&lt;li&gt;例如预先通过字段名或者方法名获取到对应的字段序号，使用Field(n)/Method(n)，而不是频繁使用FieldByName()/MethodByName()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，日常代码是不建议使用反射的。然后，使用反射必然会导致性能下降，但是还是能通过恰当的使用方法做到性能下滑少一些。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;内存对齐&#34;&gt;内存对齐&lt;/h2&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type demo1 struct {
	a int8
	b int16
	c int32
}

type demo2 struct {
	a int8
	c int32
	b int16
}

type demo3 struct {
	a int8
	c int32
	b int16
	d int16
}

func main() {
   fmt.Println(unsafe.Sizeof(demo1{})) // 8
	fmt.Println(unsafe.Sizeof(demo2{})) // 12
	fmt.Println(unsafe.Sizeof(demo3{})) // 12
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;demo1:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节&lt;/li&gt;
&lt;li&gt;b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节&lt;/li&gt;
&lt;li&gt;c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;demo2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节&lt;/li&gt;
&lt;li&gt;c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节&lt;/li&gt;
&lt;li&gt;b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节&lt;/li&gt;
&lt;li&gt;最终，demo2 的对齐倍数由 c 的对齐倍数决定，也是 4，因此，demo2还要占据 2 字节 ，内存占用为 12 字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;demo3:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节&lt;/li&gt;
&lt;li&gt;c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节&lt;/li&gt;
&lt;li&gt;b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节&lt;/li&gt;
&lt;li&gt;d 是第四个字段，对齐倍数为 2，从第 10 个位置开始占据 2 字节&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;空-struct-的内存对齐&#34;&gt;空 struct{} 的内存对齐&lt;/h2&gt;
&lt;p&gt;空 struct{} 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 作为结构体最后一个字段时，需要内存对齐。&lt;strong&gt;因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type demo3 struct {
	c int32
	a struct{}
}

type demo4 struct {
	a struct{}
	c int32
}

func main() {
	fmt.Println(unsafe.Sizeof(demo3{})) // 8
	fmt.Println(unsafe.Sizeof(demo4{})) // 4
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;golang指针运算&#34;&gt;Golang指针运算&lt;/h2&gt;
&lt;p&gt;Go的指针是不支持运算的，但是借助unsafe.Pointer和uintptr可以实现这个骚操作。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;概念&lt;/th&gt;
&lt;th&gt;持有对象(即指针不释放，其持有的对象GC无法回收)&lt;/th&gt;
&lt;th&gt;指针运算&lt;/th&gt;
&lt;th&gt;转换&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;普通的指针，传递对象的地址&lt;/td&gt;
&lt;td&gt;可持有&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;与unsafe.Pointer相互转换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsafe.Pointer&lt;/td&gt;
&lt;td&gt;类似C的void*，可以包含任意类型变量的地址&lt;/td&gt;
&lt;td&gt;可持有&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;与 *和uintptr 相互转换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uintptr&lt;/td&gt;
&lt;td&gt;可以理解为一个纯数值?(字节长度与int一致，uintptr is an integer type that is large enough to hold the bit pattern of any pointer)&lt;/td&gt;
&lt;td&gt;不可持有(GC 不把 uintptr 当指针，uintptr 类型的目标会被回收)&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;与unsafe.Pointer相互转换&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如上表，&lt;strong&gt;unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main
  ​
  import (
      &amp;quot;fmt&amp;quot;
      &amp;quot;unsafe&amp;quot;
  )
  ​
  func main() {
      //定义一个长度为3的int8类型数组
      a:=[3]int8{6,8,9}
      //取出数组第一个位置的地址
      a_first_point:=&amp;amp;a[0]
      a_first_unsafe_point:=unsafe.Pointer(a_first_point)
      fmt.Println(&amp;quot;a[0]的地址为：&amp;quot;,a_first_unsafe_point)
      //指针只能一个字节字节取，int8占一个字节，所以看到值只加了1
      fmt.Println(&amp;quot;a[1]的地址为：&amp;quot;,unsafe.Pointer(&amp;amp;a[1]))
      //把a_first_unsafe_point转成uintptr类型，就可以指针运算了
      a_uintptr_first_unsafe_point:=uintptr(a_first_unsafe_point)
      //指针+1 表示到了数组的第二个位置
      a_uintptr_first_unsafe_point++
      fmt.Println(&amp;quot;a[0]位置指针自增1后，的指针位置：&amp;quot;,a_uintptr_first_unsafe_point)
      //打印出来可以看到跟&amp;amp;a[1]的地址是一样的
      a_uintptr_second_unsafe_point:=unsafe.Pointer(a_uintptr_first_unsafe_point)
      fmt.Println(&amp;quot;a[0]位置指针自增1后，的指针位置，转成unsafe_Pointer类型：&amp;quot;,a_uintptr_second_unsafe_point)
      //将该指针转换成 *int8类型（因为它本身就是*int8类型）
      int8_point:=(*int8)(a_uintptr_second_unsafe_point)
      //解引用，得到指针对应的结果，就是数组的第二个值，8
      fmt.Println(*int8_point)  ​
}

--------------------------

output:

a[0]的地址为： 0xc000118000
a[1]的地址为： 0xc000118001
a[0]位置指针自增1后，的指针位置： 824634867713
a[0]位置指针自增1后，的指针位置，转成unsafe_Pointer类型： 0xc000118001
8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再举个正反栗：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// right
var x struct {
    a bool
    b int16
    c []int
}

// 和 pb := &amp;amp;x.b 等价
pb := (*int16)(unsafe.Pointer(
    uintptr(unsafe.Pointer(&amp;amp;x)) + unsafe.Offsetof(x.b)))
*pb = 42
fmt.Println(x.b) // &amp;quot;42&amp;quot;

------------------------------------

// wrong
// NOTE: subtly incorrect!
// 错误的原因是引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针
// 当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的&amp;amp;x.b地址
// 第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序
tmp := uintptr(unsafe.Pointer(&amp;amp;x)) + unsafe.Offsetof(x.b)
pb := (*int16)(unsafe.Pointer(tmp))
*pb = 42

------------------------------------

// 错误的原因是，并没有指针引用new新创建的变量，因此该语句执行完成之后，
// 垃圾收集器有权马上回收其内存空间，所以返回的pT将是无效的地址
pT := uintptr(unsafe.Pointer(new(T)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看了上面的例子，当从其他地方获取到了&lt;code&gt;uintptr&lt;/code&gt;以后，为了避免GC回收其对应地址的变量，应该尽快将&lt;code&gt;uintptr&lt;/code&gt;转化为&lt;code&gt;unsafe.Pointer&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cgotodo&#34;&gt;cgo(TODO)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;topic1: cgo用法总结&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cgo如果c代码在go文件同目录下的c文件内，必须&lt;code&gt;go run .&lt;/code&gt;或者&lt;code&gt;go build&lt;/code&gt;才能在编译阶段把.c文件编译进来，&lt;code&gt;go run main.go&lt;/code&gt;不行&lt;/p&gt;
&lt;hr&gt;
- https://tianqizhang93.github.io/posts/go-tips/ - ztq.</description>
        </item>
    
    
    
        <item>
        <title>The Go Programming Language</title>
        <link>https://tianqizhang93.github.io/posts/the-go-programming-language/</link>
        <pubDate>Fri, 25 Jun 2021 22:35:37 +0800</pubDate>
        
        <guid>https://tianqizhang93.github.io/posts/the-go-programming-language/</guid>
        <description>Home Page https://tianqizhang93.github.io/posts/the-go-programming-language/ -&lt;p&gt;说明：
《The Go Programming Language》
所有源码见: &lt;a href=&#34;https://github.com/adonovan/gopl.io&#34;&gt;gopl.io&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;0-前言&#34;&gt;0 前言&lt;/h1&gt;
&lt;p&gt;GO演进，B-&amp;gt;C-&amp;gt;GO。&lt;/p&gt;
&lt;p&gt;GO官方定位：Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。&lt;/p&gt;
&lt;h2 id=&#34;01-go语言起源&#34;&gt;0.1 GO语言起源&lt;/h2&gt;
&lt;p&gt;下图展示了有哪些早期语言对Go语言的设计产生了重要影响。
&lt;img src=&#34;https://tianqizhang93.github.io/images/The-Go-Programming-Language/go-origin.png&#34; alt=&#34;gpl-01&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;02-go语言项目&#34;&gt;0.2 GO语言项目&lt;/h2&gt;
&lt;p&gt;Go语言的&lt;strong&gt;动态栈&lt;/strong&gt;使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。&lt;/p&gt;
&lt;p&gt;Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。&lt;/p&gt;
&lt;p&gt;Go语言源代码本身就包含了构建规范。&lt;/p&gt;
&lt;h1 id=&#34;1-入门&#34;&gt;1 入门&lt;/h1&gt;
&lt;p&gt;把Go写的像Go。&lt;/p&gt;
&lt;h2 id=&#34;11-hello-world&#34;&gt;1.1 Hello, World&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;Hello, World&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go是编译型语言，静态编译。&lt;/p&gt;
&lt;p&gt;Go语言原生支持Unicode，可处理任何语言。&lt;/p&gt;
&lt;p&gt;Go的工具都通过&amp;quot;go&amp;quot;命令调用，具体可&amp;quot;go help&amp;quot;。&lt;/p&gt;
&lt;p&gt;Go语言通过包(package)组织。包引用使用&amp;quot;import&amp;quot;。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;main&amp;quot;包的&amp;quot;main&amp;quot;函数是这个程序执行的入口。&lt;/p&gt;
&lt;p&gt;Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析。&lt;/p&gt;
&lt;h2 id=&#34;12-命令行参数&#34;&gt;1.2 命令行参数&lt;/h2&gt;
&lt;p&gt;Go区间索引左闭右开。
自增语句i++给i加1；这和i += 1以及i = i + 1都是等价的。对应的还有i&amp;ndash;给i减1。它们是语句，而不像C系的其它语言那样是表达式。所以j = i++非法，而且++和&amp;ndash;都只能放在变量名后面，因此&amp;ndash;i也非法。&lt;/p&gt;
&lt;p&gt;Go语言只有for循环这一种循环语句，for循环有多种形式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// situation 1
for initialization; condition; post {
    // zero or more statements
}

// situation 2
// a traditional &amp;quot;while&amp;quot; loop
for condition {
    // ...
}

// situation 3
// a traditional infinite loop
for {
    // ...
}

// situation 4
for index, value := range someSlice {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;声明一个变量有几种方式，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s := &amp;quot;&amp;quot;
var s string
var s = &amp;quot;&amp;quot;
var s string = &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用哪种不用哪种，为什么呢？第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为&amp;rdquo;&amp;quot;。第三种形式用得很少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。&lt;/p&gt;
&lt;h2 id=&#34;13-查找重复的行&#34;&gt;1.3 查找重复的行&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// Dup1 prints the text of each line that appears more than
// once in the standard input, preceded by its count.
package main

import (
    &amp;quot;bufio&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
)

func main() {
    counts := make(map[string]int)
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        // map中不含某个键时不用担心，首次读到新行时，等号右边的表达式counts[line]的值将被计算为其类型的零值，对于int即0
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
    for line, n := range counts {
        // map的迭代顺序并不确定，从实践来看，该顺序随机，每次运行都会变化
        if n &amp;gt; 1 {
            fmt.Printf(&amp;quot;%d\t%s\n&amp;quot;, n, line)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;// Dup2 prints the count and text of lines that appear more than once
// in the input.  It reads from stdin or from a list of named files.
package main

import (
    &amp;quot;bufio&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
)

func main() {
    counts := make(map[string]int)
    files := os.Args[1:]
    if len(files) == 0 {
        countLines(os.Stdin, counts)
    } else {
        for _, arg := range files {
            f, err := os.Open(arg)
            if err != nil {
                fmt.Fprintf(os.Stderr, &amp;quot;dup2: %v\n&amp;quot;, err)
                continue
            }
            countLines(f, counts)
            f.Close()
        }
    }
    for line, n := range counts {
        if n &amp;gt; 1 {
            fmt.Printf(&amp;quot;%d\t%s\n&amp;quot;, n, line)
        }
    }
}

func countLines(f *os.File, counts map[string]int) {
    input := bufio.NewScanner(f)
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;strings&amp;quot;
)

func main() {
    counts := make(map[string]int)
    for _, filename := range os.Args[1:] {
        data, err := ioutil.ReadFile(filename)
        if err != nil {
            fmt.Fprintf(os.Stderr, &amp;quot;dup3: %v\n&amp;quot;, err)
            continue
        }
        for _, line := range strings.Split(string(data), &amp;quot;\n&amp;quot;) {
            counts[line]++
        }
    }
    for line, n := range counts {
        if n &amp;gt; 1 {
            fmt.Printf(&amp;quot;%d\t%s\n&amp;quot;, n, line)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;14-gif动画&#34;&gt;1.4 GIF动画&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// Lissajous generates GIF animations of random Lissajous figures.
package main

import (
    &amp;quot;image&amp;quot;
    &amp;quot;image/color&amp;quot;
    &amp;quot;image/gif&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;math&amp;quot;
    &amp;quot;math/rand&amp;quot;
    &amp;quot;os&amp;quot;
)

var palette = []color.Color{color.White, color.Black}

const (
    whiteIndex = 0 // first color in palette
    blackIndex = 1 // next color in palette
)

func main() {
    // The sequence of images is deterministic unless we seed
    // the pseudo-random number generator using the current time.
    // Thanks to Randall McPherson for pointing out the omission.
    rand.Seed(time.Now().UTC().UnixNano())
    lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
    const (
        cycles  = 5     // number of complete x oscillator revolutions
        res     = 0.001 // angular resolution
        size    = 100   // image canvas covers [-size..+size]
        nframes = 64    // number of animation frames
        delay   = 8     // delay between frames in 10ms units
    )

    freq := rand.Float64() * 3.0 // relative frequency of y oscillator
    anim := gif.GIF{LoopCount: nframes}
    phase := 0.0 // phase difference
    for i := 0; i &amp;lt; nframes; i++ {
        rect := image.Rect(0, 0, 2*size+1, 2*size+1)
        img := image.NewPaletted(rect, palette)
        for t := 0.0; t &amp;lt; cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
                blackIndex)
        }
        phase += 0.1
        anim.Delay = append(anim.Delay, delay)
        anim.Image = append(anim.Image, img)
    }
    gif.EncodeAll(out, &amp;amp;anim) // NOTE: ignoring encoding errors
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;15-获取url&#34;&gt;1.5 获取URL&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// Fetch prints the content found at a URL.
package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;os&amp;quot;
)

func main() {
    for _, url := range os.Args[1:] {
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, &amp;quot;fetch: %v\n&amp;quot;, err)
            os.Exit(1)
        }
        b, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil {
            fmt.Fprintf(os.Stderr, &amp;quot;fetch: reading %s: %v\n&amp;quot;, url, err)
            os.Exit(1)
        }
        fmt.Printf(&amp;quot;%s&amp;quot;, b)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;16-并发获取多个url&#34;&gt;1.6 并发获取多个URL&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// Fetchall fetches URLs in parallel and reports their times and sizes.
package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {
    start := time.Now()
    ch := make(chan string)
    for _, url := range os.Args[1:] {
        go fetch(url, ch) // start a goroutine
    }
    for range os.Args[1:] {
        fmt.Println(&amp;lt;-ch) // receive from channel ch
    }
    fmt.Printf(&amp;quot;%.2fs elapsed\n&amp;quot;, time.Since(start).Seconds())
}

func fetch(url string, ch chan&amp;lt;- string) {
    start := time.Now()
    resp, err := http.Get(url)
    if err != nil {
        ch &amp;lt;- fmt.Sprint(err) // send to channel ch
        return
    }
    nbytes, err := io.Copy(ioutil.Discard, resp.Body)
    resp.Body.Close() // don&#39;t leak resources
    if err != nil {
        ch &amp;lt;- fmt.Sprintf(&amp;quot;while reading %s: %v&amp;quot;, url, err)
        return
    }
    secs := time.Since(start).Seconds()
    ch &amp;lt;- fmt.Sprintf(&amp;quot;%.2fs  %7d  %s&amp;quot;, secs, nbytes, url)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;17-web服务&#34;&gt;1.7 Web服务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// Server1 is a minimal &amp;quot;echo&amp;quot; server.
package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
)

func main() {
    http.HandleFunc(&amp;quot;/&amp;quot;, handler) // each request calls handler
    log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

// handler echoes the Path component of the request URL r.
func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &amp;quot;URL.Path = %q\n&amp;quot;, r.URL.Path)
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;// Server2 is a minimal &amp;quot;echo&amp;quot; and counter server.
package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;sync&amp;quot;
)

var mu sync.Mutex
var count int

func main() {
    http.HandleFunc(&amp;quot;/&amp;quot;, handler)
    http.HandleFunc(&amp;quot;/count&amp;quot;, counter)
    log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

// handler echoes the Path component of the requested URL.
func handler(w http.ResponseWriter, r *http.Request) {
    mu.Lock()
    count++
    mu.Unlock()
    fmt.Fprintf(w, &amp;quot;URL.Path = %q\n&amp;quot;, r.URL.Path)
}

// counter echoes the number of calls so far.
func counter(w http.ResponseWriter, r *http.Request) {
    mu.Lock()
    fmt.Fprintf(w, &amp;quot;Count %d\n&amp;quot;, count)
    mu.Unlock()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;2-程序结构&#34;&gt;2 程序结构&lt;/h1&gt;
&lt;p&gt;Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用if和for之类的控制语句来组织和控制表达式的执行流程。然后多个语句被组织到一个个函数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。&lt;/p&gt;
&lt;h2 id=&#34;21-命名&#34;&gt;2.1 命名&lt;/h2&gt;
&lt;p&gt;Golang有25个关键字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Golang内建常量、类型、函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;内建常量: true false iota nil

内建类型:  int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果一个名字是在函数内部定义，那么它就只在函数内部有效（函数内的开头字母大写变量也只是函数内可见）。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。&lt;/p&gt;
&lt;p&gt;Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样，Go语言命名驼峰式，缩略词&amp;amp;专有名词全部大写。&lt;/p&gt;
&lt;h2 id=&#34;22-声明&#34;&gt;2.2 声明&lt;/h2&gt;
&lt;p&gt;Golang声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var     变量
const   常量
type    类型
func    函数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Golang包一级的各种类型的声明语句的顺序无关紧要（函数内部的名字则必须先声明之后才能使用）。&lt;/p&gt;
&lt;h2 id=&#34;23-变量&#34;&gt;2.3 变量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var 变量名 类型 = 表达式
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。&lt;/p&gt;
&lt;p&gt;零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s string
fmt.Println(s) // &amp;quot;&amp;quot;
// 这段代码将打印一个空字符串，而不是导致错误或产生不可预知的行为。
// Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, &amp;quot;four&amp;quot; // bool, float64, string
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;简短变量声明&#34;&gt;简短变量声明&lt;/h3&gt;
&lt;p&gt;函数内部，名字:=表达式，变量的类型根据表达式自动推导。简短变量声明语句也可以用来声明和初始化一组变量，简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了，简短变量声明语句中必须至少要声明一个新的变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var i = 10
i, j := 0, 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果变量是在外部词法域声明，那么简短变量声明语句将会在当前词法域重新声明一个新的变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var title = &amp;quot;new title outside of printTitle&amp;quot;

func printTitle(){
    title := &amp;quot;new title in printTitle&amp;quot;
    fmt.Println(title)
    // 将输出 new title in printTitle
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。&lt;/p&gt;
&lt;h3 id=&#34;指针&#34;&gt;指针&lt;/h3&gt;
&lt;p&gt;一个变量对应一个保存了变量对应类型值的内存空间。&lt;/p&gt;
&lt;p&gt;一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。&lt;strong&gt;并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址&lt;/strong&gt;。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。&lt;/p&gt;
&lt;p&gt;任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。&lt;/p&gt;
&lt;p&gt;在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var p = f()

func f() *int {
    v := 1
    return &amp;amp;v
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;new函数&#34;&gt;new函数&lt;/h3&gt;
&lt;p&gt;另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // &amp;quot;0&amp;quot;
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // &amp;quot;2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p := new(int)
q := new(int)
fmt.Println(p == q) // &amp;quot;false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;变量的生命周期&#34;&gt;变量的生命周期&lt;/h3&gt;
&lt;p&gt;变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。&lt;/p&gt;
&lt;p&gt;那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。&lt;/p&gt;
&lt;p&gt;编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var global *int

func f() {
    var x int
    x = 1
    global = &amp;amp;x
}

func g() {
    y := new(int)
    *y = 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，&lt;em&gt;y并没有从函数g中逃逸，编译器可以选择在栈上分配&lt;/em&gt;y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。&lt;/p&gt;
&lt;p&gt;Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。&lt;strong&gt;例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;24-赋值&#34;&gt;2.4 赋值&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// =
=

// 特定的二元运算符
*=
+=
-=
/=
%=
++
--

// 元组赋值
// 允许同时更新多个变量的值，在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值
var a, b, c int
a, b, c = 1, 2, 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;利用元组赋值 &amp;ldquo;&lt;strong&gt;在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值&lt;/strong&gt;&amp;rdquo; 这一特性，可以做如下操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 交换两个变量值
a, b = b, a
a[i], a[j] = a[j], a[i]

// 计算两个整数的最大公约数(GCD)
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}

// 计算斐波那契数列(Fibonacci)的第n个数：
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i &amp;lt; n; i++ {
        x, y = y, x+y
    }
    return x
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下划线可丢弃不需要的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T)              // 只检测类型，忽略具体值
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;可赋值性&#34;&gt;可赋值性&lt;/h3&gt;
&lt;p&gt;赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;medals := []string{&amp;quot;gold&amp;quot;, &amp;quot;silver&amp;quot;, &amp;quot;bronze&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;隐式地对slice的每个元素进行赋值操作，类似这样写的行为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;medals[0] = &amp;quot;gold&amp;quot;
medals[1] = &amp;quot;silver&amp;quot;
medals[2] = &amp;quot;bronze&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。
不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
nil可以赋值给任何指针或引用类型的变量。
常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。
对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。&lt;/p&gt;
&lt;h2 id=&#34;25-类型&#34;&gt;2.5 类型&lt;/h2&gt;
&lt;p&gt;一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type 类型名字 底层类型
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。
为了说明类型声明，我们将不同温度单位分别定义为不同的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Package tempconv performs Celsius and Fahrenheit temperature computations.
package tempconv

import &amp;quot;fmt&amp;quot;

type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型,如果T是指针类型，可能会需要用小括弧包装T，比如(*int)(0)。
只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的，这类转换可能改变值的表现。例如，将一个浮点数转为整数将丢弃小数部分，将一个字符串转为[]byte类型的slice将拷贝一个字符串数据的副本。在任何情况下，运行时不会发生转换失败的错误（错误只会发生在编译阶段）。&lt;/p&gt;
&lt;p&gt;底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;%g\n&amp;quot;, BoilingC-FreezingC) // &amp;quot;100&amp;quot; °C
boilingF := CToF(BoilingC)
fmt.Printf(&amp;quot;%g\n&amp;quot;, boilingF-CToF(FreezingC)) // &amp;quot;180&amp;quot; °F
fmt.Printf(&amp;quot;%g\n&amp;quot;, boilingF-FreezingC)       // compile error: type mismatch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比较运算符==和&amp;lt;也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var c Celsius
var f Fahrenheit
fmt.Println(c == 0)          // &amp;quot;true&amp;quot;
fmt.Println(f &amp;gt;= 0)          // &amp;quot;true&amp;quot;
fmt.Println(c == f)          // compile error: type mismatch
fmt.Println(c == Celsius(f)) // &amp;quot;true&amp;quot;!
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;26-包和文件&#34;&gt;2.6 包和文件&lt;/h2&gt;
&lt;p&gt;Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、&lt;strong&gt;单独编译&lt;/strong&gt;和代码重用。&lt;/p&gt;
&lt;p&gt;import导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容，在默认情况下，导入的包绑定到该包声明语句指定的名字，但是我们也可以绑定到另一个名称（别名），以避免名字冲突。&lt;/p&gt;
&lt;p&gt;如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理，这种强制规则可以有效减少不必要的依赖。&lt;/p&gt;
&lt;h3 id=&#34;包的初始化&#34;&gt;包的初始化&lt;/h3&gt;
&lt;p&gt;包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果&lt;strong&gt;包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个&lt;strong&gt;特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func init() { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时&lt;strong&gt;按照它们声明的顺序被自动调用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;27-作用域&#34;&gt;2.7 作用域&lt;/h2&gt;
&lt;p&gt;不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。&lt;/p&gt;
&lt;p&gt;声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。&lt;/p&gt;
&lt;p&gt;当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。&lt;strong&gt;在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。&lt;/strong&gt; 要特别注意短变量声明语句的作用域范围：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var cwd string

func init() {
    cwd, err := os.Getwd() // compile error: unused: cwd
    if err != nil {
        log.Fatalf(&amp;quot;os.Getwd failed: %v&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然cwd在外部已经声明过，但是:=语句还是将cwd和err重新声明为新的局部变量。因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使用:=的简短声明方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var cwd string

func init() {
    var err error
    cwd, err = os.Getwd()
    if err != nil {
        log.Fatalf(&amp;quot;os.Getwd failed: %v&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;3-基础数据类型&#34;&gt;3 基础数据类型&lt;/h1&gt;
&lt;p&gt;Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。&lt;/p&gt;
&lt;p&gt;基础类型：数字、字符串、布尔型。&lt;/p&gt;
&lt;p&gt;复合数据类型：数组、结构体。&lt;/p&gt;
&lt;p&gt;引用类型：指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用，这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。&lt;/p&gt;
&lt;p&gt;接口类型，interface后面介绍。&lt;/p&gt;
&lt;h2 id=&#34;31-整型&#34;&gt;3.1 整型&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 有符号
int8        // 8bit, [-128,127]
int16       // 16bit
int32       // 32bit
int64       // 64bit

// 无符号
uint8       // 8bit, [0,255]
uint16      // 16bit
uint32      // 32bit
uint64      // 64bit

// PS
rune == int32
byte == uint8
int != int32 // 即使int也是32bit，转换时需显示的类型转换
uintptr     // 无符号整数类型，没有指定具体的bit大小但是足以容纳指针

/*
PS, Golang中不能直接使用二进制表示一个整数；十进制直接表示；
八进制以数字0开头，011==72；十六进制以0x或0X开头，0x11==17.
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*      /      %      &amp;lt;&amp;lt;       &amp;gt;&amp;gt;     &amp;amp;       &amp;amp;^
+      -      |      ^
==     !=     &amp;lt;      &amp;lt;=       &amp;gt;      &amp;gt;=
&amp;amp;&amp;amp;
||

// PS. 逻辑非 ! 为单目运算符
// PS. &amp;amp;^ , 按位置零 (AND NOT): 如果对应y中bit位为1的话, 表达式z = x &amp;amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值
// PS. 取模运算符%仅用于整数间的运算，%取模运算符的符号和被取模数的符号总是一致的
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;32-浮点数&#34;&gt;3.2 浮点数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;float32     // float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差
float64
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;33-复数&#34;&gt;3.3 复数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;complex32       // 对应float32精度
complex64       // 对应float64精度
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // &amp;quot;(-5+10i)&amp;quot;
fmt.Println(real(x*y))           // &amp;quot;-5&amp;quot;
fmt.Println(imag(x*y))           // &amp;quot;10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0(换句话说，用i表示复数虚部时前面必须带float或int，直接 &amp;ldquo;8 * i&amp;rdquo; 这种表述是非法的，应该使用 &amp;ldquo;8 * 1i&amp;rdquo; 才能表示 &amp;ldquo;(0+8i)&amp;quot;)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fmt.Println(1i * 1i) // &amp;quot;(-1+0i)&amp;quot;, i^2 = -1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;34-布尔型&#34;&gt;3.4 布尔型&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// Golang中boolean true和false定义如下：
// true and false are the two untyped boolean values.
const (
	true  = 0 == 0 // Untyped bool.
	false = 0 != 0 // Untyped bool.
)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;35-字符串&#34;&gt;3.5 字符串&lt;/h2&gt;
&lt;p&gt;文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。&lt;/p&gt;
&lt;p&gt;内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i&amp;lt; len(s)条件约束，如果试图访问超出字符串索引范围的字节将会导致panic异常。&lt;/p&gt;
&lt;p&gt;子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节（如果索引超出字符串范围或者j小于i的话将导致panic异常）。不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s := &amp;quot;hello, world&amp;quot;

fmt.Println(s[:5]) // &amp;quot;hello&amp;quot;
fmt.Println(s[7:]) // &amp;quot;world&amp;quot;
fmt.Println(s[:])  // &amp;quot;hello, world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;+操作符将两个字符串连接构造一个新字符串。字符串可以用==和&amp;lt;进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。&lt;/p&gt;
&lt;p&gt;字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，但是可以给一个字符串变量分配一个新字符串值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s := &amp;quot;left foot&amp;quot;
t := s
s += &amp;quot;, right foot&amp;quot;

fmt.Println(s) // left foot, right foot
fmt.Println(t) // left foot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s := &amp;quot;left foot&amp;quot;
s[0] = &#39;L&#39; // compile error: cannot assign to s[0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得&lt;strong&gt;复制任何长度的字符串代价是低廉的&lt;/strong&gt;。同样，&lt;strong&gt;一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的&lt;/strong&gt;。在这两种情况下都没有必要分配新的内存。&lt;/p&gt;
&lt;h3 id=&#34;字符串面值&#34;&gt;字符串面值&lt;/h3&gt;
&lt;p&gt;在一个双引号包含的字符串面值中，可以用以反斜杠\开头的转义序列插入任意的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\&#39;      单引号 (只用在 &#39;\&#39;&#39; 形式的rune符号面值中)
\&amp;quot;      双引号 (只用在 &amp;quot;...&amp;quot; 形式的字符串面值中)
\\      反斜杠
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个原生的字符串面值形式是`&amp;hellip;`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+&amp;quot;`&amp;ldquo;连接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（Windows系统会把回车和换行一起放入文本文件中）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const GoUsage = `Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...`
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;字符串和byte切片&#34;&gt;字符串和byte切片&lt;/h3&gt;
&lt;p&gt;标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。&lt;/p&gt;
&lt;p&gt;strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。&lt;/p&gt;
&lt;p&gt;bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。&lt;/p&gt;
&lt;p&gt;strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。&lt;/p&gt;
&lt;p&gt;unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。&lt;/p&gt;
&lt;p&gt;一个字符串是包含只读字节的数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。字符串和字节slice之间可以相互转换：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s := &amp;quot;abc&amp;quot;
b := []byte(s)
s2 := string(b)

// 从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组
// 编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变
// 将一个字节slice转换到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的

// bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数
// 据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;36-常量&#34;&gt;3.6 常量&lt;/h2&gt;
&lt;p&gt;常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。
常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof。
如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // &amp;quot;1 1 2 2&amp;quot;

------------------------------------------------------

// iota常量生成器：常量声明可以使用iota常量生成器初始化，它用于
// 生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表
// 达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将
// 会被置为0，然后在每一个有常量声明的行加1
type Weekday int

const (
    Sunday Weekday = iota   // 0
    Monday                  // 1
    Tuesday                 // 2
    Wednesday               // 3
    Thursday
    Friday
    Saturday
)

// 下面是一个更复杂的例子，每个常量都是1024的幂：
const (
    _ = 1 &amp;lt;&amp;lt; (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 &amp;lt;&amp;lt; 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 &amp;lt;&amp;lt; 64)
    YiB // 1208925819614629174706176
)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;无类型常量&#34;&gt;无类型常量&lt;/h3&gt;
&lt;p&gt;Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。
通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。&lt;/p&gt;
&lt;p&gt;举个例子，math包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package math

// Mathematical constants.
const (
	E   = 2.71828182845904523536028747135266249775724709369995957496696763 // https://oeis.org/A001113
	Pi  = 3.14159265358979323846264338327950288419716939937510582097494459 // https://oeis.org/A000796
	Phi = 1.61803398874989484820458683436563811772030917980576286213544862 // https://oeis.org/A001622

	Sqrt2   = 1.41421356237309504880168872420969807856967187537694807317667974 // https://oeis.org/A002193
	SqrtE   = 1.64872127070012814684865078781416357165377610071014801157507931 // https://oeis.org/A019774
	SqrtPi  = 1.77245385090551602729816748334114518279754945612238712821380779 // https://oeis.org/A002161
	SqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038 // https://oeis.org/A139339

	Ln2    = 0.693147180559945309417232121458176568075500134360255254120680009 // https://oeis.org/A002162
	Log2E  = 1 / Ln2
	Ln10   = 2.30258509299404568401799145468436420760110148862877297603332790 // https://oeis.org/A002392
	Log10E = 1 / Ln10
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;math.Pi是一个无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Pi64 float64 = math.Pi

var x float32 = float32(Pi64)
var y float64 = Pi64
var z complex128 = complex128(Pi64)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和\u0000虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。
只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f float64 = 3 + 0i // untyped complex -&amp;gt; float64, 相当于：var f float64 = float64(3 + 0i)
f = 2                  // untyped integer -&amp;gt; float64, 相当于：f = float64(2)
f = 1e123              // untyped floating-point -&amp;gt; float64, 相当于：f = float64(1e123)
f = &#39;a&#39;                // untyped rune -&amp;gt; float64, 相当于：f = float64(&#39;a&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;4-复合数据类型&#34;&gt;4 复合数据类型&lt;/h1&gt;
&lt;p&gt;我们主要讨论四种类型——数组、slice、map和结构体。
数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。&lt;/p&gt;
&lt;h2 id=&#34;41-数组&#34;&gt;4.1 数组&lt;/h2&gt;
&lt;p&gt;默认情况下，数组的每个元素都被初始化为元素类型对应的零值。&lt;/p&gt;
&lt;p&gt;在数组字面值中，如果在数组的长度位置出现的是“&amp;hellip;”省略号，则表示数组的长度是根据初始化值的个数来计算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;q := [...]int{1, 2, 3}
fmt.Printf(&amp;quot;%T\n&amp;quot;, q) // &amp;quot;[3]int&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: &amp;quot;$&amp;quot;, EUR: &amp;quot;€&amp;quot;, GBP: &amp;quot;￡&amp;quot;, RMB: &amp;quot;￥&amp;quot;}

fmt.Println(RMB, symbol[RMB]) // &amp;quot;3 ￥&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r := [...]int{4: -1} // {0, 0, 0, 0, -1}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // &amp;quot;true false false&amp;quot;
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;数组类型作为函数参数传递时会发生值拷贝。&lt;/strong&gt;
PS：要理解这句话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先需要先弄清楚 传值 传指针 传引用 三者的差别&lt;/li&gt;
&lt;li&gt;然后要知道，GO只有传值&lt;/li&gt;
&lt;li&gt;那么为什么对于引用类型修改形参会影响实参呢？这是因为饮用类型内部有一个指针指向了底层数据&lt;/li&gt;
&lt;li&gt;引用类型和传引用是两个完全不同的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-slice&#34;&gt;4.2 slice&lt;/h2&gt;
&lt;p&gt;slice的语法和数组很像，只是没有固定长度而已。slice的底层引用一个数组对象。多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。&lt;/p&gt;
&lt;p&gt;slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;months := [...]string{1: &amp;quot;January&amp;quot;, /* ... */, 12: &amp;quot;December&amp;quot;}

Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // [&amp;quot;April&amp;quot; &amp;quot;May&amp;quot; &amp;quot;June&amp;quot;]
fmt.Println(summer) // [&amp;quot;June&amp;quot; &amp;quot;July&amp;quot; &amp;quot;August&amp;quot;]

fmt.Println(summer[:20]) // panic: out of range

endlessSummer := summer[:5] // extend a slice (within capacity)
fmt.Println(endlessSummer)  // &amp;quot;[June July August September October]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。slice唯一合法的比较操作是和nil比较。
一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。&lt;/p&gt;
&lt;h3 id=&#34;append&#34;&gt;append&lt;/h3&gt;
&lt;p&gt;Go内置的append函数使用比较复杂的内存扩展策略。因此，通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;first := make([]int, 3, 4)
first[0] = 0
first[1] = 1
first[2] = 2
fmt.Println(first, &amp;amp;first[0], len(first), cap(first))

second := append(first, 3)
fmt.Println(second, &amp;amp;second[0], len(second), cap(second))

third := append(first, []int{3, 4, 5}...)
// &amp;amp;third[0] != &amp;amp;first[0], 因为发生了一次扩容，底层结构不共用
fmt.Println(third, &amp;amp;third[0], len(third), cap(third))

// 1. 修改first，由于second通过append生成时未发生扩容，所以second与first共用底层数组，将同时被修改
// 2. 由于third通过append生成时，超过first的容量，发生扩容，将申请新的空间，
// 将first拷贝过来后再执行append动作，因此third与first不共用底层数组，修改first不影响third
first[1] = 10
fmt.Println(first, second, third)

----------------------------------------------------------------------------
output:

[0 1 2] 0xc000126020 3 4
[0 1 2 3] 0xc000126020 4 4
[0 1 2 3 4 5] 0xc000134000 6 8
[0 10 2] [0 10 2 3] [0 1 2 3 4 5]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;43-map&#34;&gt;4.3 map&lt;/h2&gt;
&lt;p&gt;哈希表是一种巧妙并且实用的数据结构。它是一个无序的key-value对的集合（key必须是支持==比较运算符的数据类型，但是将浮点数用做key类型则是一个坏的想法，浮点数==判断受精度影响，最坏的情况是可能出现的NaN和任何浮点数都不相等），其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。在Go语言中，一个map就是一个哈希表的引用。&lt;/p&gt;
&lt;p&gt;map索引失败时将返回零值。&lt;/p&gt;
&lt;p&gt;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ages := map[string]int{&amp;quot;bob&amp;quot;: 22}
_ = &amp;amp;ages[&amp;quot;bob&amp;quot;] // compile error: cannot take address of map element
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向一个nil值的map存入元素将导致一个panic异常。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;map之间也不能进行相等比较；唯一的例外是和nil进行比较。&lt;/p&gt;
&lt;h2 id=&#34;44-结构体&#34;&gt;4.4 结构体&lt;/h2&gt;
&lt;p&gt;结构体相邻成员类型相同可合并到一行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Employee struct{
    ID          int
    Name, Addr  string
    ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结构体成员顺序不同定义为不同的结构体类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身，但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结构体类型的零值是每个成员都是零值。&lt;/p&gt;
&lt;p&gt;如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。&lt;/p&gt;
&lt;p&gt;Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Point struct {
    X, Y int
}

type Circle struct {
    Point
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径。在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var w Wheel
w.X = 8            // equivalent to w.Circle.Point.X = 8
w.Y = 8            // equivalent to w.Circle.Point.Y = 8
w.Radius = 5       // equivalent to w.Circle.Radius = 5
w.Spokes = 20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;w = Wheel{Circle{Point{8, 8}, 5}, 20}

w = Wheel{
    Circle: Circle{
        Point:  Point{X: 8, Y: 8},
        Radius: 5,
    },
    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。&lt;/p&gt;
&lt;p&gt;因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员，&lt;strong&gt;但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;w.X = 8 // equivalent to w.circle.point.X = 8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;45-json&#34;&gt;4.5 JSON&lt;/h2&gt;
&lt;p&gt;一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。&lt;/p&gt;
&lt;p&gt;JSON在编码时，默认使用Go语言结构体的成员名字作为JSON的对象，只有导出的结构体成员才会被编码。&lt;/p&gt;
&lt;p&gt;结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:&amp;ldquo;value&amp;quot;键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/&amp;hellip;下面其它的包也遵循这个约定。&lt;/p&gt;
&lt;p&gt;除了json.Marshal&amp;amp;json.Unmarshal的编解码，还有json.Encoder&amp;amp;json.Decoder的基于流式的编解码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;json.NewEncoder(w).Encode(src)
json.NewDecoder(r).Decode(des)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Golang结构体关于JSON的tag有很多，key==json，关于其含义，官方有解释&lt;a href=&#34;https://golang.org/pkg/encoding/json/#Marshal&#34;&gt;encoding/json/Marshal关于tag的解释&lt;/a&gt;，鸟窝对此也转过一篇taowen的文章&lt;a href=&#34;https://colobu.com/2017/06/21/json-tricks-in-Go/&#34;&gt;鸟窝[转taowen]Golang 中使用 JSON 的小技巧&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;46-text-template--html-template&#34;&gt;4.6 text template &amp;amp; HTML template&lt;/h2&gt;
&lt;p&gt;text/template和html/template模板包提供将变量值填充到一个文本或HTML格式的模板的功能。&lt;/p&gt;
&lt;p&gt;一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的{{action}}对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。&lt;/p&gt;
&lt;h3 id=&#34;text-template实例&#34;&gt;text template实例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;text/template&amp;quot;
)

// 对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”
// 当前值“.”最初被初始化为调用模板时的参数
// 模板中{{range .Items}}和{{end}}对应一个循环action
// printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用
// 在一个action中，|操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念
const personTextTempl = `Name: {{.Name}}, Titles:
{{range .Titles}}////////////////////////////
Title: {{.Title}}
Desc:  {{.Desc}}
Desc1: {{.Desc1 | printf &amp;quot;%.64s&amp;quot;}} (desc1)
Desc2: {{.Desc2 | printDesc}} (desc2)
{{end}}`

// text templates
var (
	personTempl *template.Template
)


type Person struct {
	Name   string
	Titles []Title
}

type Title struct {
	Title string
	Desc  string
	Desc1 string
	Desc2 string
}

func init() {
	var err error

	personTempl, err = template.New(&amp;quot;personTempl&amp;quot;).Funcs(template.FuncMap{&amp;quot;printDesc&amp;quot;: printDescWithPrefix}).Parse(personTextTempl)
	if err != nil {
		fmt.Println(&amp;quot;template parse err: %v&amp;quot;, err)
		os.Exit(-1)
	}
}

func printDescWithPrefix(desc string) string {
	return fmt.Sprintf(&amp;quot;Desc is: %s&amp;quot;, desc)
}

func main() {
	personInfo := Person{
		Name: &amp;quot;ztq&amp;quot;,
		Titles: []Title{
			Title{
				Title: &amp;quot;title0&amp;quot;,
				Desc:  &amp;quot;desc0&amp;quot;,
				Desc1: &amp;quot;desc1&amp;quot;,
				Desc2: &amp;quot;desc2&amp;quot;,
			},
			Title{
				Title: &amp;quot;title1&amp;quot;,
				Desc:  &amp;quot;desc0&amp;quot;,
				Desc1: &amp;quot;desc1&amp;quot;,
				Desc2: &amp;quot;desc2&amp;quot;,
			},
		},
	}
	if err := personTempl.Execute(os.Stdout, personInfo); err != nil {
		fmt.Println(&amp;quot;template execute error: %v&amp;quot;, err)
	}
}

---------------------------------------------
output:

Name: ztq, Titles:
////////////////////////////
Title: title0
Desc:  desc0
Desc1: desc1 (desc1)
Desc2: Desc is: desc2 (desc2)
////////////////////////////
Title: title1
Desc:  desc0
Desc1: desc1 (desc1)
Desc2: Desc is: desc2 (desc2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个小技巧，上述的这个调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;something, err = template.New(&amp;quot;*&amp;quot;).Funcs(template.FuncMap{&amp;quot;*&amp;quot;: *}).Parse(*)
if err != nil {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以包在template.Must()里，template.Must()函数如下，如果模版构建有错误则直接panic，因为模版在编译阶段就构建好了，如果解析失败后面直接使用可能会导致一些考虑不到的panic，或者这里捕获一次panic，总好过后面每次使用模版都要考虑可能发生panic。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Must is a helper that wraps a call to a function returning (*Template, error)
// and panics if the error is non-nil. It is intended for use in variable
// initializations such as
//	var t = template.Must(template.New(&amp;quot;name&amp;quot;).Parse(&amp;quot;text&amp;quot;))
func Must(t *Template, err error) *Template {
	if err != nil {
		panic(err)
	}
	return t
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;html-template实例&#34;&gt;HTML template实例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	htemplate  &amp;quot;html/template&amp;quot;
)

const HTMLTempl = `
&amp;lt;h1&amp;gt;{{.HEAD1}} :&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;State&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;User&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range .Items}}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;{{.State}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{.User}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{.Title | printTitle}}&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

// HTML templates
var (
	hTempl *htemplate.Template
)

func printTitleWithPrefix(title string) string {
	return fmt.Sprintf(&amp;quot;Title: %s&amp;quot;, title)
}

// Could panic when HTML template New failed.
func init() {
	hTempl = htemplate.Must(htemplate.New(&amp;quot;ht&amp;quot;).Funcs(htemplate.FuncMap{&amp;quot;printTitle&amp;quot;: printTitleWithPrefix}).Parse(HTMLTempl))
}

func main() {
	info := struct {
		Head  string
		Items []struct{ State, User, Title string }
	}{
		Head: &amp;quot;ztq&amp;quot;,
		Items: []struct{ State, User, Title string }{
			struct{ State, User, Title string }{&amp;quot;state1&amp;quot;, &amp;quot;user1&amp;quot;, &amp;quot;title1&amp;quot;},
			struct{ State, User, Title string }{&amp;quot;state2&amp;quot;, &amp;quot;user2&amp;quot;, &amp;quot;title2&amp;quot;},
			struct{ State, User, Title string }{&amp;quot;state3&amp;quot;, &amp;quot;user3&amp;quot;, &amp;quot;title3&amp;quot;},
		},
	}

	if err := hTempl.Execute(os.Stdout, &amp;amp;info); err != nil {
		fmt.Println(&amp;quot;HTML template failed: %v&amp;quot;, err)
	}
}

------------------------------------------------------
output:

&amp;lt;h1&amp;gt;ztq :&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;State&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;User&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;state1&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;user1&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;Title: title1&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;state2&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;user2&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;Title: title2&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;state3&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;user3&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;Title: title3&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;/table&amp;gt;

页面效果如下：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://tianqizhang93.github.io/images/The-Go-Programming-Language/html-template.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-函数&#34;&gt;5 函数&lt;/h1&gt;
&lt;p&gt;函数将一个语句序列打包为一个单元，然后可以从程序中其它地方多次调用。&lt;/p&gt;
&lt;h2 id=&#34;51-函数声明&#34;&gt;5.1 函数声明&lt;/h2&gt;
&lt;p&gt;函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func name(parameter-list) (result-list) {
    body
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为0。(如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环。)&lt;/p&gt;
&lt;p&gt;函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或标识符。形参和返回值的变量名不影响函数标识符，也不影响它们是否可以以省略参数类型的形式表示。&lt;/p&gt;
&lt;p&gt;每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，&lt;strong&gt;Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参&lt;/strong&gt;，因此形参和返回值的变量名对于函数调用者而言没有意义。&lt;/p&gt;
&lt;p&gt;在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有函数体的函数声明，表示该函数不是以Go实现的，这样的声明仅仅定义函数标识符(也在go:linkname机制中使用到)&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package math

func Sin(x float64) float //implemented in assembly language
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;52-递归&#34;&gt;5.2 递归&lt;/h2&gt;
&lt;p&gt;函数可以是递归的，这意味着函数可以直接或间接的调用自身。&lt;/p&gt;
&lt;h2 id=&#34;53-多返回值&#34;&gt;5.3 多返回值&lt;/h2&gt;
&lt;p&gt;在Go中，一个函数可以返回多个值。
如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。&lt;/p&gt;
&lt;h2 id=&#34;54-错误&#34;&gt;5.4 错误&lt;/h2&gt;
&lt;p&gt;在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。&lt;/p&gt;
&lt;p&gt;在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。&lt;/p&gt;
&lt;p&gt;Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。&lt;/p&gt;
&lt;p&gt;一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息。&lt;/p&gt;
&lt;p&gt;如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// WaitForServer attempts to contact the server of a URL.
// It tries for one minute using exponential back-off.
// It reports an error if all attempts fail.
func WaitForServer(url string) error {
    const timeout = 1 * time.Minute
    deadline := time.Now().Add(timeout)
    for tries := 0; time.Now().Before(deadline); tries++ {
        _, err := http.Head(url)
        if err == nil {
            return nil // success
        }
        log.Printf(&amp;quot;server not responding (%s);retrying…&amp;quot;, err)
        time.Sleep(time.Second &amp;lt;&amp;lt; uint(tries)) // exponential back-off
    }
    return fmt.Errorf(&amp;quot;server %s failed to respond after %s&amp;quot;, url, timeout)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该清晰地写下你的意图。
在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。&lt;/p&gt;
&lt;h2 id=&#34;55-函数值&#34;&gt;5.5 函数值&lt;/h2&gt;
&lt;p&gt;在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    func square(n int) int { return n * n }
    func negative(n int) int { return -n }
    func product(m, n int) int { return m * n }

    f := square
    fmt.Println(f(3)) // &amp;quot;9&amp;quot;

    f = negative
    fmt.Println(f(3))     // &amp;quot;-3&amp;quot;
    fmt.Printf(&amp;quot;%T\n&amp;quot;, f) // &amp;quot;func(int) int&amp;quot;

    f = product // compile error: can&#39;t assign func(int, int) int to func(int) int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数类型的零值是nil。调用值为nil的函数值会引起panic错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f func(int) int
f(3) // 此处f的值为nil, 会引起panic错误
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数值之间不可比较，也不能用函数值作为map的key，但是函数值可以与nil比较。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者

func add1(r rune) rune { return r + 1 }

fmt.Println(strings.Map(add1, &amp;quot;HAL-9000&amp;quot;)) // &amp;quot;IBM.:111&amp;quot;
fmt.Println(strings.Map(add1, &amp;quot;VMS&amp;quot;))      // &amp;quot;WNT&amp;quot;
fmt.Println(strings.Map(add1, &amp;quot;Admix&amp;quot;))    // &amp;quot;Benjy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;56-匿名函数&#34;&gt;5.6 匿名函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;拥有函数名的函数只能在包级语法块中被声明&lt;/strong&gt;，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。&lt;/p&gt;
&lt;p&gt;通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // &amp;quot;1&amp;quot;
    fmt.Println(f()) // &amp;quot;4&amp;quot;
    fmt.Println(f()) // &amp;quot;9&amp;quot;
    fmt.Println(f()) // &amp;quot;16&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。&lt;/p&gt;
&lt;p&gt;当匿名函数需要递归调用时，需要将匿名函数赋值给函数变量然后实现递归：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var visitAll func(items []string)
visitAll = func(items []string) {
    for _, item := range items {
        if !seen[item] {
            seen[item] = true
            visitAll(m[item])
            order = append(order, item)
        }
    }
}

--------------------------------------------
visitAll := func(items []string) {
    // ...
    visitAll(m[item]) // compile error: undefined: visitAll
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;57-可变参数&#34;&gt;5.7 可变参数&lt;/h2&gt;
&lt;p&gt;参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。
在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“&amp;hellip;”，这表示该函数会接收任意数量的该类型参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func sum(vals...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;58-defer函数&#34;&gt;5.8 defer函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;当执行到该条语句时，函数和参数表达式得到计算&lt;/strong&gt;，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，&lt;strong&gt;不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个函数中执行多条defer语句，它们的&lt;strong&gt;执行顺序与声明顺序相反&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;defer可以读取具名返回值&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;59-panic&#34;&gt;5.9 panic&lt;/h2&gt;
&lt;p&gt;Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。
一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer ）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。&lt;/p&gt;
&lt;p&gt;不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。&lt;/p&gt;
&lt;h2 id=&#34;510-recover&#34;&gt;5.10 recover&lt;/h2&gt;
&lt;p&gt;如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。&lt;strong&gt;导致panic异常的函数不会继续运行，但能正常返回&lt;/strong&gt;。在未发生panic时调用recover，recover会返回nil。&lt;/p&gt;
&lt;p&gt;虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。&lt;/p&gt;
&lt;p&gt;基于以上原因，安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// soleTitle returns the text of the first non-empty title element
// in doc, and an error if there was not exactly one.
func soleTitle(doc *html.Node) (title string, err error) {
    type bailout struct{}
    defer func() {
        switch p := recover(); p {
        case nil:       // no panic
        case bailout{}: // &amp;quot;expected&amp;quot; panic
            err = fmt.Errorf(&amp;quot;multiple title elements&amp;quot;)
        default:
            panic(p) // unexpected panic; carry on panicking
        }
    }()
    // Bail out of recursion if we find more than one nonempty title.
    forEachNode(doc, func(n *html.Node) {
        if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;title&amp;quot; &amp;amp;&amp;amp;
            n.FirstChild != nil {
            if title != &amp;quot;&amp;quot; {
                panic(bailout{}) // multiple titleelements
            }
            title = n.FirstChild.Data
        }
    }, nil)
    if title == &amp;quot;&amp;quot; {
        return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;no title element&amp;quot;)
    }
    return title, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;6-方法&#34;&gt;6 方法&lt;/h1&gt;
&lt;h2 id=&#34;61-方法声明&#34;&gt;6.1 方法声明&lt;/h2&gt;
&lt;p&gt;在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package geometry

import &amp;quot;math&amp;quot;

type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码里那个附加的参数p，叫做方法的接收器(receiver)。
在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。接收器命名建议可以使用类型的第一个字母，比如这里使用了Point的首字母p。&lt;/p&gt;
&lt;p&gt;在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // &amp;quot;5&amp;quot;, function call
fmt.Println(p.Distance(q))  // &amp;quot;5&amp;quot;, method call
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如p.X。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用p.X时会有歧义。&lt;/p&gt;
&lt;h2 id=&#34;62-基于指针对象的方法&#34;&gt;6.2 基于指针对象的方法&lt;/h2&gt;
&lt;p&gt;当接受者变量本身比较大时，可以用其指针而不是对象来声明方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Point struct{ X, Y float64 }

func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个方法的名字是(*Point).ScaleBy。括号是必须的,没有括号的话这个表达式可能会被理解为*(Point.ScaleBy)。&lt;/p&gt;
&lt;p&gt;只有类型(Point)和指向他们的指针(*Point)，才可能是出现在接收器声明里的两种接收器。在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法，编译器会隐式地帮我们用&amp;amp;p去调用ScaleBy这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p.ScaleBy(2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种简写方法只适用于“变量”，我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到(临时变量不能隐式的转换为指针，如果显示声明还是可以的)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Point{1, 2}.ScaleBy(2) // compile error: can&#39;t take address of Point literal

/////////////////////////

(&amp;amp;Point{1, 2}).ScaleBy(2) // ok
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;nil也是合法的接收器&#34;&gt;nil也是合法的接收器&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// An IntList is a linked list of integers.
// A nil *IntList represents the empty list.
type IntList struct {
    Value int
    Tail  *IntList
}
// Sum returns the sum of the list elements.
func (list *IntList) Sum() int {
    if list == nil {
        return 0
    }
    return list.Value + list.Tail.Sum()
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;63-通过嵌入结构体来扩展类型&#34;&gt;6.3 通过嵌入结构体来扩展类型&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;image/color&amp;quot;

type Point struct{ X, Y float64 }

type ColoredPoint struct {
    Point
    Color color.RGBA
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是&amp;quot;has a&amp;rdquo;，而不是&amp;quot;is a&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;当编译器解析一个选择器到方法时，它会首先去找直接定义在这个类型里的方法，然后找被内嵌字段们引入的方法，然后去找内嵌字段的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错（同一级里有两个同名的方法）。&lt;/p&gt;
&lt;h2 id=&#34;64-方法值和方法表达式&#34;&gt;6.4 方法值和方法表达式&lt;/h2&gt;
&lt;p&gt;我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。p.Distance叫作“选择器”，选择器会返回一个方法&amp;quot;值&amp;rdquo;-&amp;gt;一个将方法(Point.Distance)绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器(因为已经在前文中指定过了)，只要传入函数的参数即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance        // method value
fmt.Println(distanceFromP(q))      // &amp;quot;5&amp;quot;
var origin Point                   // {0, 0}
fmt.Println(distanceFromP(origin)) // &amp;quot;2.23606797749979&amp;quot;, sqrt(5)

scaleP := p.ScaleBy // method value
scaleP(2)           // p becomes (2, 4)
scaleP(3)           //      then (6, 12)
scaleP(10)          //      then (60, 120)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法&amp;quot;值&amp;quot;会非常实用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Rocket struct { /* ... */ }
func (r *Rocket) Launch() { /* ... */ }
r := new(Rocket)
time.AfterFunc(10 * time.Second, func() { r.Launch() })

------------------------------------------------------

// 直接用方法&amp;quot;值&amp;quot;传入AfterFunc的话可以更为简短, 省掉了上面例子里的匿名函数
time.AfterFunc(10 * time.Second, r.Launch)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和方法&amp;quot;值&amp;quot;相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器(p.Distance)语法来指定方法的接收器。&lt;/p&gt;
&lt;p&gt;当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个函数&amp;quot;值&amp;quot;，这种函数会将其第一个参数用作接收器，所以可以用通常(不写选择器)的方式来对其进行调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p := Point{1, 2}
q := Point{4, 6}

distance := Point.Distance   // method expression
fmt.Println(distance(p, q))  // &amp;quot;5&amp;quot;
fmt.Printf(&amp;quot;%T\n&amp;quot;, distance) // &amp;quot;func(Point, Point) float64&amp;quot;

scale := (*Point).ScaleBy
scale(&amp;amp;p, 2)
fmt.Println(p)            // &amp;quot;{2 4}&amp;quot;
fmt.Printf(&amp;quot;%T\n&amp;quot;, scale) // &amp;quot;func(*Point, float64)&amp;quot;

// 译注：这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()
// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数
// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再看一个具体例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type Title struct {
	Desc string
}

func (t *Title) PrintDesc(a, b, c string) (d string) {
	fmt.Println(t.Desc)

	return
}

func main() {
	fmt.Printf(&amp;quot;%T\n&amp;quot;, (&amp;amp;Title{}).PrintDesc)

	fmt.Printf(&amp;quot;%T\n&amp;quot;, (*Title).PrintDesc)
}

----------------------------------------------
output:

func(string, string, string) string
func(*main.Title, string, string, string) string // 这里函数参数多了一个*main.Title，即接收器
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;66-封装&#34;&gt;6.6 封装&lt;/h2&gt;
&lt;p&gt;一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。&lt;/p&gt;
&lt;p&gt;Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。&lt;/p&gt;
&lt;p&gt;这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。&lt;/p&gt;
&lt;p&gt;封装提供了三方面的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可&lt;/li&gt;
&lt;li&gt;隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由&lt;/li&gt;
&lt;li&gt;阻止了外部调用方对对象内部的值任意地进行修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证API兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。&lt;/p&gt;
&lt;h1 id=&#34;7-接口&#34;&gt;7 接口&lt;/h1&gt;
&lt;p&gt;接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。&lt;/p&gt;
&lt;p&gt;很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足&lt;strong&gt;隐式实现&lt;/strong&gt;的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。&lt;/p&gt;
&lt;h2 id=&#34;71-接口合约&#34;&gt;7.1 接口==“合约”&lt;/h2&gt;
&lt;p&gt;一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。&lt;/p&gt;
&lt;p&gt;在Go语言中还存在着另外一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说&lt;strong&gt;当你看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性(LSP里氏替换)。这是一个面向对象的特征。&lt;/p&gt;
&lt;h2 id=&#34;72-接口类型&#34;&gt;7.2 接口类型&lt;/h2&gt;
&lt;p&gt;接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。&lt;/p&gt;
&lt;h2 id=&#34;73-实现接口的条件&#34;&gt;7.3 实现接口的条件&lt;/h2&gt;
&lt;p&gt;一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。&lt;/p&gt;
&lt;p&gt;接口的使用场景实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 考虑在一个组织出售数字文化产品比如音乐，电影和书籍的程序中可能定义了下列的具体类型
Album
Book
Movie
Magazine
Podcast
TVEpisode
Track

// 把每个抽象的特点用接口来表示。一些特性对于所有的这些文化产品都是共通的，例如标题，创作日期和作者列表
type Artifact interface {
    Title() string
    Creators() []string
    Created() time.Time
}

// 其它的一些特性只对特定类型的文化产品才有。和文字排版特性相关的只有books和magazines，
// 还有只有movies和TV剧集和屏幕分辨率相关
type Text interface {
    Pages() int
    Words() int
    PageSize() int
}
type Audio interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string // e.g., &amp;quot;MP3&amp;quot;, &amp;quot;WAV&amp;quot;
}
type Video interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string // e.g., &amp;quot;MP4&amp;quot;, &amp;quot;WMV&amp;quot;
    Resolution() (x, y int)
}

// 这些接口不止是一种有用的方式来分组相关的具体类型和表示他们之间的共同特点。
// 我们后面可能会发现其它的分组。举例，如果我们发现我们需要以同样的方式处理Audio和Video，
// 我们可以定义一个Streamer接口来代表它们之间相同的部分而不必对已经存在的类型做改变
type Streamer interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。&lt;em&gt;当具体的类型来自不同的作者时这种方式会特别有用&lt;/em&gt;。当然也确实没有必要在具体的类型中指出这些共性。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;75-接口值&#34;&gt;7.5 接口值&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。&lt;/strong&gt;
下面4个语句中，变量w得到了3个不同的值（开始和最后的值是相同的）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var w io.Writer
w = os.Stdout
w = new(bytes.Buffer)
w = nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个语句&lt;code&gt;var w io.Writer&lt;/code&gt;定义了变量w。在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil:
&lt;img src=&#34;https://tianqizhang93.github.io/images/The-Go-Programming-Language/ch7-01.png&#34; alt=&#34;ch7-01&#34;&gt;
一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生panic:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;w.Write([]byte(&amp;quot;hello&amp;quot;)) // panic: nil pointer dereference
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个语句&lt;code&gt;w = os.Stdout&lt;/code&gt;将一个*os.File类型的值赋给变量w。这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用&lt;code&gt;io.Writer(os.Stdout)&lt;/code&gt;是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为*os.File指针的类型描述符，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的os.File类型变量的指针:
&lt;img src=&#34;https://tianqizhang93.github.io/images/The-Go-Programming-Language/ch7-02.png&#34; alt=&#34;ch7-02&#34;&gt;
调用一个包含*os.File类型指针的接口值的Write方法，使得(*os.File).Write方法被调用。这个调用输出“hello”:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;w.Write([]byte(&amp;quot;hello&amp;quot;)) // &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;os.Stdout.Write([]byte(&amp;quot;hello&amp;quot;)) // &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第三个语句&lt;code&gt;w = new(bytes.Buffer)&lt;/code&gt;给接口值赋了一个*bytes.Buffer类型的值。现在动态类型是*bytes.Buffer并且动态值是一个指向新分配的缓冲区的指针：
&lt;img src=&#34;https://tianqizhang93.github.io/images/The-Go-Programming-Language/ch7-03.png&#34; alt=&#34;ch7-03&#34;&gt;
Write方法的调用也使用了和之前一样的机制：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;w.Write([]byte(&amp;quot;hello&amp;quot;)) // writes &amp;quot;hello&amp;quot; to the bytes.Buffers
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这次类型描述符是*bytes.Buffer，所以调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。
最后，第四个语句&lt;code&gt;w = nil&lt;/code&gt;将nil赋给了接口值。这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时相同的状态，在第一张图中可以看到。
使用fmt包的%T看到的效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var w io.Writer
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;&amp;lt;nil&amp;gt;&amp;quot;
w = os.Stdout
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;*os.File&amp;quot;
w = new(bytes.Buffer)
fmt.Printf(&amp;quot;%T\n&amp;quot;, w) // &amp;quot;*bytes.Buffer&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个接口值可以持有任意大的动态值。&lt;/p&gt;
&lt;p&gt;接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。
然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。&lt;/p&gt;
&lt;h2 id=&#34;710-类型断言&#34;&gt;7.10 类型断言&lt;/h2&gt;
&lt;p&gt;类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果断言的类型T是一个具体类型，类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，会抛出panic。
&lt;pre&gt;&lt;code&gt;var w io.Writer
w = os.Stdout
f := w.(*os.File)      // success: f == os.Stdout
c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果相反地断言的类型T是一个接口类型，类型断言检查是否x的动态类型满足T&lt;/strong&gt;。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，&lt;strong&gt;对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分&lt;/strong&gt;。
&lt;pre&gt;&lt;code&gt;var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) // success: *os.File has both Read and Write
w = new(ByteCounter)
rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;w = rw             // io.ReadWriter is assignable to io.Writer
w = rw.(io.Writer) // fails only if rw == nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果类型断言出现在一个预期有两个结果的赋值操作中，这个操作不会在失败的时候发生panic，第二个结果是一个标识成功与否的布尔值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var w io.Writer = os.Stdout
f, ok := w.(*os.File)      // success:  ok, f == os.Stdout
b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;713-类型分支&#34;&gt;7.13 类型分支&lt;/h2&gt;
&lt;p&gt;接口被以两种不同的方式使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。&lt;/li&gt;
&lt;li&gt;第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。以这种方式使用的接口被描述为discriminated unions（可辨识联合）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在最简单的形式中，一个类型分支像普通的switch语句一样，它的运算对象是x.(type)——它使用了关键词字面量type——并且每个case有一到多个类型。一个类型分支基于这个接口值的动态类型使一个多路分支有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch x.(type) {
case nil:       // ...
case int, uint: // ...
case bool:      // ...
case string:    // ...
default:        // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;8-goroutine-和-channel&#34;&gt;8 goroutine 和 channel&lt;/h1&gt;
&lt;h2 id=&#34;81-goroutine&#34;&gt;8.1 goroutine&lt;/h2&gt;
&lt;p&gt;在Go语言中，每一个并发的执行单元叫作一个goroutine。&lt;/p&gt;
&lt;p&gt;当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f()    // call f(); wait for it to return
go f() // create a new goroutine that calls f(); don&#39;t wait
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;主函数返回时，所有的goroutine都会被直接打断，程序退出&lt;/strong&gt;。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行（但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;go后跟的函数的参数会在go语句自身执行时被求值&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;82-channel&#34;&gt;8.2 channel&lt;/h2&gt;
&lt;p&gt;如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。&lt;/p&gt;
&lt;p&gt;创建一个 int变量channel：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch := make(chan int) // ch has type &#39;chan int&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;channel对应一个make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。&lt;/p&gt;
&lt;p&gt;两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。&lt;/p&gt;
&lt;p&gt;一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用&amp;lt;-运算符。在发送语句中，&amp;lt;-运算符分割channel和要发送的值。在接收语句中，&amp;lt;-运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch &amp;lt;- x  // a send statement
x = &amp;lt;-ch // a receive expression in an assignment statement
&amp;lt;-ch     // a receive statement; result is discarded
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic&lt;/strong&gt;。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。
使用内置的close函数就可以关闭一个channel：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;close(ch)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch = make(chan int)    // unbuffered channel
ch = make(chan int, 0) // unbuffered channel
ch = make(chan int, 3) // buffered channel with capacity 3
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;单方向channeleg-chan--int-和--chan-int&#34;&gt;单方向channel(e.g. chan&amp;lt;- int 和 &amp;lt;-chan int)&lt;/h3&gt;
&lt;p&gt;当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。类型chan&amp;lt;- int表示一个只发送int的channel，只能发送不能接收。相反，类型&amp;lt;-chan int表示一个只接收int的channel，只能接收不能发送。（箭头&amp;lt;-和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。&lt;/p&gt;
&lt;p&gt;因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。&lt;/p&gt;
&lt;h3 id=&#34;不带缓存的channel&#34;&gt;不带缓存的channel&lt;/h3&gt;
&lt;p&gt;一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。
基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。&lt;strong&gt;当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前(happens before)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;带缓存的channel&#34;&gt;带缓存的channel&lt;/h3&gt;
&lt;p&gt;带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch = make(chan string, 3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。
channel的缓存队列解耦了接收和发送的goroutine(发送和接收操作&amp;quot;不同步&amp;quot;了)。&lt;/p&gt;
&lt;p&gt;cap和len可分别获取缓存channel的容量和长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch &amp;lt;- &amp;quot;test&amp;quot;

println(cap(ch))    // 3
println(len(ch))    // 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。&lt;/p&gt;
&lt;h2 id=&#34;89-并发的退出&#34;&gt;8.9 并发的退出&lt;/h2&gt;
&lt;p&gt;Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。
可以在某个goroutine中向一个channel发送一个简单的值，其他的goroutine将这个值理解为自己的退出信号；但是如果是有多个goroutine需要退出呢？一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的，不知道应该发送多少个退出信号。&lt;/p&gt;
&lt;p&gt;为了达到退出goroutine的目的，需要一个更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。&lt;/p&gt;
&lt;p&gt;关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。将这个机制扩展一下，来作为广播机制：不要向channel发送值，而是用关闭一个channel来进行广播:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main() {
	var exitSig = make(chan struct{})
	var wg = &amp;amp;sync.WaitGroup{}
	var exigWg = &amp;amp;sync.WaitGroup{}

	testFunc := func(msg string) {
		i := 0
	forSelect:
		for {
			select {
			case &amp;lt;-exitSig:
				exigWg.Add(1)
				fmt.Println(msg, &amp;quot; &amp;quot;, &amp;quot;exit&amp;quot;)
				exigWg.Done()
				
				break forSelect
			default:
				wg.Add(1)
				
				fmt.Println(msg, &amp;quot; &amp;quot;, i)
				i++
				time.Sleep(200 * time.Millisecond)
            
				wg.Done()
			}
		}
	}

	go testFunc(&amp;quot;func1&amp;quot;)
	go testFunc(&amp;quot;func2&amp;quot;)

	// work
	time.Sleep(time.Second)

	// exit
	close(exitSig)

	// wait for wg
	wg.Wait()
	// wait for exit msg output
	exigWg.Wait()
}
---------------------------------------
output:

func2   0
func1   0
func1   1
func2   1
func1   2
func2   2
func2   3
func1   3
func1   4
func2   4
func1   exit
func2   exit
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;9-基于共享变量的并发&#34;&gt;9 基于共享变量的并发&lt;/h1&gt;
&lt;h2 id=&#34;91-竞争条件&#34;&gt;9.1 竞争条件&lt;/h2&gt;
&lt;p&gt;在一个线性(就是说只有一个goroutine的)的程序中，程序的执行顺序只由程序的逻辑来决定。例如，我们有一段语句序列，第一个在第二个之前，以此类推。在有两个或更多goroutine的程序中，每一个goroutine内的语句也是按照既定的顺序去执行的，但是一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。&lt;/p&gt;
&lt;p&gt;一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是并发安全的，并发安全的函数不需要额外的同步工作。做个概括，对于某个类型来说，如果其所有可访问的方法和操作都是并发安全的话，那么该类型便是并发安全的。&lt;/p&gt;
&lt;p&gt;包级别的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。&lt;/p&gt;
&lt;p&gt;竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。&lt;/p&gt;
&lt;p&gt;数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。根据上述定义，有三种方式可以避免数据竞争：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要去写变量&lt;/li&gt;
&lt;li&gt;避免从多个goroutine访问变量：Go的一个口头禅“不要使用共享数据来通信；使用通信来共享数据”。一个提供对一个指定的变量通过channel来请求的goroutine叫做这个变量的monitor goroutine。例子中balance变量被限制在了monitor goroutine中，名为teller：
&lt;pre&gt;&lt;code&gt;// Package bank provides a concurrency-safe bank with one account.
package bank

var deposits = make(chan int) // send amount to deposit
var balances = make(chan int) // receive balance

func Deposit(amount int) { deposits &amp;lt;- amount }
func Balance() int       { return &amp;lt;-balances }

func teller() {
    var balance int // balance is confined to teller goroutine
    for {
        select {
        case amount := &amp;lt;-deposits:
            balance += amount
        case balances &amp;lt;- balance:
        }
    }
}

func init() {
    go teller() // start the monitor goroutine
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问:&amp;ldquo;互斥&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;92-syncmutex&#34;&gt;9.2 sync.Mutex&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import &amp;quot;sync&amp;quot;

var (
    mu      sync.Mutex // guards balance
    balance int
)

func Deposit(amount int) {
    mu.Lock()
    balance = balance + amount
    mu.Unlock()
}

func Balance() int {
    mu.Lock()
    b := balance
    mu.Unlock()
    return b
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上，再考虑下下面的函数。当过多的取款操作同时执行时，balance可能会瞬时被减到0以下。这可能会引起一个并发的取款被不合逻辑地拒绝。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// NOTE: not atomic!
func Withdraw(amount int) bool {
    Deposit(-amount)
    if Balance() &amp;lt; 0 {
        Deposit(amount)
        return false // insufficient funds
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;理想情况下，取款应该只在整个操作中获得一次互斥锁。下面这样的尝试是错误的，Deposit会调用mu.Lock()第二次去获取互斥锁，但因为mutex已经锁上了，会导致程序死锁，没法继续执行下去，Withdraw会永远阻塞下去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// NOTE: incorrect!
func Withdraw(amount int) bool {
    mu.Lock()
    defer mu.Unlock()
    Deposit(-amount)
    if Balance() &amp;lt; 0 {
        Deposit(amount)
        return false // insufficient funds
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决方案是将一个函数分离为多个函数，比如我们把Deposit分离成两个：一个不导出的函数deposit，这个函数假设锁总是会被保持并去做实际的操作，另一个是导出的函数Deposit，这个函数会调用deposit，但在调用前会先去获取锁。同理我们可以将Withdraw也表示成这种形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func Withdraw(amount int) bool {
    mu.Lock()
    defer mu.Unlock()
    deposit(-amount)
    if balance &amp;lt; 0 {
        deposit(amount)
        return false // insufficient funds
    }
    return true
}

func Deposit(amount int) {
    mu.Lock()
    defer mu.Unlock()
    deposit(amount)
}

func Balance() int {
    mu.Lock()
    defer mu.Unlock()
    return balance
}

// This function requires that the lock be held.
func deposit(amount int) { balance += amount }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;93-syncrwmutex&#34;&gt;9.3 sync.RWMutex&lt;/h2&gt;
&lt;p&gt;sync.RWMutex：&amp;ldquo;多读单写&amp;quot;锁(multiple readers, single writer lock)。&lt;/p&gt;
&lt;h2 id=&#34;94-内存同步&#34;&gt;9.4 内存同步&lt;/h2&gt;
&lt;p&gt;并发编程时，使用互斥量，不仅仅是为了控制并发时的&amp;quot;顺序问题&amp;rdquo;，更重要的，还会涉及&amp;quot;内存问题&amp;quot;。&lt;/p&gt;
&lt;p&gt;在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存(local cache)。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到。&lt;/p&gt;
&lt;p&gt;看下例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x, y int
go func() {
    x = 1 // A1
    fmt.Print(&amp;quot;y:&amp;quot;, y, &amp;quot; &amp;quot;) // A2
}()
go func() {
    y = 1                   // B1
    fmt.Print(&amp;quot;x:&amp;quot;, x, &amp;quot; &amp;quot;) // B2
}()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两个goroutine并发，&lt;code&gt;x, y&lt;/code&gt;没有加锁，两个goroutine存在数据竞争，那么输出会是什么样子呢？
按常规思路，执行顺序，假设第一个goroutine先执行，再假设A2在B2前，又有隐藏条件A1一定在A2前，B1一定在B2前，那么这时候执行顺序就是 (A1 A2 B1 B2 或 A1 B1 A2 B2)，其他情况依次类推，那么输出可能如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;y:0 x:1
y:1 x:1
x:0 y:1
x:1 y:1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是实际上，可能会得到如下的输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x:0 y:0
y:0 x:0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两种情况要怎么解释呢？
在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的，也就是说goroutine内顺序是连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没法保证事件在不同的goroutine中看到的执行顺序是一致的了。尽管goroutine A中一定需要观察到x=1执行成功之后才会去读取y，但它没法确保自己观察得到goroutine B中对y的写入，所以A还可能会打印出y的一个旧版的值。&lt;/p&gt;
&lt;p&gt;尽管去理解并发的一种尝试是去将其运行理解为不同goroutine语句的交错执行，但看看上面的例子，这已经不是现代的编译器和cpu的工作方式了。因为赋值和打印指向不同的变量，编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序。如果两个goroutine在不同的CPU上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其它goroutine的Print，在主存同步之前就是不可见的了。&lt;/p&gt;
&lt;p&gt;所有并发的问题都可以用一致的、简单的既定的模式来规避。所以可能的话，将变量限定在goroutine内部；如果是多个goroutine都需要访问的变量，使用互斥条件来访问。&lt;/p&gt;
&lt;h2 id=&#34;95-synconce惰性初始化&#34;&gt;9.5 sync.Once惰性初始化&lt;/h2&gt;
&lt;p&gt;如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。如果在程序启动的时候就去做这类初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量，所以实际上有一些浪费。&lt;/p&gt;
&lt;p&gt;下面是一个懒初始化(lazy initialization)的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var icons map[string]image.Image

func loadIcons() {
    icons = map[string]image.Image{
        &amp;quot;spades.png&amp;quot;:   loadIcon(&amp;quot;spades.png&amp;quot;),
        &amp;quot;hearts.png&amp;quot;:   loadIcon(&amp;quot;hearts.png&amp;quot;),
        &amp;quot;diamonds.png&amp;quot;: loadIcon(&amp;quot;diamonds.png&amp;quot;),
        &amp;quot;clubs.png&amp;quot;:    loadIcon(&amp;quot;clubs.png&amp;quot;),
    }
}

// NOTE: not concurrency-safe!
func Icon(name string) image.Image {
    if icons == nil {
        loadIcons() // one-time initialization
    }
    return icons[name]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的例程在单独的goroutine内工作OK，但是并发调用时不安全。&lt;/p&gt;
&lt;p&gt;Icon函数由多个步骤组成：首先测试icons是否为空，然后load这些icons，之后将icons更新为一个非空的值。&lt;/p&gt;
&lt;p&gt;那么并发场景下上面例程最差的情况是什么呢？
loadIcons函数被多次访问会带来数据竞争。当第一个goroutine在忙着loading这些icons的时候，另一个goroutine进入了Icon函数，发现变量是nil，然后也会调用loadIcons函数；这看起来不是很致命，貌似能够保证最终一致性。
其实不然。
由于缺少显示的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个goroutine自己的执行顺序一致。其中一种可能loadIcons的语句重排是下面这样。它会在填写icons变量的值之前先用一个空map来初始化icons变量，然后逐个loadIcon；那么问题就来了，由于没有显示的同步，假设某个goroutine(g1)走到了step1，然后flush内存，然后其他的goroutine(g2)调用Icon函数，&lt;code&gt;icons == nil&lt;/code&gt;条件不成立，但是此时icons还没有load任何东西，这就导致在g1没有将后续的load执行完并flush内存的这段期间，g2认为icons是已经被初始化的，但是却获得不到任何数据。所以其实数据的最终一致性并没有得到保障，进而可能引发一系列的逻辑bug。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func loadIcons() {
    icons = make(map[string]image.Image)                // step1
    icons[&amp;quot;spades.png&amp;quot;] = loadIcon(&amp;quot;spades.png&amp;quot;)        // step2
    icons[&amp;quot;hearts.png&amp;quot;] = loadIcon(&amp;quot;hearts.png&amp;quot;)        // step3
    icons[&amp;quot;diamonds.png&amp;quot;] = loadIcon(&amp;quot;diamonds.png&amp;quot;)    // step4
    icons[&amp;quot;clubs.png&amp;quot;] = loadIcon(&amp;quot;clubs.png&amp;quot;)          // step5
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最简单且正确的保证所有goroutine能够观察到loadIcons效果的方式，是用一个mutex来同步检查：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var mu sync.Mutex // guards icons
var icons map[string]image.Image

// Concurrency-safe.
func Icon(name string) image.Image {
    mu.Lock()
    defer mu.Unlock()
    if icons == nil {
        loadIcons()
    }
    return icons[name]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上例的问题在于，该变量将完全无法并发访问，即使他已经被初始化完毕。要解决的话，可以使用读写锁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var mu sync.RWMutex // guards icons
var icons map[string]image.Image

// Concurrency-safe.
func Icon(name string) image.Image {
    mu.RLock()
    if icons != nil {
        icon := icons[name]
        mu.RUnlock()
        return icon
    }
    mu.RUnlock()

    // acquire an exclusive lock
    mu.Lock()
    if icons == nil { // NOTE: must recheck for nil
        loadIcons()
    }
    icon := icons[name]
    mu.Unlock()
    return icon
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码有两个临界区。goroutine首先会获取一个读锁，查询map，然后释放锁。如果条目被找到了(一般情况下)，那么会直接返回。如果没有找到，那goroutine会获取一个写锁。不释放共享锁的话，也没有任何办法来将一个共享锁升级为一个互斥锁，所以我们必须重新检查icons变量是否为nil，以防止在执行这一段代码的时候，icons变量已经被其它gorouine初始化过了。&lt;/p&gt;
&lt;p&gt;sync.Once可以更方便的完成上述操作。概念上来讲，一次性的初始化需要一个互斥量mutex和一个boolean变量来记录初始化是不是已经完成了；互斥量用来保护boolean变量和客户端数据结构。Do这个唯一的方法需要接收初始化函数作为其参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var loadIconsOnce sync.Once
var icons map[string]image.Image

// Concurrency-safe.
func Icon(name string) image.Image {
    loadIconsOnce.Do(loadIcons)
    return icons[name]
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;96-golang-race-detector&#34;&gt;9.6 Golang Race Detector&lt;/h2&gt;
&lt;p&gt;go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用。
竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。
竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证测试并发地覆盖了包。
由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的工作来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的debugging。&lt;/p&gt;
&lt;h2 id=&#34;98-goroutine-和-线程&#34;&gt;9.8 goroutine 和 线程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;goroutine&lt;/strong&gt;和&lt;strong&gt;线程&lt;/strong&gt;的区别实际上只是一个量的区别，但量变会引起质变。&lt;/p&gt;
&lt;h3 id=&#34;动态栈&#34;&gt;动态栈&lt;/h3&gt;
&lt;p&gt;每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。而对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。&lt;/p&gt;
&lt;p&gt;相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。&lt;/p&gt;
&lt;h3 id=&#34;gouroutine调度&#34;&gt;gouroutine调度&lt;/h3&gt;
&lt;p&gt;OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。&lt;/p&gt;
&lt;p&gt;Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工(调度)m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine（按程序独立）。&lt;/p&gt;
&lt;p&gt;和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。&lt;/p&gt;
&lt;h3 id=&#34;gomaxprocs&#34;&gt;GOMAXPROCS&lt;/h3&gt;
&lt;p&gt;Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。(GOMAXPROCS是前面说的m:n调度中的n)。在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计算在内。&lt;/p&gt;
&lt;p&gt;GOMAXPROCS的环境变量和runtime.GOMAXPROCS函数可以修改GOMAXPROCS。&lt;/p&gt;
&lt;p&gt;runtime.GOMAXPROCS备注第一句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// GOMAXPROCS sets the maximum number of CPUs that can be executing
// simultaneously and returns the previous setting.
func GOMAXPROCS(n int) int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面例子可以看到GOMAXPROCS效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for {
    go fmt.Print(0)
    fmt.Print(1)
}

$ GOMAXPROCS=1 go run ***.go
111111111111111111110000000000000000000011111...

$ GOMAXPROCS=2 go run ***.go
010101010101010101011001100101011010010100110...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;goroutine没有id号&#34;&gt;goroutine没有ID号&lt;/h3&gt;
&lt;p&gt;在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份(id)，并且这个身份信息可以以一个普通值的形式被很容易地获取到，典型的可以是一个integer或者指针值。这种情况下我们做一个抽象化的thread-local storage(线程本地存储，多线程编程中不希望其它线程访问的内容)就很容易，只需要以线程的id作为key的一个map就可以解决问题，每一个线程以其id就能从中获取到值，且和其它线程互不冲突。&lt;/p&gt;
&lt;p&gt;goroutine没有可以被程序员获取到的身份(id)的概念。这一点是设计上故意而为之，由于thread-local storage总是会被滥用。比如说，一个web server是用一种支持tls的语言实现的，而非常普遍的是很多函数会去寻找HTTP请求的信息，这代表它们就是去其存储层(这个存储层有可能是tls)查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能并不仅由自己的参数所决定，而是由其所运行在的线程所决定。因此，如果线程本身的身份会改变——比如一些worker线程之类的——那么函数的行为就会变得神秘莫测。&lt;/p&gt;
&lt;p&gt;Go鼓励更为简单的模式，这种模式下参数(外部显式参数和内部显式参数。tls 中的内容算是&amp;quot;外部&amp;quot;隐式参数)对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。&lt;/p&gt;
&lt;h1 id=&#34;10-包和工具&#34;&gt;10 包和工具&lt;/h1&gt;
&lt;p&gt;Go语言有超过200个标准包（go list std）。标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设计、共享、重用和改进，目前互联网上已经发布了非常多的Go语言开源包，它们可以通过 &lt;a href=&#34;http://godoc.org&#34;&gt;godoc&lt;/a&gt; 检索。
Go还自带了工具箱，里面有很多用来简化工作区和包管理的小工具。&lt;/p&gt;
&lt;p&gt;Go语言编译器的编译速度明显快于其它编译语言，这主要得益于三个语言特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。&lt;/li&gt;
&lt;li&gt;第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。&lt;/li&gt;
&lt;li&gt;第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认包名一般采用导入路径名的最后一段，有三个例外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序&lt;/li&gt;
&lt;li&gt;第二个例外，包所在的目录中可能有一些文件名是以_test.go为后缀的Go源文件（前面必须有其它的字符，因为以_或.开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖
&lt;ul&gt;
&lt;li&gt;通俗的说，一个文件夹下一般只能有一个包名，但以_test.go 作为结尾的源码文件，可以用 $(被测试的包名)_test 作为包名，放置在相同源码目录下而不产生编译错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如&amp;quot;gopkg.in/yaml.v2&amp;quot;。这种情况下包的名字并不包含版本号后缀，而是yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以将&amp;quot;path&amp;quot;标准包重命名为pathpkg:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
    &amp;quot;crypto/rand&amp;quot;
    mrand &amp;quot;math/rand&amp;quot; // alternative name mrand avoids conflict
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数。可以用下划线_来重命名导入的包。这就是&lt;strong&gt;包的匿名导入&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import _ &amp;quot;image/png&amp;quot; // register PNG decoder
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;包的命名：简短，有描述行且无歧义，一般采用单数形式(标准库的一些复数形式是为了避免和预定义的类型或关键字冲突)。&lt;/p&gt;
&lt;h3 id=&#34;107-golang工具&#34;&gt;10.7 Golang工具&lt;/h3&gt;
&lt;p&gt;go help或者go help &lt;!-- raw HTML omitted --&gt;可以查看帮助信息。&lt;/p&gt;
&lt;p&gt;下载包：go get
构建包：go build
包文档：go doc (PS: 还有一个 godoc)
查询包：go list&lt;/p&gt;
&lt;h1 id=&#34;11-测试&#34;&gt;11 测试&lt;/h1&gt;
&lt;p&gt;Go语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的，而且它很容易延伸到基准测试和示例文档。&lt;/p&gt;
&lt;p&gt;go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。&lt;/p&gt;
&lt;p&gt;在*_test.go文件中，有三种类型的函数：测试函数、基准测试(benchmark)函数、示例函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL&lt;/li&gt;
&lt;li&gt;基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间&lt;/li&gt;
&lt;li&gt;示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。&lt;/p&gt;
&lt;p&gt;基准测试：&lt;a href=&#34;https://docs.hacknode.org/gopl-zh/ch11/ch11-04.html&#34;&gt;The Go Programming Language 11.4 基准测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例函数：&lt;a href=&#34;https://docs.hacknode.org/gopl-zh/ch11/ch11-06.html&#34;&gt;The Go Programming Language 11.6 示例函数&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;12-反射&#34;&gt;12 反射&lt;/h1&gt;
&lt;p&gt;Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。&lt;/p&gt;
&lt;p&gt;反射是一个复杂的内省技术，不应该随意使用。&lt;/p&gt;
&lt;h2 id=&#34;122-reflecttype和reflectvalue&#34;&gt;12.2 reflect.Type和reflect.Value&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;reflect.Type&lt;/code&gt;表示一个Go类型。&lt;code&gt;Type&lt;/code&gt;是&lt;code&gt;interface{}&lt;/code&gt;, 有许多方法来区分类型以及检查它们的组成部分, 例如一个结构体的成员或一个函数的参数等。
函数&lt;code&gt;reflect.TypeOf&lt;/code&gt;接受任意的&lt;code&gt;interface{}&lt;/code&gt;类型, 并以&lt;code&gt;reflect.Type&lt;/code&gt;形式返回其动态类型。
&lt;code&gt;reflect.TypeOf&lt;/code&gt;总是返回具体的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var w io.Writer = os.Stdout
fmt.Println(reflect.TypeOf(w)) // &amp;quot;*os.File&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个&lt;code&gt;reflect.Value&lt;/code&gt;可以装载任意类型的值。函数&lt;code&gt;reflect.ValueOf&lt;/code&gt;接受任意的&lt;code&gt;interface{}&lt;/code&gt;类型, 并返回一个装载着其动态值的&lt;code&gt;reflect.Value&lt;/code&gt;。和&lt;code&gt;reflect.TypeOf&lt;/code&gt;类似,&lt;code&gt;reflect.ValueOf&lt;/code&gt;返回的结果也是具体的类型, 但是&lt;code&gt;reflect.Value&lt;/code&gt;也可以持有一个接口值。&lt;/p&gt;
&lt;h2 id=&#34;123-通过reflectvalue修改值&#34;&gt;12.3 通过reflect.Value修改值&lt;/h2&gt;
&lt;p&gt;有些reflect.Value可取地址，有些不可以：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x := 2                   // value   type    variable?
a := reflect.ValueOf(2)  // 2       int     no
b := reflect.ValueOf(x)  // 2       int     no
c := reflect.ValueOf(&amp;amp;x) // &amp;amp;x      *int    no
d := c.Elem()            // 2       int     yes (x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;所有通过reflect.ValueOf(x)返回的reflect.Value都是不可取地址的&lt;/strong&gt;。
但是对于上例中的d，它是c的解引用方式生成的，指向另一个变量，因此是可取地址的。
&lt;strong&gt;可以通过调用reflect.ValueOf(&amp;amp;x).Elem()，来获取任意变量x对应的可取地址的Value&lt;/strong&gt;。
CanAddr方法可以判断reflect.Value是否可取地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fmt.Println(a.CanAddr()) // &amp;quot;false&amp;quot;
fmt.Println(b.CanAddr()) // &amp;quot;false&amp;quot;
fmt.Println(c.CanAddr()) // &amp;quot;false&amp;quot;
fmt.Println(d.CanAddr()) // &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从变量对应的可取地址的reflect.Value来访问变量需要三个步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，调用Addr()方法，它返回一个Value，里面保存了指向变量的指针&lt;/li&gt;
&lt;li&gt;第二步，在Value上调用Interface()方法，也就是返回一个interface{}，里面包含指向变量的指针&lt;/li&gt;
&lt;li&gt;第三步，如果明确知道变量的类型，可以使用类型的断言机制将得到的interface{}类型的接口强制转为普通的类型指针，然后通过这个普通指针来更新变量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;x := 2
d := reflect.ValueOf(&amp;amp;x).Elem()   // d refers to the variable x
px := d.Addr().Interface().(*int) // px := &amp;amp;x
*px = 3                           // x = 3
fmt.Println(x)                    // &amp;quot;3&amp;quot;

----------------------------------------------------------------

// 或者使用reflect.Value.Set方法
d.Set(reflect.ValueOf(4))   // 注意！这里类型不匹配会panic；d不可取址当然也会panic
fmt.Println(x) // &amp;quot;4&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;reflect.Value.Set方法可以完成可取址reflect.Value的赋值操作，但是必须类型匹配；同时，Set方法也有很多基于数据类型的方法：SetInt、SetUint、SetString、SetFloat等。只要reflect.Value对应的可取址变量的底层类型与Set类型可赋值即可(可能会发生截断影响精读)。但是，如果reflect.Value本身对应一个interface{},不能使用具体类型的Set方法例如SetInt、SetString等，而应该使用Set:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x := 1
rx := reflect.ValueOf(&amp;amp;x).Elem()
rx.SetInt(2)                     // OK, x = 2
rx.Set(reflect.ValueOf(3))       // OK, x = 3
rx.SetString(&amp;quot;hello&amp;quot;)            // panic: string is not assignable to int
rx.Set(reflect.ValueOf(&amp;quot;hello&amp;quot;)) // panic: string is not assignable to int

var y interface{}
ry := reflect.ValueOf(&amp;amp;y).Elem()
ry.SetInt(2)                     // panic: SetInt called on interface Value
ry.Set(reflect.ValueOf(3))       // OK, y = int(3)
ry.SetString(&amp;quot;hello&amp;quot;)            // panic: SetString called on interface Value
ry.Set(reflect.ValueOf(&amp;quot;hello&amp;quot;)) // OK, y = &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以越过Go语言的导出规则的限制读取结构体中未导出的成员，比如在类Unix系统上os.File结构体中的fd int成员。然而，利用反射机制并不能修改这些未导出的成员：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;stdout := reflect.ValueOf(os.Stdout).Elem() // *os.Stdout, an os.File var
fmt.Println(stdout.Type())                  // &amp;quot;os.File&amp;quot;
fd := stdout.FieldByName(&amp;quot;fd&amp;quot;)
fmt.Println(fd.Int()) // &amp;quot;1&amp;quot;
fd.SetInt(2)          // panic: unexported field
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个可取地址的reflect.Value会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。因此，CanAddr方法并不能正确反映一个变量是否是可以被修改的。另一个相关的方法CanSet是用于检查对应的reflect.Value是否是可取地址并可被修改的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fmt.Println(fd.CanAddr(), fd.CanSet()) // &amp;quot;true false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;127-获取结构体字段标签&#34;&gt;12.7 获取结构体字段标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// search implements the /search URL endpoint.
func search(resp http.ResponseWriter, req *http.Request) {
    var data struct {
        Labels     []string `http:&amp;quot;l&amp;quot;`
        MaxResults int      `http:&amp;quot;max&amp;quot;`
        Exact      bool     `http:&amp;quot;x&amp;quot;`
    }
    data.MaxResults = 10 // set default
    if err := params.Unpack(req, &amp;amp;data); err != nil {
        http.Error(resp, err.Error(), http.StatusBadRequest) // 400
        return
    }

    // ...rest of handler...
    fmt.Fprintf(resp, &amp;quot;Search: %+v\n&amp;quot;, data)
}

--------------------------------------------------------------------

// Unpack populates the fields of the struct pointed to by ptr
// from the HTTP request parameters in req.
func Unpack(req *http.Request, ptr interface{}) error {
    if err := req.ParseForm(); err != nil {
        return err
    }

    // Build map of fields keyed by effective name.
    fields := make(map[string]reflect.Value)
    v := reflect.ValueOf(ptr).Elem() // the struct variable
    for i := 0; i &amp;lt; v.NumField(); i++ {
        fieldInfo := v.Type().Field(i) // a reflect.StructField
        tag := fieldInfo.Tag           // a reflect.StructTag
        name := tag.Get(&amp;quot;http&amp;quot;)
        if name == &amp;quot;&amp;quot; {
            name = strings.ToLower(fieldInfo.Name)
        }
        fields[name] = v.Field(i)
    }

    // Update struct field for each parameter in the request.
    for name, values := range req.Form {
        f := fields[name]
        if !f.IsValid() {
            continue // ignore unrecognized HTTP parameters
        }
        for _, value := range values {
            if f.Kind() == reflect.Slice {
                elem := reflect.New(f.Type().Elem()).Elem()
                if err := populate(elem, value); err != nil {
                    return fmt.Errorf(&amp;quot;%s: %v&amp;quot;, name, err)
                }
                f.Set(reflect.Append(f, elem))
            } else {
                if err := populate(f, value); err != nil {
                    return fmt.Errorf(&amp;quot;%s: %v&amp;quot;, name, err)
                }
            }
        }
    }
    return nil
}

--------------------------------------------------------------------

func populate(v reflect.Value, value string) error {
    switch v.Kind() {
    case reflect.String:
        v.SetString(value)

    case reflect.Int:
        i, err := strconv.ParseInt(value, 10, 64)
        if err != nil {
            return err
        }
        v.SetInt(i)

    case reflect.Bool:
        b, err := strconv.ParseBool(value)
        if err != nil {
            return err
        }
        v.SetBool(b)

    default:
        return fmt.Errorf(&amp;quot;unsupported kind %s&amp;quot;, v.Type())
    }
    return nil
}

--------------------------------------------------------------------

output:

$ ./search &amp;amp;
$ ./fetch &#39;http://localhost:12345/search&#39;
Search: {Labels:[] MaxResults:10 Exact:false}
$ ./fetch &#39;http://localhost:12345/search?l=golang&amp;amp;l=programming&#39;
Search: {Labels:[golang programming] MaxResults:10 Exact:false}
$ ./fetch &#39;http://localhost:12345/search?l=golang&amp;amp;l=programming&amp;amp;max=100&#39;
Search: {Labels:[golang programming] MaxResults:100 Exact:false}
$ ./fetch &#39;http://localhost:12345/search?x=true&amp;amp;l=golang&amp;amp;l=programming&#39;
Search: {Labels:[golang programming] MaxResults:10 Exact:true}
$ ./fetch &#39;http://localhost:12345/search?q=hello&amp;amp;x=123&#39;
x: strconv.ParseBool: parsing &amp;quot;123&amp;quot;: invalid syntax
$ ./fetch &#39;http://localhost:12345/search?q=hello&amp;amp;max=lots&#39;
max: strconv.ParseInt: parsing &amp;quot;lots&amp;quot;: invalid syntax
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;128-显示一个类型的方法集&#34;&gt;12.8 显示一个类型的方法集&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// Print prints the method set of the value x.
func Print(x interface{}) {
    v := reflect.ValueOf(x)
    t := v.Type()
    fmt.Printf(&amp;quot;type %s\n&amp;quot;, t)

    for i := 0; i &amp;lt; v.NumMethod(); i++ {
        methType := v.Method(i).Type()
        fmt.Printf(&amp;quot;func (%s) %s%s\n&amp;quot;, t, t.Method(i).Name,
            strings.TrimPrefix(methType.String(), &amp;quot;func&amp;quot;))
    }
}

-----------------------------------------------------------

methods.Print(time.Hour)
// Output:
// type time.Duration
// func (time.Duration) Hours() float64
// func (time.Duration) Minutes() float64
// func (time.Duration) Nanoseconds() int64
// func (time.Duration) Seconds() float64
// func (time.Duration) String() string

methods.Print(new(strings.Replacer))
// Output:
// type *strings.Replacer
// func (*strings.Replacer) Replace(string) string
// func (*strings.Replacer) WriteString(io.Writer, string) (int, error)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;129-关于reflect的几点忠告&#34;&gt;12.9 关于reflect的几点忠告&lt;/h2&gt;
&lt;p&gt;反射是一个强大并富有表达力的工具，但是它应该被小心地使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个原因是，基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出panic异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间
&lt;ul&gt;
&lt;li&gt;避免这种因反射而导致的脆弱性的问题的最好方法，是将所有的反射相关的使用控制在包的内部，如果可能的话避免在包的API中直接暴露reflect.Value类型，这样可以限制一些非法输入。如果无法做到这一点，在每个有风险的操作前指向额外的类型检查。以标准库中的代码为例，当fmt.Printf收到一个非法的操作数时，它并不会抛出panic异常，而是打印相关的错误信息。程序虽然还有BUG，但是会更加容易诊断：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;fmt.Printf(&amp;quot;%d %s\n&amp;quot;, &amp;quot;hello&amp;quot;, 42) // &amp;quot;%!d(string=hello) %!s(int=42)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;第二个原因是，即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受interface{}或reflect.Value类型参数的函数维护说明文档&lt;/li&gt;
&lt;li&gt;第三个原因，基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以当反射能使程序更加清晰的时候可以考虑使用。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于reflect导致性能下滑有鸟窝的blog记载： &lt;a href=&#34;https://colobu.com/2019/01/29/go-reflect-performance/&#34;&gt;Go Reflect 性能&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;13-底层编程&#34;&gt;13 底层编程&lt;/h1&gt;
&lt;h2 id=&#34;131-unsafe-sizeof-alignof-offsetof&#34;&gt;13.1 unsafe: Sizeof, Alignof, Offsetof&lt;/h2&gt;
&lt;p&gt;unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。Sizeof函数返回的大小只包括数据结构中固定的部分，例如字符串对应结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小在32位平台上是4个字节，在64位平台上是8个字节。&lt;/p&gt;
&lt;p&gt;计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。
由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;1个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;intN, uintN, floatN, complexN&lt;/td&gt;
&lt;td&gt;N/8个字节(例如float64是8个字节)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int, uint, uintptr&lt;/td&gt;
&lt;td&gt;1个机器字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*T&lt;/td&gt;
&lt;td&gt;1个机器字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;2个机器字(data,len)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]T&lt;/td&gt;
&lt;td&gt;3个机器字(data,len,cap)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;map&lt;/td&gt;
&lt;td&gt;1个机器字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;func&lt;/td&gt;
&lt;td&gt;1个机器字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chan&lt;/td&gt;
&lt;td&gt;1个机器字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;interface&lt;/td&gt;
&lt;td&gt;2个机器字(type,value)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面的三个结构体虽然有着相同的字段，但是第一种写法比另外的两个需要多50%的内存:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                               // 64-bit  32-bit
struct{ bool; float64; int16 } // 3 words 4words
struct{ float64; int16; bool } // 2 words 3words
struct{ bool; int16; float64 } // 2 words 3words
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;unsafe.Alignof 函数返回对应参数的类型需要对齐的倍数。
unsafe.Offsetof 函数的参数必须是一个字段 x.f, 然后返回 f 字段相对于 x 起始地址的偏移量, 包括可能的空洞。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x struct {
    a bool
    b int16
    c []int
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;图( 灰色区域是空洞)：
&lt;img src=&#34;https://tianqizhang93.github.io/images/The-Go-Programming-Language/unsafe.png&#34; alt=&#34;unsafe&#34;&gt;&lt;/p&gt;
&lt;p&gt;32位系统：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sizeof(x)   = 16  Alignof(x)   = 4
Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0
Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2
Sizeof(x.c) = 12  Alignof(x.c) = 4 Offsetof(x.c) = 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;64位系统：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sizeof(x)   = 32  Alignof(x)   = 8
Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0
Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2
Sizeof(x.c) = 24  Alignof(x.c) = 8 Offsetof(x.c) = 8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然这几个函数在不安全的unsafe包，但是这几个函数调用并不是真的不安全，特别在需要优化内存空间时它们返回的结果对于理解原生的内存布局很有帮助。&lt;/p&gt;
&lt;h2 id=&#34;132-unsafepointer&#34;&gt;13.2 unsafe.Pointer&lt;/h2&gt;
&lt;p&gt;大多数指针类型会写成*T，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义的一种指针类型（类似C语言中的void*类型的指针），它可以包含任意类型变量的地址。当然，我们不可以直接通过*p来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。&lt;/p&gt;
&lt;p&gt;一个普通的&lt;em&gt;T类型指针可以被转化为unsafe.Pointer类型指针，并且一个unsafe.Pointer类型指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的&lt;/em&gt;T类型相同。通过将&lt;em&gt;float64类型指针转化为&lt;/em&gt;uint64类型指针，我们可以查看一个浮点数变量的位模式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package math

func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&amp;amp;f)) }

fmt.Printf(&amp;quot;%#016x\n&amp;quot;, Float64bits(1.0)) // &amp;quot;0x3ff0000000000000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;134-通过cgo调用c代码&#34;&gt;13.4 通过cgo调用C代码&lt;/h2&gt;
&lt;p&gt;Go语言自带的cgo可以支援C语言函数调用的工具。
这类工具一般被称为 foreign-function interfaces （ffi）。
ffi不仅包括cgo，&lt;a href=&#34;http://swig.org&#34;&gt;SWIG&lt;/a&gt;是另一个类似的且被广泛使用的工具，SWIG提供了很多复杂特性以支持C++。&lt;/p&gt;
&lt;p&gt;如果是比较小的C语言库，完全可以用纯Go语言重新实现一遍。
如果对性能没有特殊要求的话，还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行（用os/exec包调用子进程的方法会导致程序运行时依赖那个应用程序）。
&lt;strong&gt;只有当需要使用复杂而且性能更高的底层C接口时，才是使用cgo的场景&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import C&lt;/code&gt;必须单独一行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt;的语句是比较特别的，其实并没有一个叫C的包，但是这行语句会让Go编译程序在编译之前先运行cgo工具。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt;语句前紧挨着的注释是对应cgo的特殊语法，对应必要的构建参数选项和C语言代码。在预处理过程中，cgo工具生成一个临时包用于包含所有在Go语言中访问的C语言的函数或类型。&lt;/p&gt;
&lt;p&gt;在cgo注释中还可以包含#cgo指令，用于给C语言工具链指定特殊的参数。&lt;/p&gt;
&lt;p&gt;举个简单例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 只有go文件

package main

/*
#include &amp;lt;stdio.h&amp;gt;

void print(const char* s)
{
    puts(s);
}
*/
import &amp;quot;C&amp;quot;

func main() {
	C.print(C.CString(&amp;quot;test&amp;quot;))
}

------------------------------------

// go文件 + c文件

// c文件
#include &amp;lt;stdio.h&amp;gt;

void print(const char* s){
    puts(s);
}

// go文件
package main

//void print(const char* s);
import &amp;quot;C&amp;quot;

func main() {
	C.print(C.CString(&amp;quot;test&amp;quot;))
}

// 注意！！！go run .或go build测试效果
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于cgo更多的细节，可以看&lt;a href=&#34;https://chai2010.cn/advanced-go-programming-book/ch2-cgo/readme.html&#34;&gt;Go语言高级编程第2章&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;135-忠告&#34;&gt;13.5 忠告&lt;/h2&gt;
&lt;p&gt;unsafe包让程序员可以透过这个绝缘的抽象层直接使用一些必要的功能，代价就是牺牲了可移植性和程序安全，因此使用unsafe包是一个危险的行为。&lt;/p&gt;
- https://tianqizhang93.github.io/posts/the-go-programming-language/ - ztq.</description>
        </item>
    
    
    
        <item>
        <title>DNS,挺好,啥是DNS?</title>
        <link>https://tianqizhang93.github.io/posts/dns-bind/</link>
        <pubDate>Thu, 13 May 2021 20:53:32 +0800</pubDate>
        
        <guid>https://tianqizhang93.github.io/posts/dns-bind/</guid>
        <description>Home Page https://tianqizhang93.github.io/posts/dns-bind/ -&lt;h1 id=&#34;dns挺好啥是dns&#34;&gt;DNS，挺好，啥是DNS？&lt;/h1&gt;
&lt;h2 id=&#34;一些概念&#34;&gt;一些概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。&lt;/li&gt;
&lt;li&gt;cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源&lt;/li&gt;
&lt;li&gt;forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。&lt;/li&gt;
&lt;li&gt;CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15
&lt;ul&gt;
&lt;li&gt;A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns做什么&#34;&gt;DNS做什么&lt;/h2&gt;
&lt;p&gt;ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。&lt;/p&gt;
&lt;p&gt;主机名的解析有一个发展的过程。&lt;/p&gt;
&lt;p&gt;最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。&lt;/p&gt;
&lt;p&gt;这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。&lt;/p&gt;
&lt;p&gt;这种方式问题很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大）&lt;/li&gt;
&lt;li&gt;例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。&lt;/p&gt;
&lt;h2 id=&#34;bindberkeley-internet-name-domain&#34;&gt;BIND，Berkeley Internet Name Domain&lt;/h2&gt;
&lt;h3 id=&#34;bind管理方式&#34;&gt;BIND管理方式&lt;/h3&gt;
&lt;p&gt;BIND是一套阶层式的管理主机名与IP对应关系的系统。&lt;/p&gt;
&lt;p&gt;阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tianqizhang93.github.io/images/dns-bind/1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;以www.baidu.com为例，最上层根服务器，domain name是&amp;quot;.&amp;quot;，然后有三个hostname &amp;ldquo;net com cn&amp;rdquo;，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个&amp;quot;.&amp;ldquo;都拆分domain name&amp;amp;hostname，例如上图  video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。&lt;/p&gt;
&lt;p&gt;DNS阶层系统的最上方是一个&amp;rdquo;.&amp;quot;，root，是根服务器，本质上讲，这里的&amp;quot;.&amp;ldquo;后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。&lt;/p&gt;
&lt;p&gt;每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括&amp;rdquo;.&amp;quot;)；同一层内不允许同名，确保唯一性。&lt;/p&gt;
&lt;h3 id=&#34;bind查询流程&#34;&gt;BIND查询流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当浏览器输入 &lt;a href=&#34;https://www.baidu.com&#34;&gt;https://www.baidu.com&lt;/a&gt; ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录&lt;/li&gt;
&lt;li&gt;client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？
&lt;ul&gt;
&lt;li&gt;其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;.并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧&lt;/li&gt;
&lt;li&gt;然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果&lt;/li&gt;
&lt;li&gt;.com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧
&lt;ul&gt;
&lt;li&gt;.com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://tianqizhang93.github.io/images/dns-bind/2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;local DNS向baidu.com询问www.baidu.com的解析结果，baidu.com说，对了，这个归我管，我是权威，www.baidu.com的IP地址是****(这里其实应该是CNAME而不是A)&lt;/li&gt;
&lt;li&gt;local DNS得到权威服务器baidu.com的响应后，会缓存www.baidu.com的解析结果并响应用户的DNS解析请求
&lt;ul&gt;
&lt;li&gt;名称服务器(local DNS)收到递归查询请求并迭代出结果后，会对结果进行缓存，甚至会包括“否定缓存”，即权威返回的结果是域名或数据类型不存在，也会进行缓存，同样的，TTL也适用于否定缓存；大部分情况下，名称服务器处理递归请求，即使所查询的实际内容(域名)不在缓存中，但是其对应的权威服务器地址应该是已经在缓存中的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS：上述的解析查询一般是通过UDP协议，DNS端口53，但是不排除客户端有时会通过TCP来进行DNS解析，通常UDP解析失败客户端可能采用TCP重试，或者当客户端能预期到解析结果较大(个人理解单次解析网络请求包较多)时可能主动使用TCP进行解析。&lt;/p&gt;
&lt;p&gt;关于NS记录，当上层记录的NS A记录与下层的不同时，以下层为准；例如baidu.com记录了NS记录test.baidu.com NS 1.1.1.1,当去1.1.1.1服务器时发现该服务器记录了test.baidu.com NS 2.2.2.2,那么将以2.2.2.2为准，即后续解析服务器缓存的是test.baidu.com NS 2.2.2.2。&lt;/p&gt;
&lt;p&gt;DNS针对一个需要解析的领域(domain)称之为一个zone（区域）；记录主机名-&amp;gt;IP称之为正解，记录IP-&amp;gt;主机名称之为反解；正解zone主要记录的内容一般包括：SOA(Start Of Authority),NS(NameServer，DNS服务器),A(Address，地址，IP)；反解zone主要记录的内容除了SOA NS外，还包括PTR（PoinTeR，记录的是反解到的主机名）。&amp;quot;.&amp;ldquo;这个根服务器是所有DNS服务器都必须认识的，.的zone的类型称之为hint类型。&lt;/p&gt;
&lt;p&gt;客户端主机内DNS相关的配置文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/etc/hosts:hostname与IP的对应关系文档&lt;/li&gt;
&lt;li&gt;/etc/resolv.conf:DNS服务器IP地址（通常是local DNS）；可以填写多个，一般使用第一个，当前面的服务器故障时，按顺序使用后面的服务器；使用DHCP时，系统会主动使用DHCP服务器返回的数据修正系统/etc/resolv.conf文件，可在 /etc/sysconfig/network-scripts/ifcfg-eth0内增加一行PEERDNS=no来关闭&lt;/li&gt;
&lt;li&gt;/etc/nsswitch.conf:该文档决定先试用/etc/hosts还是/etc/resolv.conf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNS查询命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;host
&lt;ul&gt;
&lt;li&gt;host [FQDN] [server]&lt;/li&gt;
&lt;li&gt;host -a [FQDN] [server]: host -a &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt; 114.114.114.114&lt;/li&gt;
&lt;li&gt;host -l ***:需要授权，读取DNS服务器设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nslookup
&lt;ul&gt;
&lt;li&gt;nslookup [FQDN] [server]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dig
&lt;ul&gt;
&lt;li&gt;dig [options] [FQDN] [@server]: dig AAAA &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt; @114.114.114.114
&lt;ul&gt;
&lt;li&gt;QUESTION: 要查询的内容&lt;/li&gt;
&lt;li&gt;ANSWER:查询结果&lt;/li&gt;
&lt;li&gt;AUTHORITY:由哪台DNS服务器提供的答案（权威服务器）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dig -x [IP]: 查反解&lt;/li&gt;
&lt;li&gt;+trace: dig *** +trace，可以实际抓包看下，+trace的过程其实是从root开始迭代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;whois：查询zone的管理者&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bind部署&#34;&gt;BIND部署&lt;/h3&gt;
&lt;p&gt;BIND部署一般采用主从结构，master接受变更，slave同步master数据对外提供解析服务;master和slave都是权威;master又叫primary master，slave又叫secondary master, slave需要同步master的zone数据，该过程称为zone transfer；slave通常会配置为备份从master获取到的zone datafile数据，当slave冷启动时，会先加载本地zone datafile数据，并检查更新。&lt;/p&gt;
&lt;p&gt;BIND核心数据有两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BIND本身的配置文件： /etc/named.conf ，规范主机的设定，zone file位置，权限设定&lt;/li&gt;
&lt;li&gt;zone file: /var/named/ ,记录主机名于IP等关系&lt;/li&gt;
&lt;li&gt;其他文件：
&lt;ul&gt;
&lt;li&gt;/etc/sysconfig/named ：是否启动chroot及额外的参数，当BIND被change root时，所有的文件都是在新root下，例如ROOTDIR=/var/named/chroot , 那么named.conf文件的位置实际为 /var/named/chroot/etc/named.conf&lt;/li&gt;
&lt;li&gt;/var/run/named ：named进程pid文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNS通常起53端口的TCP&amp;amp;UDP监听，同时还会监听本机953端口的TCP，作为rndc(remote name daemon control，远程名称解析服务控制)服务。&lt;/p&gt;
&lt;h4 id=&#34;正解rr&#34;&gt;正解RR&lt;/h4&gt;
&lt;p&gt;常见的正解文件RR(resource record)相关信息:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;domain&lt;/th&gt;
&lt;th&gt;ttl&lt;/th&gt;
&lt;th&gt;class&lt;/th&gt;
&lt;th&gt;RR type&lt;/th&gt;
&lt;th&gt;RR data&lt;/th&gt;
&lt;th&gt;serial&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;IPv4 addr&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;AAAA&lt;/td&gt;
&lt;td&gt;IPv6 addr&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;NS&lt;/td&gt;
&lt;td&gt;管理该域的主机名&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7个参数&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;SOA&lt;/td&gt;
&lt;td&gt;管理该域的7个参数&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;MX&lt;/td&gt;
&lt;td&gt;邮件服务器&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机别名&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;CNAME&lt;/td&gt;
&lt;td&gt;该主机别名到其他主机&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PS:class取值（refer to &lt;a href=&#34;https://www.ietf.org/rfc/rfc1035.txt&#34;&gt;RFC1035&lt;/a&gt; 3.2.4）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IN: the Internet&lt;/li&gt;
&lt;li&gt;CS: the CSNET class (Obsolete - used only for examples in
some obsolete RFCs)&lt;/li&gt;
&lt;li&gt;CH: the CHAOS class&lt;/li&gt;
&lt;li&gt;HS: Hesiod [Dyer 87]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS，SOA的七个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MNAME: master服务器主机名
&lt;ul&gt;
&lt;li&gt;UPDATE requests should be forwarded toward the primary master&lt;/li&gt;
&lt;li&gt;NOTIFY requests propagate outward from the primary master&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RNAME: 管理员email, email地址中@用.进行了提换, 例如test@gmail.com，实际记录值为test.gmail.com&lt;/li&gt;
&lt;li&gt;SERIAL: YYYYMMDDNU格式，2021041500，代表2021年4月15日00次更新，slave会对比该serial以确认master数据是否比自身数据更新；该序列号&amp;lt;=2&lt;!-- raw HTML omitted --&gt;32&lt;!-- raw HTML omitted --&gt;,即4294967296&lt;/li&gt;
&lt;li&gt;REFRESH: 更新频率，slave向master请求更新的频率（仅适用于slave主动拉？不适用master notify?）；一般refresh&amp;gt;retry*2&lt;/li&gt;
&lt;li&gt;RETRY: slave与master通信的失败重试时间间隔&lt;/li&gt;
&lt;li&gt;EXPIRE: 失效时间，slave一直retry直到expire后将不再继续重试获取相应的zone file;一般&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;refresh+retry &amp;lt; expire, expire &amp;gt;= retry*10, expire &amp;gt;= 7days
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;TTL, a.k.a. MINIMUM: Time to live for purposes of negative caching. Recommendation for small and stable zones: 3600 seconds (1 hour). Originally this field had the meaning of a minimum TTL value for resource records in this zone; it was changed to its current meaning by RFC 2308. PLS refer to &lt;a href=&#34;https://tools.ietf.org/html/rfc2308&#34;&gt;RFC2308&lt;/a&gt; (BIND8.2以前的版本，用SOA最后的TTL表示区域默认TTL；BIND8.2以后，RFC2308发布，该字段的含义变成了“否定缓存TTL, negative caching TTL”,指的是远程名称服务器将区域的否定响应缓存的时间，否定响应指所查询的特定域名或域名是数据类型不存在时的应答)
&lt;ul&gt;
&lt;li&gt;那么默认TTL如何设置呢？区域数据文件中最上面的$TTL就是在设置默认TTL（仅适用BIND8.2以后的版本）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无论是name部分还是data部分，如果未使用FQDN(.结尾)，那么就会认为与本文件同域
&lt;ul&gt;
&lt;li&gt;name: zone file内第一个字段，名称的描述&lt;/li&gt;
&lt;li&gt;data: zone file内第四个字段，值的描述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@表示与当前文件描述域同名&lt;/li&gt;
&lt;li&gt;若某个资源记录的名称使用了空格(space)或制表符(tab),那么他就会沿用上一条资源记录的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e.g. zone[test.com] file如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;; Default TTL
$TTL 3h 

;
; Origin added to names not ending in a dot: test.com
;
@ IN SOA main main (
            1   ; serial
            3h  ; refresh after 3 hours
            1h  ; retry after 1 hour
            1w  ; expire after 1 week
            1h) ; negative caching TTL of 1 hour

;
; Name servers(The name &#39;@&#39; is implied)
;
  IN NS test1
  IN NS test2.testt.com.

;
; Address for the canonical names
;
localhost   IN  A   127.0.0.1
test        IN  A   10.10.1.1
            IN  A   10.10.1.2

;
; Alias
;
heihei  IN CNAME haha

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;MX的dig返回结果如下(以baidu.com为例)，可见返回了多条数据，前面带数字，一般选择数值较小的那一台&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;***$ dig mx baidu.com

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; mx baidu.com
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 34808
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 5, ADDITIONAL: 10

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;baidu.com.			IN	MX

;; ANSWER SECTION:
baidu.com.		7200	IN	MX	15 mx.n.shifen.com.
baidu.com.		7200	IN	MX	20 mx1.baidu.com.
baidu.com.		7200	IN	MX	20 jpmx.baidu.com.
baidu.com.		7200	IN	MX	20 mx50.baidu.com.
baidu.com.		7200	IN	MX	10 mx.maillb.baidu.com.
***

-----------------------------------------------------------
MX算法：
上述MX的dig结果中的数字代表该记录的优先级，该优先级是个无符号的16位数字（0-65535），数字越小优先级越高。MX转发为避免环路，转发处理时只会向更高的优先级服务器进行转发，转到最高还不行。。。会咋办忘了，具体可参考RFC2308：https://datatracker.ietf.org/doc/html/rfc2308

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;zone file内的特殊符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@ : 代表该zone的意思，例如zone为baidu.com. ， 则 @ 代表baidu.com.&lt;/li&gt;
&lt;li&gt;. : 加上了 . 表示这是个完整的主机名 (FQDN)，亦即是 &amp;ldquo;hostname + domain name&amp;rdquo; , 如果没有加上 . 的话，表示该名称仅为 &amp;ldquo;hostname&amp;rdquo; ,若zone file内主机名不以.结尾，则代表主机名.@ , 例如 baidu.com. zone 内 &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;. &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt; 两条记录分别对应 &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;. &lt;a href=&#34;http://www.baidu.com.baidu.com&#34;&gt;www.baidu.com.baidu.com&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;反解rr&#34;&gt;反解RR&lt;/h4&gt;
&lt;p&gt;常见的反解文件RR(resource record)相关信息，无A/AAAA，取而代之是PTR类型，其他同正解:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;domain&lt;/th&gt;
&lt;th&gt;ttl&lt;/th&gt;
&lt;th&gt;class&lt;/th&gt;
&lt;th&gt;RR type&lt;/th&gt;
&lt;th&gt;RR data&lt;/th&gt;
&lt;th&gt;serial&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;***&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;PTR&lt;/td&gt;
&lt;td&gt;FQDN&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;DNS分层搜索都是从大范围找到小范围最终定位，正解是根据域名寻找IP，根据域名从后向前搜索；那么反解是根据IP寻找域名，而IP越靠前代表网段范围越大，所以反解搜索时需要根据IP从前向后搜索，例如寻找11.12.13.14的主机名，一般是将IP倒序，再拼接.in-addr.arpa.(in-addr,inverse address; arpa is a TLD, refer to &lt;a href=&#34;https://en.wikipedia.org/wiki/.arpa&#34;&gt;wikipedia for arpa&lt;/a&gt;)的后缀，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ipv4:

***$ dig -x 11.12.13.14

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -x 11.12.13.14
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NXDOMAIN, id: 61795
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;14.13.12.11.in-addr.arpa.	IN PTR
***

ipv6:

***$ dig -x 2408:871a:2100:2:0:ff:b09f:237

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -x 2408:871a:2100:2:0:ff:b09f:237
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NXDOMAIN, id: 49330
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;7.3.2.0.f.9.0.b.f.f.0.0.0.0.0.0.2.0.0.0.0.0.1.2.a.1.7.8.8.0.4.2.ip6.arpa. IN PTR
***
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;rndcremote-named-control&#34;&gt;RNDC(remote named control)&lt;/h4&gt;
&lt;p&gt;BIND9以后，会在953启动rndc进程；使用rndc需要rndc key&lt;/p&gt;
&lt;p&gt;rndc命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rndc status: 查看DNS服务器状态&lt;/li&gt;
&lt;li&gt;rndc stats: 记录DNS服务器当前统计数据，保存至/var/named/data/named_stats.txt&lt;/li&gt;
&lt;li&gt;rndc dumpdb: 将cache数据写入文件，通常写到/var/named/data/cache_dump.db&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;远程更新dns服务器数据&#34;&gt;远程更新DNS服务器数据&lt;/h3&gt;
&lt;p&gt;nsupdate可远程更新DNS server数据。前提是，server端给出密钥，且指定zone支持修改。
客户端更新方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;***$ nsupdate -k somekey
&amp;gt; server 1.1.1.1 // 指定server地址
&amp;gt; update delete www.baidu.com // 删
&amp;gt; update add www.baidu.com 600 A 1.1.1.1 // 增 
&amp;gt; send
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;dns解析器&#34;&gt;DNS解析器&lt;/h3&gt;
&lt;p&gt;DNS解析器配置，通常在/etc/resolv.conf，其包含以下指令的配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;domain&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;domain test.com

# domain指令用来设定本地域名，domain空白字符后跟域名，域名最后没有. 
# 其他设定本地域名的方法：
#  1 本机hostname去除第一个.前面的数据，例如本机hostname为ztq.test.com,则根据hostname可推算本地域名为test.com
#  2 domain指令
#  3 环境变量LOCALDOMAIN
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;search&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;search a.com b.com c.com
# search指令与domain指令互斥，用来指定搜索列表
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nameserver&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nameserver 1.1.1.1
nameserver 2.2.2.2
# nameserver指令告诉解析器，要查询的名称服务器的地址
# nameserver最多支持3条，解析器会按顺序查询
# 小tips: 全零地址(0.0.0.0)和loopback地址(127.0.0.1)一般都用来指“本机”
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sortlist&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sortlist 128.32.42.0/255.255.255.0 15.0.0.0
# 当解析器获取到多个结果时，会按顺序匹配sortlist中的地址，以此来获取多地址的使用优先级
# sortlist可以跟多地址
# 128.32.42.0/255.255.255.0，/后面是子网掩码
# 15.0.0.0，也可以使用这种不带子网掩码的，含义是15/32整个网段
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;options&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;options debug
options ndots:2
options attempts:4
options timeout:2
options rotate
options ndots:2 attempts:4 timeout:2
# 解析器一些乱七八糟的配置
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://tianqizhang93.github.io/posts/dns-bind/ - ztq.</description>
        </item>
    
    
    
        <item>
        <title>新盘购房攻略(to be done)</title>
        <link>https://tianqizhang93.github.io/posts/house/</link>
        <pubDate>Tue, 11 May 2021 23:42:10 +0800</pubDate>
        
        <guid>https://tianqizhang93.github.io/posts/house/</guid>
        <description>Home Page https://tianqizhang93.github.io/posts/house/ -&lt;h2 id=&#34;第一阶段选房&#34;&gt;第一阶段，选房&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;购房时间购房资格&#34;&gt;购房时间，购房资格&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;如何选择中介中介费率or直接售楼处如何谈价格&#34;&gt;如何选择中介(中介费率)or直接售楼处，如何谈价格&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;城市选择市内区域选择&#34;&gt;城市选择，市内区域选择&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;开发商承建商物业后期物业费标准预售证五证房屋性质&#34;&gt;开发商，承建商，物业(后期物业费标准)，预售证，五证，房屋性质&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;楼座楼层户型隔音防水材料墙体厚度承重墙分布容积率出房率绿地率公摊面积房屋面积套内面积使用面积&#34;&gt;楼座，楼层，户型，隔音防水材料，墙体厚度&amp;amp;承重墙分布，容积率，出房率，绿地率，公摊面积，房屋面积，套内面积，使用面积&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;周边周边配套教育医疗商业&#34;&gt;周边：周边配套(教育/医疗/商业)&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;车位配比真人车分流电梯有-1车库有本地库有储物间一层有小庭院顶楼层高会不会更高&#34;&gt;车位配比？真人车分流？电梯有-1？车库有本？地库有储物间？一层有小庭院？顶楼层高会不会更高？&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二手房好卖&#34;&gt;二手房好卖？&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第二阶段付款&#34;&gt;第二阶段，付款&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;合同税&#34;&gt;合同，税&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;贷款办理所需材料&#34;&gt;贷款办理(所需材料？)&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;房本发放时间包括与中介协商下房本后支付中介费&#34;&gt;房本发放时间(包括与中介协商下房本后支付中介费)&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;契税什么时候交&#34;&gt;契税什么时候交？&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;中介费交多少供暖费怎么交装修押金多少&#34;&gt;中介费交多少？供暖费怎么交？装修押金多少？&lt;/h3&gt;
&lt;hr&gt;
- https://tianqizhang93.github.io/posts/house/ - ztq.</description>
        </item>
    
    
    
        <item>
        <title>关于我</title>
        <link>https://tianqizhang93.github.io/about/aboutme/</link>
        <pubDate>Thu, 15 Apr 2021 16:05:32 +0800</pubDate>
        
        <guid>https://tianqizhang93.github.io/about/aboutme/</guid>
        <description>Home Page https://tianqizhang93.github.io/about/aboutme/ -&lt;hr&gt;
&lt;h2 id=&#34;个人信息&#34;&gt;个人信息&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;性别：男&lt;/li&gt;
&lt;li&gt;年龄：28&lt;/li&gt;
&lt;li&gt;城市：北京&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;联系方式&#34;&gt;联系方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;email：dianxinztq@126.com&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;学习经历&#34;&gt;学习经历&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;th&gt;学校&lt;/th&gt;
&lt;th&gt;学历&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2016-2018&lt;/td&gt;
&lt;td&gt;南开大学&lt;/td&gt;
&lt;td&gt;硕士&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2012-2016&lt;/td&gt;
&lt;td&gt;南开大学&lt;/td&gt;
&lt;td&gt;本科&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;我做过哪些事&#34;&gt;我做过哪些事&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;2018.7 - 2021.7      百度
参与百度内外(IDC)网流量调度相关工作，以及负责一小部分百度DNS控制系统
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;2021.7 - 至今         腾讯
do something.
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;我的小目标持续更新&#34;&gt;我的小目标(持续更新)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;2021年阅读5本技术书籍
2021年每周刷2道题
2021年每个月3篇博客
2021年内彻底学习完Go语言
30岁前技术独立，技术思考独立，理解业务，接触市场
32岁前找到自己能够为之奋斗到40岁的方向
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;我想成为什么样的人&#34;&gt;我想成为什么样的人&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;技术上，能在某一领域取得一点小成绩，作出真正有价值的贡献
认知上，更多的了解这个世界的运行规律
生活上，成为一个有趣的人，照顾好家人，多与朋友交流
&lt;/code&gt;&lt;/pre&gt;- https://tianqizhang93.github.io/about/aboutme/ - ztq.</description>
        </item>
    
    
    
        <item>
        <title>关于本空间</title>
        <link>https://tianqizhang93.github.io/about/aboutthisspace/</link>
        <pubDate>Thu, 15 Apr 2021 16:03:25 +0800</pubDate>
        
        <guid>https://tianqizhang93.github.io/about/aboutthisspace/</guid>
        <description>Home Page https://tianqizhang93.github.io/about/aboutthisspace/ -&lt;hr&gt;
&lt;h2 id=&#34;category-list&#34;&gt;Category List&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;category&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;About&lt;/td&gt;
&lt;td&gt;一些介绍；包括我的个人简历，以及本空间的一些介绍内容&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;computer science&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Life&lt;/td&gt;
&lt;td&gt;一些生活上的思考&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tag-list&#34;&gt;Tag list&lt;/h2&gt;
&lt;p&gt;PS: tag说明可能不全，仅对部分内容作解释&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;其他tags:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;tag&lt;/th&gt;
&lt;th&gt;归属category&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;about&lt;/td&gt;
&lt;td&gt;About&lt;/td&gt;
&lt;td&gt;介绍内容，包括本人或者本空间&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;通用tags:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;tag&lt;/th&gt;
&lt;th&gt;归属category&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读书笔记&lt;/td&gt;
&lt;td&gt;各个category都可能会有&lt;/td&gt;
&lt;td&gt;各个目录内的读 书/paper 等的笔记&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;Life tags:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;tag&lt;/th&gt;
&lt;th&gt;归属category&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;新房&lt;/td&gt;
&lt;td&gt;Life&lt;/td&gt;
&lt;td&gt;新盘购房攻略&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;以下详细介绍 CS tags:&lt;/p&gt;
&lt;p&gt;CS-刷题 tag:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;tag&lt;/th&gt;
&lt;th&gt;归属category&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;刷题&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;刷题过程记录&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;CS-语言 tag:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;tag&lt;/th&gt;
&lt;th&gt;归属category&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Language&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;语言专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Golang&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;golang专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;python专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;C语言专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;C++语言专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rust&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;Rust语言专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;CS-源码 tag:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;tag&lt;/th&gt;
&lt;th&gt;归属category&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Source-code&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;源码专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Source-code-Golang&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;golang源码专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Source-code-K8s&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;K8s源码专栏&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;CS-DNS tag:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;tag&lt;/th&gt;
&lt;th&gt;归属category&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DNS&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;DNS内容&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
- https://tianqizhang93.github.io/about/aboutthisspace/ - ztq.</description>
        </item>
    
    
  </channel>
</rss> 