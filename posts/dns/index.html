<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DNS | Duck</title><meta name=keywords content="CS-Other"><meta name=description content='DNS，挺好，啥是DNS？
一些概念

FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。
cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源
forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。
CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15

A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号



DNS做什么
ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。
主机名的解析有一个发展的过程。
最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。
这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。
这种方式问题很多：

例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大）
例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了

时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。
BIND，Berkeley Internet Name Domain
BIND管理方式
BIND是一套阶层式的管理主机名与IP对应关系的系统。
阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。

以www.baidu.com为例，最上层根服务器，domain name是"."，然后有三个hostname &ldquo;net com cn&rdquo;，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个".&ldquo;都拆分domain name&amp;hostname，例如上图  video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。
DNS阶层系统的最上方是一个&rdquo;."，root，是根服务器，本质上讲，这里的".&ldquo;后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。
每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括&rdquo;.")；同一层内不允许同名，确保唯一性。
BIND查询流程

当浏览器输入 https://www.baidu.com ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录
client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？

其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认)


.并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧
然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果
.com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧

.com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？)



'><meta name=author content><link rel=canonical href=https://duck-dd.github.io/posts/dns/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2a8ef18cccda149eb1cd8ec968ba463447d72022979e5c5cae43dcf5d7358750.css integrity="sha256-Ko7xjMzaFJ6xzY7JaLpGNEfXICKXnlxcrkPc9dc1h1A=" rel="preload stylesheet" as=style><link rel=icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://duck-dd.github.io/posts/dns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><meta property="og:url" content="https://duck-dd.github.io/posts/dns/"><meta property="og:site_name" content="Duck"><meta property="og:title" content="DNS"><meta property="og:description" content='DNS，挺好，啥是DNS？ 一些概念 FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。 cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源 forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。 CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15 A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号 DNS做什么 ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。
主机名的解析有一个发展的过程。
最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。
这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。
这种方式问题很多：
例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大） 例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了 时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。
BIND，Berkeley Internet Name Domain BIND管理方式 BIND是一套阶层式的管理主机名与IP对应关系的系统。
阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。
以www.baidu.com为例，最上层根服务器，domain name是"."，然后有三个hostname “net com cn”，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个".“都拆分domain name&amp;hostname，例如上图 video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。
DNS阶层系统的最上方是一个”."，root，是根服务器，本质上讲，这里的".“后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。
每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括”.")；同一层内不允许同名，确保唯一性。
BIND查询流程 当浏览器输入 https://www.baidu.com ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录 client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？ 其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认) .并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧 然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果 .com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧 .com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？) '><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-13T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-13T00:00:00+00:00"><meta property="article:tag" content="CS-Other"><meta property="og:image" content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="DNS"><meta name=twitter:description content='DNS，挺好，啥是DNS？
一些概念

FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。
cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源
forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。
CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15

A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号



DNS做什么
ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。
主机名的解析有一个发展的过程。
最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。
这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。
这种方式问题很多：

例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大）
例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了

时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。
BIND，Berkeley Internet Name Domain
BIND管理方式
BIND是一套阶层式的管理主机名与IP对应关系的系统。
阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。

以www.baidu.com为例，最上层根服务器，domain name是"."，然后有三个hostname &ldquo;net com cn&rdquo;，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个".&ldquo;都拆分domain name&amp;hostname，例如上图  video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。
DNS阶层系统的最上方是一个&rdquo;."，root，是根服务器，本质上讲，这里的".&ldquo;后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。
每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括&rdquo;.")；同一层内不允许同名，确保唯一性。
BIND查询流程

当浏览器输入 https://www.baidu.com ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录
client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？

其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认)


.并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧
然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果
.com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧

.com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？)



'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://duck-dd.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DNS","item":"https://duck-dd.github.io/posts/dns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DNS","name":"DNS","description":"DNS，挺好，啥是DNS？ 一些概念 FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。 cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源 forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。 CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15 A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号 DNS做什么 ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。\n主机名的解析有一个发展的过程。\n最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。\n这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。\n这种方式问题很多：\n例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大） 例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了 时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。\nBIND，Berkeley Internet Name Domain BIND管理方式 BIND是一套阶层式的管理主机名与IP对应关系的系统。\n阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。\n以www.baidu.com为例，最上层根服务器，domain name是\u0026quot;.\u0026quot;，然后有三个hostname \u0026ldquo;net com cn\u0026rdquo;，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个\u0026quot;.\u0026ldquo;都拆分domain name\u0026amp;hostname，例如上图 video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。\nDNS阶层系统的最上方是一个\u0026rdquo;.\u0026quot;，root，是根服务器，本质上讲，这里的\u0026quot;.\u0026ldquo;后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。\n每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括\u0026rdquo;.\u0026quot;)；同一层内不允许同名，确保唯一性。\nBIND查询流程 当浏览器输入 https://www.baidu.com ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录 client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？ 其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认) .并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧 然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果 .com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧 .com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？) ","keywords":["CS-Other"],"articleBody":"DNS，挺好，啥是DNS？ 一些概念 FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。 cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源 forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。 CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15 A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号 DNS做什么 ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。\n主机名的解析有一个发展的过程。\n最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。\n这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。\n这种方式问题很多：\n例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大） 例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了 时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。\nBIND，Berkeley Internet Name Domain BIND管理方式 BIND是一套阶层式的管理主机名与IP对应关系的系统。\n阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。\n以www.baidu.com为例，最上层根服务器，domain name是\".\"，然后有三个hostname “net com cn”，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个\".“都拆分domain name\u0026hostname，例如上图 video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。\nDNS阶层系统的最上方是一个”.\"，root，是根服务器，本质上讲，这里的\".“后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。\n每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括”.\")；同一层内不允许同名，确保唯一性。\nBIND查询流程 当浏览器输入 https://www.baidu.com ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录 client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？ 其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认) .并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧 然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果 .com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧 .com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？) local DNS向baidu.com询问www.baidu.com的解析结果，baidu.com说，对了，这个归我管，我是权威，www.baidu.com的IP地址是****(这里其实应该是CNAME而不是A) local DNS得到权威服务器baidu.com的响应后，会缓存www.baidu.com的解析结果并响应用户的DNS解析请求 名称服务器(local DNS)收到递归查询请求并迭代出结果后，会对结果进行缓存，甚至会包括“否定缓存”，即权威返回的结果是域名或数据类型不存在，也会进行缓存，同样的，TTL也适用于否定缓存；大部分情况下，名称服务器处理递归请求，即使所查询的实际内容(域名)不在缓存中，但是其对应的权威服务器地址应该是已经在缓存中的 PS：上述的解析查询一般是通过UDP协议，DNS端口53，但是不排除客户端有时会通过TCP来进行DNS解析，通常UDP解析失败客户端可能采用TCP重试，或者当客户端能预期到解析结果较大(个人理解单次解析网络请求包较多)时可能主动使用TCP进行解析。\n关于NS记录，当上层记录的NS A记录与下层的不同时，以下层为准；例如baidu.com记录了NS记录test.baidu.com NS 1.1.1.1,当去1.1.1.1服务器时发现该服务器记录了test.baidu.com NS 2.2.2.2,那么将以2.2.2.2为准，即后续解析服务器缓存的是test.baidu.com NS 2.2.2.2。\nDNS针对一个需要解析的领域(domain)称之为一个zone（区域）；记录主机名-\u003eIP称之为正解，记录IP-\u003e主机名称之为反解；正解zone主要记录的内容一般包括：SOA(Start Of Authority),NS(NameServer，DNS服务器),A(Address，地址，IP)；反解zone主要记录的内容除了SOA NS外，还包括PTR（PoinTeR，记录的是反解到的主机名）。\".“这个根服务器是所有DNS服务器都必须认识的，.的zone的类型称之为hint类型。\n客户端主机内DNS相关的配置文件：\n/etc/hosts:hostname与IP的对应关系文档 /etc/resolv.conf:DNS服务器IP地址（通常是local DNS）；可以填写多个，一般使用第一个，当前面的服务器故障时，按顺序使用后面的服务器；使用DHCP时，系统会主动使用DHCP服务器返回的数据修正系统/etc/resolv.conf文件，可在 /etc/sysconfig/network-scripts/ifcfg-eth0内增加一行PEERDNS=no来关闭 /etc/nsswitch.conf:该文档决定先试用/etc/hosts还是/etc/resolv.conf DNS查询命令：\nhost host [FQDN] [server] host -a [FQDN] [server]: host -a www.baidu.com 114.114.114.114 host -l ***:需要授权，读取DNS服务器设置 nslookup nslookup [FQDN] [server] dig dig [options] [FQDN] [@server]: dig AAAA www.baidu.com @114.114.114.114 QUESTION: 要查询的内容 ANSWER:查询结果 AUTHORITY:由哪台DNS服务器提供的答案（权威服务器） dig -x [IP]: 查反解 +trace: dig *** +trace，可以实际抓包看下，+trace的过程其实是从root开始迭代 whois：查询zone的管理者 BIND部署 BIND部署一般采用主从结构，master接受变更，slave同步master数据对外提供解析服务;master和slave都是权威;master又叫primary master，slave又叫secondary master, slave需要同步master的zone数据，该过程称为zone transfer；slave通常会配置为备份从master获取到的zone datafile数据，当slave冷启动时，会先加载本地zone datafile数据，并检查更新。\nBIND核心数据有两部分：\nBIND本身的配置文件： /etc/named.conf ，规范主机的设定，zone file位置，权限设定 zone file: /var/named/ ,记录主机名于IP等关系 其他文件： /etc/sysconfig/named ：是否启动chroot及额外的参数，当BIND被change root时，所有的文件都是在新root下，例如ROOTDIR=/var/named/chroot , 那么named.conf文件的位置实际为 /var/named/chroot/etc/named.conf /var/run/named ：named进程pid文件 DNS通常起53端口的TCP\u0026UDP监听，同时还会监听本机953端口的TCP，作为rndc(remote name daemon control，远程名称解析服务控制)服务。\n正解RR 常见的正解文件RR(resource record)相关信息:\ndomain ttl class RR type RR data serial 主机名 60 IN A IPv4 addr * 主机名 60 IN AAAA IPv6 addr * 主机名 60 IN NS 管理该域的主机名 * 7个参数 60 IN SOA 管理该域的7个参数 * 主机名 60 IN MX 邮件服务器 * 主机别名 60 IN CNAME 该主机别名到其他主机 * PS:class取值（refer to RFC1035 3.2.4）：\nIN: the Internet CS: the CSNET class (Obsolete - used only for examples in some obsolete RFCs) CH: the CHAOS class HS: Hesiod [Dyer 87] PS，SOA的七个参数：\nMNAME: master服务器主机名 UPDATE requests should be forwarded toward the primary master NOTIFY requests propagate outward from the primary master RNAME: 管理员email, email地址中@用.进行了提换, 例如test@gmail.com，实际记录值为test.gmail.com SERIAL: YYYYMMDDNU格式，2021041500，代表2021年4月15日00次更新，slave会对比该serial以确认master数据是否比自身数据更新；该序列号\u003c=232,即4294967296 REFRESH: 更新频率，slave向master请求更新的频率（仅适用于slave主动拉？不适用master notify?）；一般refresh\u003eretry*2 RETRY: slave与master通信的失败重试时间间隔 EXPIRE: 失效时间，slave一直retry直到expire后将不再继续重试获取相应的zone file;一般 refresh+retry \u003c expire, expire \u003e= retry*10, expire \u003e= 7days TTL, a.k.a. MINIMUM: Time to live for purposes of negative caching. Recommendation for small and stable zones: 3600 seconds (1 hour). Originally this field had the meaning of a minimum TTL value for resource records in this zone; it was changed to its current meaning by RFC 2308. PLS refer to RFC2308 (BIND8.2以前的版本，用SOA最后的TTL表示区域默认TTL；BIND8.2以后，RFC2308发布，该字段的含义变成了“否定缓存TTL, negative caching TTL”,指的是远程名称服务器将区域的否定响应缓存的时间，否定响应指所查询的特定域名或域名是数据类型不存在时的应答) 那么默认TTL如何设置呢？区域数据文件中最上面的$TTL就是在设置默认TTL（仅适用BIND8.2以后的版本） PS：\n无论是name部分还是data部分，如果未使用FQDN(.结尾)，那么就会认为与本文件同域 name: zone file内第一个字段，名称的描述 data: zone file内第四个字段，值的描述 @表示与当前文件描述域同名 若某个资源记录的名称使用了空格(space)或制表符(tab),那么他就会沿用上一条资源记录的名称 e.g. zone[test.com] file如下:\n; Default TTL $TTL 3h ; ; Origin added to names not ending in a dot: test.com ; @ IN SOA main main ( 1 ; serial 3h ; refresh after 3 hours 1h ; retry after 1 hour 1w ; expire after 1 week 1h) ; negative caching TTL of 1 hour ; ; Name servers(The name '@' is implied) ; IN NS test1 IN NS test2.testt.com. ; ; Address for the canonical names ; localhost IN A 127.0.0.1 test IN A 10.10.1.1 IN A 10.10.1.2 ; ; Alias ; heihei IN CNAME haha MX的dig返回结果如下(以baidu.com为例)，可见返回了多条数据，前面带数字，一般选择数值较小的那一台\n***$ dig mx baidu.com ; \u003c\u003c\u003e\u003e DiG 9.10.6 \u003c\u003c\u003e\u003e mx baidu.com ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 34808 ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 5, ADDITIONAL: 10 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;baidu.com.\tIN\tMX ;; ANSWER SECTION: baidu.com.\t7200\tIN\tMX\t15 mx.n.shifen.com. baidu.com.\t7200\tIN\tMX\t20 mx1.baidu.com. baidu.com.\t7200\tIN\tMX\t20 jpmx.baidu.com. baidu.com.\t7200\tIN\tMX\t20 mx50.baidu.com. baidu.com.\t7200\tIN\tMX\t10 mx.maillb.baidu.com. *** ----------------------------------------------------------- MX算法： 上述MX的dig结果中的数字代表该记录的优先级，该优先级是个无符号的16位数字（0-65535），数字越小优先级越高。MX转发为避免环路，转发处理时只会向更高的优先级服务器进行转发，转到最高还不行。。。会咋办忘了，具体可参考RFC2308：https://datatracker.ietf.org/doc/html/rfc2308 zone file内的特殊符号：\n@ : 代表该zone的意思，例如zone为baidu.com. ， 则 @ 代表baidu.com. . : 加上了 . 表示这是个完整的主机名 (FQDN)，亦即是 “hostname + domain name” , 如果没有加上 . 的话，表示该名称仅为 “hostname” ,若zone file内主机名不以.结尾，则代表主机名.@ , 例如 baidu.com. zone 内 www.baidu.com. www.baidu.com 两条记录分别对应 www.baidu.com. www.baidu.com.baidu.com. 反解RR 常见的反解文件RR(resource record)相关信息，无A/AAAA，取而代之是PTR类型，其他同正解:\ndomain ttl class RR type RR data serial *** 60 IN PTR FQDN * DNS分层搜索都是从大范围找到小范围最终定位，正解是根据域名寻找IP，根据域名从后向前搜索；那么反解是根据IP寻找域名，而IP越靠前代表网段范围越大，所以反解搜索时需要根据IP从前向后搜索，例如寻找11.12.13.14的主机名，一般是将IP倒序，再拼接.in-addr.arpa.(in-addr,inverse address; arpa is a TLD, refer to wikipedia for arpa)的后缀，如下：\nipv4: ***$ dig -x 11.12.13.14 ; \u003c\u003c\u003e\u003e DiG 9.10.6 \u003c\u003c\u003e\u003e -x 11.12.13.14 ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NXDOMAIN, id: 61795 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;14.13.12.11.in-addr.arpa.\tIN PTR *** ipv6: ***$ dig -x 2408:871a:2100:2:0:ff:b09f:237 ; \u003c\u003c\u003e\u003e DiG 9.10.6 \u003c\u003c\u003e\u003e -x 2408:871a:2100:2:0:ff:b09f:237 ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NXDOMAIN, id: 49330 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;7.3.2.0.f.9.0.b.f.f.0.0.0.0.0.0.2.0.0.0.0.0.1.2.a.1.7.8.8.0.4.2.ip6.arpa. IN PTR *** RNDC(remote named control) BIND9以后，会在953启动rndc进程；使用rndc需要rndc key\nrndc命令：\nrndc status: 查看DNS服务器状态 rndc stats: 记录DNS服务器当前统计数据，保存至/var/named/data/named_stats.txt rndc dumpdb: 将cache数据写入文件，通常写到/var/named/data/cache_dump.db 远程更新DNS服务器数据 nsupdate可远程更新DNS server数据。前提是，server端给出密钥，且指定zone支持修改。 客户端更新方式：\n***$ nsupdate -k somekey \u003e server 1.1.1.1 // 指定server地址 \u003e update delete www.baidu.com // 删 \u003e update add www.baidu.com 600 A 1.1.1.1 // 增 \u003e send DNS解析器 DNS解析器配置，通常在/etc/resolv.conf，其包含以下指令的配置：\ndomain\ndomain test.com # domain指令用来设定本地域名，domain空白字符后跟域名，域名最后没有. # 其他设定本地域名的方法： # 1 本机hostname去除第一个.前面的数据，例如本机hostname为ztq.test.com,则根据hostname可推算本地域名为test.com # 2 domain指令 # 3 环境变量LOCALDOMAIN search\nsearch a.com b.com c.com # search指令与domain指令互斥，用来指定搜索列表 nameserver\nnameserver 1.1.1.1 nameserver 2.2.2.2 # nameserver指令告诉解析器，要查询的名称服务器的地址 # nameserver最多支持3条，解析器会按顺序查询 # 小tips: 全零地址(0.0.0.0)和loopback地址(127.0.0.1)一般都用来指“本机” sortlist\nsortlist 128.32.42.0/255.255.255.0 15.0.0.0 # 当解析器获取到多个结果时，会按顺序匹配sortlist中的地址，以此来获取多地址的使用优先级 # sortlist可以跟多地址 # 128.32.42.0/255.255.255.0，/后面是子网掩码 # 15.0.0.0，也可以使用这种不带子网掩码的，含义是15/32整个网段 options\noptions debug options ndots:2 options attempts:4 options timeout:2 options rotate options ndots:2 attempts:4 timeout:2 # 解析器一些乱七八糟的配置 ","wordCount":"847","inLanguage":"en","image":"https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2021-05-13T00:00:00Z","dateModified":"2021-05-13T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://duck-dd.github.io/posts/dns/"},"publisher":{"@type":"Organization","name":"Duck","logo":{"@type":"ImageObject","url":"https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://duck-dd.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://duck-dd.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://duck-dd.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://duck-dd.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://duck-dd.github.io/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://duck-dd.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://duck-dd.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">DNS</h1><div class=post-meta><span title='2021-05-13 00:00:00 +0000 UTC'>2021-05-13</span>&nbsp;·&nbsp;创建于:&nbsp;2021-05-13&nbsp;·&nbsp;4 min&nbsp;·&nbsp;847 words<div class=meta-item>&nbsp·&nbsp
<a href=https://duck-dd.github.io/categories/cs/>CS</a></div><div class=meta-item>&nbsp·&nbsp
<a href=https://duck-dd.github.io/tags/cs-other/>CS-Other</a></div></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#dns%e6%8c%ba%e5%a5%bd%e5%95%a5%e6%98%afdns aria-label=DNS，挺好，啥是DNS？>DNS，挺好，啥是DNS？</a><ul><li><a href=#%e4%b8%80%e4%ba%9b%e6%a6%82%e5%bf%b5 aria-label=一些概念>一些概念</a></li><li><a href=#dns%e5%81%9a%e4%bb%80%e4%b9%88 aria-label=DNS做什么>DNS做什么</a></li><li><a href=#bindberkeley-internet-name-domain aria-label="BIND，Berkeley Internet Name Domain">BIND，Berkeley Internet Name Domain</a><ul><li><a href=#bind%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label=BIND管理方式>BIND管理方式</a></li><li><a href=#bind%e6%9f%a5%e8%af%a2%e6%b5%81%e7%a8%8b aria-label=BIND查询流程>BIND查询流程</a></li><li><a href=#bind%e9%83%a8%e7%bd%b2 aria-label=BIND部署>BIND部署</a><ul><li><a href=#%e6%ad%a3%e8%a7%a3rr aria-label=正解RR>正解RR</a></li><li><a href=#%e5%8f%8d%e8%a7%a3rr aria-label=反解RR>反解RR</a></li><li><a href=#rndcremote-named-control aria-label="RNDC(remote named control)">RNDC(remote named control)</a></li></ul></li><li><a href=#%e8%bf%9c%e7%a8%8b%e6%9b%b4%e6%96%b0dns%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%95%b0%e6%8d%ae aria-label=远程更新DNS服务器数据>远程更新DNS服务器数据</a></li><li><a href=#dns%e8%a7%a3%e6%9e%90%e5%99%a8 aria-label=DNS解析器>DNS解析器</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=dns挺好啥是dns>DNS，挺好，啥是DNS？<a hidden class=anchor aria-hidden=true href=#dns挺好啥是dns>#</a></h1><h2 id=一些概念>一些概念<a hidden class=anchor aria-hidden=true href=#一些概念>#</a></h2><ul><li>FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。</li><li>cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源</li><li>forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。</li><li>CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15<ul><li>A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号</li></ul></li></ul><h2 id=dns做什么>DNS做什么<a hidden class=anchor aria-hidden=true href=#dns做什么>#</a></h2><p>ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。</p><p>主机名的解析有一个发展的过程。</p><p>最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。</p><p>这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。</p><p>这种方式问题很多：</p><ul><li>例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大）</li><li>例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了</li></ul><p>时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。</p><h2 id=bindberkeley-internet-name-domain>BIND，Berkeley Internet Name Domain<a hidden class=anchor aria-hidden=true href=#bindberkeley-internet-name-domain>#</a></h2><h3 id=bind管理方式>BIND管理方式<a hidden class=anchor aria-hidden=true href=#bind管理方式>#</a></h3><p>BIND是一套阶层式的管理主机名与IP对应关系的系统。</p><p>阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。</p><p><img loading=lazy src=/images/dns/1.jpg></p><p>以www.baidu.com为例，最上层根服务器，domain name是"."，然后有三个hostname &ldquo;net com cn&rdquo;，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个".&ldquo;都拆分domain name&amp;hostname，例如上图 video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。</p><p>DNS阶层系统的最上方是一个&rdquo;."，root，是根服务器，本质上讲，这里的".&ldquo;后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。</p><p>每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括&rdquo;.")；同一层内不允许同名，确保唯一性。</p><h3 id=bind查询流程>BIND查询流程<a hidden class=anchor aria-hidden=true href=#bind查询流程>#</a></h3><ol><li>当浏览器输入 <a href=https://www.baidu.com>https://www.baidu.com</a> ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录</li><li>client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？<ul><li>其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认)</li></ul></li><li>.并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧</li><li>然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果</li><li>.com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧<ul><li>.com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？)</li></ul></li></ol><p><img loading=lazy src=/images/dns/2.jpg></p><ol start=6><li>local DNS向baidu.com询问www.baidu.com的解析结果，baidu.com说，对了，这个归我管，我是权威，www.baidu.com的IP地址是****(这里其实应该是CNAME而不是A)</li><li>local DNS得到权威服务器baidu.com的响应后，会缓存www.baidu.com的解析结果并响应用户的DNS解析请求<ul><li>名称服务器(local DNS)收到递归查询请求并迭代出结果后，会对结果进行缓存，甚至会包括“否定缓存”，即权威返回的结果是域名或数据类型不存在，也会进行缓存，同样的，TTL也适用于否定缓存；大部分情况下，名称服务器处理递归请求，即使所查询的实际内容(域名)不在缓存中，但是其对应的权威服务器地址应该是已经在缓存中的</li></ul></li></ol><p>PS：上述的解析查询一般是通过UDP协议，DNS端口53，但是不排除客户端有时会通过TCP来进行DNS解析，通常UDP解析失败客户端可能采用TCP重试，或者当客户端能预期到解析结果较大(个人理解单次解析网络请求包较多)时可能主动使用TCP进行解析。</p><p>关于NS记录，当上层记录的NS A记录与下层的不同时，以下层为准；例如baidu.com记录了NS记录test.baidu.com NS 1.1.1.1,当去1.1.1.1服务器时发现该服务器记录了test.baidu.com NS 2.2.2.2,那么将以2.2.2.2为准，即后续解析服务器缓存的是test.baidu.com NS 2.2.2.2。</p><p>DNS针对一个需要解析的领域(domain)称之为一个zone（区域）；记录主机名->IP称之为正解，记录IP->主机名称之为反解；正解zone主要记录的内容一般包括：SOA(Start Of Authority),NS(NameServer，DNS服务器),A(Address，地址，IP)；反解zone主要记录的内容除了SOA NS外，还包括PTR（PoinTeR，记录的是反解到的主机名）。".&ldquo;这个根服务器是所有DNS服务器都必须认识的，.的zone的类型称之为hint类型。</p><p>客户端主机内DNS相关的配置文件：</p><ul><li>/etc/hosts:hostname与IP的对应关系文档</li><li>/etc/resolv.conf:DNS服务器IP地址（通常是local DNS）；可以填写多个，一般使用第一个，当前面的服务器故障时，按顺序使用后面的服务器；使用DHCP时，系统会主动使用DHCP服务器返回的数据修正系统/etc/resolv.conf文件，可在 /etc/sysconfig/network-scripts/ifcfg-eth0内增加一行PEERDNS=no来关闭</li><li>/etc/nsswitch.conf:该文档决定先试用/etc/hosts还是/etc/resolv.conf</li></ul><p>DNS查询命令：</p><ul><li>host<ul><li>host [FQDN] [server]</li><li>host -a [FQDN] [server]: host -a <a href=https://www.baidu.com>www.baidu.com</a> 114.114.114.114</li><li>host -l ***:需要授权，读取DNS服务器设置</li></ul></li><li>nslookup<ul><li>nslookup [FQDN] [server]</li></ul></li><li>dig<ul><li>dig [options] [FQDN] [@server]: dig AAAA <a href=https://www.baidu.com>www.baidu.com</a> @114.114.114.114<ul><li>QUESTION: 要查询的内容</li><li>ANSWER:查询结果</li><li>AUTHORITY:由哪台DNS服务器提供的答案（权威服务器）</li></ul></li><li>dig -x [IP]: 查反解</li><li>+trace: dig *** +trace，可以实际抓包看下，+trace的过程其实是从root开始迭代</li></ul></li><li>whois：查询zone的管理者</li></ul><h3 id=bind部署>BIND部署<a hidden class=anchor aria-hidden=true href=#bind部署>#</a></h3><p>BIND部署一般采用主从结构，master接受变更，slave同步master数据对外提供解析服务;master和slave都是权威;master又叫primary master，slave又叫secondary master, slave需要同步master的zone数据，该过程称为zone transfer；slave通常会配置为备份从master获取到的zone datafile数据，当slave冷启动时，会先加载本地zone datafile数据，并检查更新。</p><p>BIND核心数据有两部分：</p><ul><li>BIND本身的配置文件： /etc/named.conf ，规范主机的设定，zone file位置，权限设定</li><li>zone file: /var/named/ ,记录主机名于IP等关系</li><li>其他文件：<ul><li>/etc/sysconfig/named ：是否启动chroot及额外的参数，当BIND被change root时，所有的文件都是在新root下，例如ROOTDIR=/var/named/chroot , 那么named.conf文件的位置实际为 /var/named/chroot/etc/named.conf</li><li>/var/run/named ：named进程pid文件</li></ul></li></ul><p>DNS通常起53端口的TCP&amp;UDP监听，同时还会监听本机953端口的TCP，作为rndc(remote name daemon control，远程名称解析服务控制)服务。</p><h4 id=正解rr>正解RR<a hidden class=anchor aria-hidden=true href=#正解rr>#</a></h4><p>常见的正解文件RR(resource record)相关信息:</p><table><thead><tr><th>domain</th><th>ttl</th><th>class</th><th>RR type</th><th>RR data</th><th>serial</th></tr></thead><tbody><tr><td>主机名</td><td>60</td><td>IN</td><td>A</td><td>IPv4 addr</td><td>*</td></tr><tr><td>主机名</td><td>60</td><td>IN</td><td>AAAA</td><td>IPv6 addr</td><td>*</td></tr><tr><td>主机名</td><td>60</td><td>IN</td><td>NS</td><td>管理该域的主机名</td><td>*</td></tr><tr><td>7个参数</td><td>60</td><td>IN</td><td>SOA</td><td>管理该域的7个参数</td><td>*</td></tr><tr><td>主机名</td><td>60</td><td>IN</td><td>MX</td><td>邮件服务器</td><td>*</td></tr><tr><td>主机别名</td><td>60</td><td>IN</td><td>CNAME</td><td>该主机别名到其他主机</td><td>*</td></tr></tbody></table><p>PS:class取值（refer to <a href=https://www.ietf.org/rfc/rfc1035.txt>RFC1035</a> 3.2.4）：</p><ul><li>IN: the Internet</li><li>CS: the CSNET class (Obsolete - used only for examples in
some obsolete RFCs)</li><li>CH: the CHAOS class</li><li>HS: Hesiod [Dyer 87]</li></ul><p>PS，SOA的七个参数：</p><ol><li>MNAME: master服务器主机名<ul><li>UPDATE requests should be forwarded toward the primary master</li><li>NOTIFY requests propagate outward from the primary master</li></ul></li><li>RNAME: 管理员email, email地址中@用.进行了提换, 例如test@gmail.com，实际记录值为test.gmail.com</li><li>SERIAL: YYYYMMDDNU格式，2021041500，代表2021年4月15日00次更新，slave会对比该serial以确认master数据是否比自身数据更新；该序列号&lt;=2<sup>32</sup>,即4294967296</li><li>REFRESH: 更新频率，slave向master请求更新的频率（仅适用于slave主动拉？不适用master notify?）；一般refresh>retry*2</li><li>RETRY: slave与master通信的失败重试时间间隔</li><li>EXPIRE: 失效时间，slave一直retry直到expire后将不再继续重试获取相应的zone file;一般</li></ol><pre tabindex=0><code>refresh+retry &lt; expire, expire &gt;= retry*10, expire &gt;= 7days
</code></pre><ol start=7><li>TTL, a.k.a. MINIMUM: Time to live for purposes of negative caching. Recommendation for small and stable zones: 3600 seconds (1 hour). Originally this field had the meaning of a minimum TTL value for resource records in this zone; it was changed to its current meaning by RFC 2308. PLS refer to <a href=https://tools.ietf.org/html/rfc2308>RFC2308</a> (BIND8.2以前的版本，用SOA最后的TTL表示区域默认TTL；BIND8.2以后，RFC2308发布，该字段的含义变成了“否定缓存TTL, negative caching TTL”,指的是远程名称服务器将区域的否定响应缓存的时间，否定响应指所查询的特定域名或域名是数据类型不存在时的应答)<ul><li>那么默认TTL如何设置呢？区域数据文件中最上面的$TTL就是在设置默认TTL（仅适用BIND8.2以后的版本）</li></ul></li></ol><p>PS：</p><ul><li>无论是name部分还是data部分，如果未使用FQDN(.结尾)，那么就会认为与本文件同域<ul><li>name: zone file内第一个字段，名称的描述</li><li>data: zone file内第四个字段，值的描述</li></ul></li><li>@表示与当前文件描述域同名</li><li>若某个资源记录的名称使用了空格(space)或制表符(tab),那么他就会沿用上一条资源记录的名称</li></ul><p>e.g. zone[test.com] file如下:</p><pre tabindex=0><code>; Default TTL
$TTL 3h 

;
; Origin added to names not ending in a dot: test.com
;
@ IN SOA main main (
            1   ; serial
            3h  ; refresh after 3 hours
            1h  ; retry after 1 hour
            1w  ; expire after 1 week
            1h) ; negative caching TTL of 1 hour

;
; Name servers(The name &#39;@&#39; is implied)
;
  IN NS test1
  IN NS test2.testt.com.

;
; Address for the canonical names
;
localhost   IN  A   127.0.0.1
test        IN  A   10.10.1.1
            IN  A   10.10.1.2

;
; Alias
;
heihei  IN CNAME haha
</code></pre><p>MX的dig返回结果如下(以baidu.com为例)，可见返回了多条数据，前面带数字，一般选择数值较小的那一台</p><pre tabindex=0><code>***$ dig mx baidu.com

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; mx baidu.com
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 34808
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 5, ADDITIONAL: 10

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;baidu.com.			IN	MX

;; ANSWER SECTION:
baidu.com.		7200	IN	MX	15 mx.n.shifen.com.
baidu.com.		7200	IN	MX	20 mx1.baidu.com.
baidu.com.		7200	IN	MX	20 jpmx.baidu.com.
baidu.com.		7200	IN	MX	20 mx50.baidu.com.
baidu.com.		7200	IN	MX	10 mx.maillb.baidu.com.
***

-----------------------------------------------------------
MX算法：
上述MX的dig结果中的数字代表该记录的优先级，该优先级是个无符号的16位数字（0-65535），数字越小优先级越高。MX转发为避免环路，转发处理时只会向更高的优先级服务器进行转发，转到最高还不行。。。会咋办忘了，具体可参考RFC2308：https://datatracker.ietf.org/doc/html/rfc2308
</code></pre><p>zone file内的特殊符号：</p><ul><li>@ : 代表该zone的意思，例如zone为baidu.com. ， 则 @ 代表baidu.com.</li><li>. : 加上了 . 表示这是个完整的主机名 (FQDN)，亦即是 &ldquo;hostname + domain name&rdquo; , 如果没有加上 . 的话，表示该名称仅为 &ldquo;hostname&rdquo; ,若zone file内主机名不以.结尾，则代表主机名.@ , 例如 baidu.com. zone 内 <a href=https://www.baidu.com>www.baidu.com</a>. <a href=https://www.baidu.com>www.baidu.com</a> 两条记录分别对应 <a href=https://www.baidu.com>www.baidu.com</a>. <a href=https://www.baidu.com.baidu.com>www.baidu.com.baidu.com</a>.</li></ul><h4 id=反解rr>反解RR<a hidden class=anchor aria-hidden=true href=#反解rr>#</a></h4><p>常见的反解文件RR(resource record)相关信息，无A/AAAA，取而代之是PTR类型，其他同正解:</p><table><thead><tr><th>domain</th><th>ttl</th><th>class</th><th>RR type</th><th>RR data</th><th>serial</th></tr></thead><tbody><tr><td>***</td><td>60</td><td>IN</td><td>PTR</td><td>FQDN</td><td>*</td></tr></tbody></table><p>DNS分层搜索都是从大范围找到小范围最终定位，正解是根据域名寻找IP，根据域名从后向前搜索；那么反解是根据IP寻找域名，而IP越靠前代表网段范围越大，所以反解搜索时需要根据IP从前向后搜索，例如寻找11.12.13.14的主机名，一般是将IP倒序，再拼接.in-addr.arpa.(in-addr,inverse address; arpa is a TLD, refer to <a href=https://en.wikipedia.org/wiki/.arpa>wikipedia for arpa</a>)的后缀，如下：</p><pre tabindex=0><code>ipv4:

***$ dig -x 11.12.13.14

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; -x 11.12.13.14
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 61795
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;14.13.12.11.in-addr.arpa.	IN PTR
***

ipv6:

***$ dig -x 2408:871a:2100:2:0:ff:b09f:237

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; -x 2408:871a:2100:2:0:ff:b09f:237
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 49330
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;7.3.2.0.f.9.0.b.f.f.0.0.0.0.0.0.2.0.0.0.0.0.1.2.a.1.7.8.8.0.4.2.ip6.arpa. IN PTR
***
</code></pre><h4 id=rndcremote-named-control>RNDC(remote named control)<a hidden class=anchor aria-hidden=true href=#rndcremote-named-control>#</a></h4><p>BIND9以后，会在953启动rndc进程；使用rndc需要rndc key</p><p>rndc命令：</p><ul><li>rndc status: 查看DNS服务器状态</li><li>rndc stats: 记录DNS服务器当前统计数据，保存至/var/named/data/named_stats.txt</li><li>rndc dumpdb: 将cache数据写入文件，通常写到/var/named/data/cache_dump.db</li></ul><h3 id=远程更新dns服务器数据>远程更新DNS服务器数据<a hidden class=anchor aria-hidden=true href=#远程更新dns服务器数据>#</a></h3><p>nsupdate可远程更新DNS server数据。前提是，server端给出密钥，且指定zone支持修改。
客户端更新方式：</p><pre tabindex=0><code>***$ nsupdate -k somekey
&gt; server 1.1.1.1 // 指定server地址
&gt; update delete www.baidu.com // 删
&gt; update add www.baidu.com 600 A 1.1.1.1 // 增 
&gt; send
</code></pre><h3 id=dns解析器>DNS解析器<a hidden class=anchor aria-hidden=true href=#dns解析器>#</a></h3><p>DNS解析器配置，通常在/etc/resolv.conf，其包含以下指令的配置：</p><ul><li><p>domain</p><pre tabindex=0><code>domain test.com

# domain指令用来设定本地域名，domain空白字符后跟域名，域名最后没有. 
# 其他设定本地域名的方法：
#  1 本机hostname去除第一个.前面的数据，例如本机hostname为ztq.test.com,则根据hostname可推算本地域名为test.com
#  2 domain指令
#  3 环境变量LOCALDOMAIN
</code></pre></li><li><p>search</p><pre tabindex=0><code>search a.com b.com c.com
# search指令与domain指令互斥，用来指定搜索列表
</code></pre></li><li><p>nameserver</p><pre tabindex=0><code>nameserver 1.1.1.1
nameserver 2.2.2.2
# nameserver指令告诉解析器，要查询的名称服务器的地址
# nameserver最多支持3条，解析器会按顺序查询
# 小tips: 全零地址(0.0.0.0)和loopback地址(127.0.0.1)一般都用来指“本机”
</code></pre></li><li><p>sortlist</p><pre tabindex=0><code>sortlist 128.32.42.0/255.255.255.0 15.0.0.0
# 当解析器获取到多个结果时，会按顺序匹配sortlist中的地址，以此来获取多地址的使用优先级
# sortlist可以跟多地址
# 128.32.42.0/255.255.255.0，/后面是子网掩码
# 15.0.0.0，也可以使用这种不带子网掩码的，含义是15/32整个网段
</code></pre></li><li><p>options</p><pre tabindex=0><code>options debug
options ndots:2
options attempts:4
options timeout:2
options rotate
options ndots:2 attempts:4 timeout:2
# 解析器一些乱七八糟的配置
</code></pre></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://duck-dd.github.io/tags/cs-other/>CS-Other</a></li></ul><nav class=paginav><a class=prev href=https://duck-dd.github.io/posts/go-schedule/><span class=title>« Prev</span><br><span>Golang schedule</span></a></nav></footer><script src=https://utteranc.es/client.js repo=duck-dd/blog-comment issue-term=pathname label='💬 Comments' theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://duck-dd.github.io/>Duck</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$",right:"$",display:!1},{left:"$$",right:"$$",display:!0}],throwOnError:!1})})</script></body></html>