<!DOCTYPE html>
<html><head>
<title>Golang schedule</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">



<meta property="og:title" content="Golang schedule" />
<meta property="og:description" content="写在前面 如果哪里写错辣了您的眼睛，请务必评论区批评指正，感激不尽。
留了一些TODO。
runtime包实现了所有goroutine scheduler、memory allocator、garbage collector细节，理论上可以从runtime包获取一切信息，没有直接怼源码，而是站在巨人的肩膀上（直接吃大佬们吃剩下的），看大家的各种说法，整理一下。
搜集到的材料，大家都是基于不同的go版本做的分析，而go版本迭代调度算法也在持续更新，所以整理的可能有些乱。但是可以保证的是，所有材料都是GM-&gt;GMP演化后的材料。
GM go1.1版本以前，调度使用GM模型，如下图所示。简单的理解GM模型，就是有一个始终执行的调度函数schedule不停的执行调度计算，当某个M的G执行完成了，调度器就把这个M放回M队列，可绑定执行其他G（如果某个M&#43;G发生了syscall，那么本来并发度是通过M数量控制的，此时并发度就降低了？）；如果G执行过程中创建新的G，会将新的G放入到G全局可执行队列中。G全局可执行队列的操作有一把全局锁，这导致了各个M对G全局队列的操作存在严重的竞争。
下面这段完全是我的臆测，请别太相信：
 简单概括呢，所以可以认为有：
 G全局可执行队列(以下也可能简称G可执行队列) M可用队列  调度器要做的事就是：
 从G的可执行队列取G并从M的可用队列取M，将二者绑定开始执行G 对于已经执行完的G，销毁G并立即将M释放回M可用队列供后续使用   那么GM模型有哪些问题呢？
 (重点问题)单一的全局mutex(sched.lock)和集中状态管理  mutex需要保护所有与全局goroutine队列相关操作(创建、完成、重排等等)，竞争严重   (重点问题)per-M内存(M.mcache)问题  每个M都需要一个mcache，会导致资源消耗过大(每个mcache可以吸纳到2MB的内存缓存和其他缓存)  举个栗子，一个陷入syscall的M并不需要使用cache，但是在全部的M中，陷入系统调用的M与执行goroutine的M的比例可能是N:1(N&gt;&gt;1)，这就导致了N/(N&#43;1)比例的mcache在闲置   数据局部性差:  举个栗子，M1执行G1，此时创建了G2，G2通常是立刻进入了G全局可执行队列，而此时M1还在执行G1，所以G2通常被其他M执行，但是G1和G2通常强相关，所以G2最好也在M1上执行，因为G2对M1的缓存命中率更高     goroutine传递问题  goroutine(G)交接(G.nextg)，M之间会经常交接可运行的G 再通俗点说，就是G空转，本来能够好好在一个M上执行完，但是由于全局队列的存在，G一旦回全局队列了，下次就不知道被哪个M取走了，所以叫“空转”；M加载G的上下文是有开销的，所以空转会导致性能下降   频繁的线程阻塞/解阻塞  syscalls情况下，线程经常被阻塞和解阻塞，增加了很多额外开销 通俗点说，M&#43;G syscall，M阻塞，syscall完成后，M解阻塞继续执行G（如果是通过M数量控制并发度，这是不是就导致了并发度降低？）    GMP 基于以上说的GM的问题，go1.1以后开始使用GMP调度模型。 G、M、P的定义如下(***/src/runtime/runtime2.go)。
type g struct { // Stack parameters. // stack describes the actual stack memory: [stack." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tianqizhang93.github.io/posts/golang-schedule/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-21T22:27:31+08:00" />
<meta property="article:modified_time" content="2021-08-21T22:27:31+08:00" /><meta property="og:site_name" content="ZTQ&#39;s Blog" />






<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang schedule"/>
<meta name="twitter:description" content="写在前面 如果哪里写错辣了您的眼睛，请务必评论区批评指正，感激不尽。
留了一些TODO。
runtime包实现了所有goroutine scheduler、memory allocator、garbage collector细节，理论上可以从runtime包获取一切信息，没有直接怼源码，而是站在巨人的肩膀上（直接吃大佬们吃剩下的），看大家的各种说法，整理一下。
搜集到的材料，大家都是基于不同的go版本做的分析，而go版本迭代调度算法也在持续更新，所以整理的可能有些乱。但是可以保证的是，所有材料都是GM-&gt;GMP演化后的材料。
GM go1.1版本以前，调度使用GM模型，如下图所示。简单的理解GM模型，就是有一个始终执行的调度函数schedule不停的执行调度计算，当某个M的G执行完成了，调度器就把这个M放回M队列，可绑定执行其他G（如果某个M&#43;G发生了syscall，那么本来并发度是通过M数量控制的，此时并发度就降低了？）；如果G执行过程中创建新的G，会将新的G放入到G全局可执行队列中。G全局可执行队列的操作有一把全局锁，这导致了各个M对G全局队列的操作存在严重的竞争。
下面这段完全是我的臆测，请别太相信：
 简单概括呢，所以可以认为有：
 G全局可执行队列(以下也可能简称G可执行队列) M可用队列  调度器要做的事就是：
 从G的可执行队列取G并从M的可用队列取M，将二者绑定开始执行G 对于已经执行完的G，销毁G并立即将M释放回M可用队列供后续使用   那么GM模型有哪些问题呢？
 (重点问题)单一的全局mutex(sched.lock)和集中状态管理  mutex需要保护所有与全局goroutine队列相关操作(创建、完成、重排等等)，竞争严重   (重点问题)per-M内存(M.mcache)问题  每个M都需要一个mcache，会导致资源消耗过大(每个mcache可以吸纳到2MB的内存缓存和其他缓存)  举个栗子，一个陷入syscall的M并不需要使用cache，但是在全部的M中，陷入系统调用的M与执行goroutine的M的比例可能是N:1(N&gt;&gt;1)，这就导致了N/(N&#43;1)比例的mcache在闲置   数据局部性差:  举个栗子，M1执行G1，此时创建了G2，G2通常是立刻进入了G全局可执行队列，而此时M1还在执行G1，所以G2通常被其他M执行，但是G1和G2通常强相关，所以G2最好也在M1上执行，因为G2对M1的缓存命中率更高     goroutine传递问题  goroutine(G)交接(G.nextg)，M之间会经常交接可运行的G 再通俗点说，就是G空转，本来能够好好在一个M上执行完，但是由于全局队列的存在，G一旦回全局队列了，下次就不知道被哪个M取走了，所以叫“空转”；M加载G的上下文是有开销的，所以空转会导致性能下降   频繁的线程阻塞/解阻塞  syscalls情况下，线程经常被阻塞和解阻塞，增加了很多额外开销 通俗点说，M&#43;G syscall，M阻塞，syscall完成后，M解阻塞继续执行G（如果是通过M数量控制并发度，这是不是就导致了并发度降低？）    GMP 基于以上说的GM的问题，go1.1以后开始使用GMP调度模型。 G、M、P的定义如下(***/src/runtime/runtime2.go)。
type g struct { // Stack parameters. // stack describes the actual stack memory: [stack."/>







<script src="/vendor/js/jquery.min.js" ></script>
<script src="/vendor/js/popper.min.js" ></script>
<script src="/vendor/js/bootstrap.min.js" ></script>
<script src="/vendor/js/smooth-scroll.polyfills.min.js" ></script>
<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>


  






<link rel="stylesheet" href="https://tianqizhang93.github.io/scss/journal.min.5e8f3f653e9f6ce67bf72ff8ee6fee69decf7b5639a3ae7f8344750ad4e065b1.css" integrity="sha256-Xo8/ZT6fbOZ79y/47m/uad7Pe1Y5o65/g0R1CtTgZbE=" media="screen">



<link rel="stylesheet" href="https://tianqizhang93.github.io/scss/dark-mode.min.bdfa63b2e89903517dcbb1032b537d54cff3f425c19d008a78dfe49e6cd07ced.css" integrity="sha256-vfpjsuiZA1F9y7EDK1N9VM/z9CXBnQCKeN/knmzQfO0=" media="screen">


<script src="/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");
</script>




  
    <script src="/js/toc-collapse.js"></script>
  



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/vendor/js/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
  clientID: '639d751c6c921e5529a0',
  clientSecret: '50b656593456becbb7f009b1f3a2271dcf55ce79',
  repo: 'tianqizhang93.github.io',
  owner: 'TianqiZhang93',
  admin: ['TianqiZhang93'],
  id: md5(location.pathname),
  distractionFreeMode: 'false'
  });
  window.onload = function () {
        gitalk.render('gitalk-container')
  }
</script>










</head>
<body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://tianqizhang93.github.io/">
    
        <div class="nav-title">
            Home Page
        </div>
        
        <div class="nav-subtitle">
            ZTQ&#39;s Space.
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/posts">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/about">
                About
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Songti SC'; color: #000000; -webkit-text-stroke: #000000}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #0000e3}
    span.s3 {font: 12.0px Times; font-kerning: none}
  </style>
</head>
<body>
<p class="p1"><span class="s1">Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary"><span class="s2">Diary</span></a> by <a href="https://amazingrise.net/"><span class="s2">Rise</span></a></span><span class="s2">.</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1">学艺不精, 委屈您的眼睛了</span><span class="s3"><br>
</span></p>
<p class="p1"><span class="s1">©  ztq. </span></p>
</body>
</html>

    </div>
    
</div><div ref="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2" onclick="onNavClick(`#写在前面-nav`)" id="写在前面-nav">
									写在前面
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#gm" onclick="onNavClick(`#gm-nav`)" id="gm-nav">
									GM
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#gmp" onclick="onNavClick(`#gmp-nav`)" id="gmp-nav">
									GMP
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#gmp%e6%a8%a1%e5%9e%8b%e7%9a%84%e4%b8%80%e4%ba%9b%e6%a6%82%e5%bf%b5" onclick="onNavClick(`#gmp模型的一些概念-nav`)" id="gmp模型的一些概念-nav">
									GMP模型的一些概念
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e7%8a%b6%e6%80%81%e6%b1%87%e6%80%bb" onclick="onNavClick(`#状态汇总-nav`)" id="状态汇总-nav">
									状态汇总
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%85%b3%e4%ba%8ep%e5%92%8cm%e7%9a%84%e5%88%9b%e5%bb%ba%e6%97%b6%e9%97%b4" onclick="onNavClick(`#关于p和m的创建时间-nav`)" id="关于p和m的创建时间-nav">
									关于P和M的创建时间
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e8%b0%83%e5%ba%a6%e5%9b%be%e8%a7%a3" onclick="onNavClick(`#调度图解-nav`)" id="调度图解-nav">
									调度图解
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" onclick="onNavClick(`#执行过程-nav`)" id="执行过程-nav">
									执行过程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e8%b0%83%e5%ba%a6%e5%9c%ba%e6%99%af" onclick="onNavClick(`#调度场景-nav`)" id="调度场景-nav">
									调度场景
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#gm---gmp" onclick="onNavClick(`#gm---gmp-nav`)" id="gm---gmp-nav">
									GM -&gt; GMP
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8gmp%e5%8f%96%e4%bb%a3gm" onclick="onNavClick(`#为什么使用gmp取代gm-nav`)" id="为什么使用gmp取代gm-nav">
									为什么使用GMP取代GM
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#gmp%e6%95%b0%e9%87%8f" onclick="onNavClick(`#gmp数量-nav`)" id="gmp数量-nav">
									G、M、P数量
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%8f%82%e8%80%83%e6%9d%90%e6%96%99" onclick="onNavClick(`#参考材料-nav`)" id="参考材料-nav">
									参考材料
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a class="pagination-action" v-on:click="toggleDarkMode">
            <i class="material-icons pagination-action-icon" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons pagination-action-icon" v-else="isDarkMode">
                brightness_7
            </i>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/posts">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/about">
                    About
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2" onclick="onNavClick(`#写在前面-nav`)" id="写在前面-nav">
									写在前面
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#gm" onclick="onNavClick(`#gm-nav`)" id="gm-nav">
									GM
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#gmp" onclick="onNavClick(`#gmp-nav`)" id="gmp-nav">
									GMP
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#gmp%e6%a8%a1%e5%9e%8b%e7%9a%84%e4%b8%80%e4%ba%9b%e6%a6%82%e5%bf%b5" onclick="onNavClick(`#gmp模型的一些概念-nav`)" id="gmp模型的一些概念-nav">
									GMP模型的一些概念
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e7%8a%b6%e6%80%81%e6%b1%87%e6%80%bb" onclick="onNavClick(`#状态汇总-nav`)" id="状态汇总-nav">
									状态汇总
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%85%b3%e4%ba%8ep%e5%92%8cm%e7%9a%84%e5%88%9b%e5%bb%ba%e6%97%b6%e9%97%b4" onclick="onNavClick(`#关于p和m的创建时间-nav`)" id="关于p和m的创建时间-nav">
									关于P和M的创建时间
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e8%b0%83%e5%ba%a6%e5%9b%be%e8%a7%a3" onclick="onNavClick(`#调度图解-nav`)" id="调度图解-nav">
									调度图解
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" onclick="onNavClick(`#执行过程-nav`)" id="执行过程-nav">
									执行过程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e8%b0%83%e5%ba%a6%e5%9c%ba%e6%99%af" onclick="onNavClick(`#调度场景-nav`)" id="调度场景-nav">
									调度场景
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#gm---gmp" onclick="onNavClick(`#gm---gmp-nav`)" id="gm---gmp-nav">
									GM -&gt; GMP
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8gmp%e5%8f%96%e4%bb%a3gm" onclick="onNavClick(`#为什么使用gmp取代gm-nav`)" id="为什么使用gmp取代gm-nav">
									为什么使用GMP取代GM
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#gmp%e6%95%b0%e9%87%8f" onclick="onNavClick(`#gmp数量-nav`)" id="gmp数量-nav">
									G、M、P数量
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%8f%82%e8%80%83%e6%9d%90%e6%96%99" onclick="onNavClick(`#参考材料-nav`)" id="参考材料-nav">
									参考材料
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="https://tianqizhang93.github.io/">
            Home Page
        </a>
        
        <button type="button" class="nav-darkmode-toggle" v-on:click="toggleDarkMode">
            <i class="material-icons" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons" v-else="isDarkMode">
                brightness_7
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://tianqizhang93.github.io/">
        <div class="single-column-header-title">Home Page</div>
        
        <div class="single-column-header-subtitle">ZTQ&#39;s Space.</div>
        

    </a>
</div>

            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                
            >
                <div class="post-title">
                    Golang schedule
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2021-08-21 22:27
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/cs">CS</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/language">Language</a>
                                &nbsp;
                            
                                <a href="/tags/golang">Golang</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <h2 id="写在前面">写在前面</h2>
<p>如果哪里写错辣了您的眼睛，请务必评论区批评指正，感激不尽。</p>
<p>留了一些TODO。</p>
<p>runtime包实现了所有<code>goroutine scheduler</code>、<code>memory allocator</code>、<code>garbage collector</code>细节，理论上可以从runtime包获取一切信息，没有直接怼源码，而是站在巨人的肩膀上（直接吃大佬们吃剩下的），看大家的各种说法，整理一下。</p>
<p>搜集到的材料，大家都是基于不同的go版本做的分析，而go版本迭代调度算法也在持续更新，所以整理的可能有些乱。但是可以保证的是，所有材料都是GM-&gt;GMP演化后的材料。</p>
<h2 id="gm">GM</h2>
<p>go1.1版本以前，调度使用GM模型，如下图所示。简单的理解GM模型，就是有一个始终执行的调度函数schedule不停的执行调度计算，当某个M的G执行完成了，调度器就把这个M放回M队列，可绑定执行其他G（如果某个M+G发生了syscall，那么本来并发度是通过M数量控制的，此时并发度就降低了？）；如果G执行过程中创建新的G，会将新的G放入到G全局可执行队列中。G全局可执行队列的操作有一把全局锁，这导致了各个M对G全局队列的操作存在严重的竞争。</p>
<p>下面这段完全是我的臆测，请别太相信：</p>
<hr>
<p>简单概括呢，所以可以认为有：</p>
<ul>
<li>G全局可执行队列(以下也可能简称G可执行队列)</li>
<li>M可用队列</li>
</ul>
<p>调度器要做的事就是：</p>
<ul>
<li>从G的可执行队列取G并从M的可用队列取M，将二者绑定开始执行G</li>
<li>对于已经执行完的G，销毁G并立即将M释放回M可用队列供后续使用</li>
</ul>
<hr>
<p><img src="/images/Golang-schedule/gm.png" alt="GM-model"></p>
<p>那么GM模型有哪些问题呢？</p>
<ul>
<li>(<strong>重点问题</strong>)单一的全局mutex(sched.lock)和集中状态管理
<ul>
<li>mutex需要保护所有与全局goroutine队列相关操作(创建、完成、重排等等)，竞争严重</li>
</ul>
</li>
<li>(<strong>重点问题</strong>)per-M内存(M.mcache)问题
<ul>
<li>每个M都需要一个mcache，会导致资源消耗过大(每个mcache可以吸纳到2MB的内存缓存和其他缓存)
<ul>
<li>举个栗子，一个陷入syscall的M并不需要使用cache，但是在全部的M中，陷入系统调用的M与执行goroutine的M的比例可能是<code>N:1(N&gt;&gt;1)</code>，这就导致了<code>N/(N+1)</code>比例的mcache在闲置</li>
</ul>
</li>
<li><strong>数据局部性差</strong>:
<ul>
<li>举个栗子，M1执行G1，此时创建了G2，G2通常是立刻进入了G全局可执行队列，而此时M1还在执行G1，所以G2通常被其他M执行，但是G1和G2通常强相关，所以G2最好也在M1上执行，因为G2对M1的缓存命中率更高</li>
</ul>
</li>
</ul>
</li>
<li>goroutine传递问题
<ul>
<li>goroutine(G)交接(G.nextg)，M之间会经常交接可运行的G</li>
<li>再通俗点说，就是G空转，本来能够好好在一个M上执行完，但是由于全局队列的存在，G一旦回全局队列了，下次就不知道被哪个M取走了，所以叫“空转”；M加载G的上下文是有开销的，所以空转会导致性能下降</li>
</ul>
</li>
<li>频繁的线程阻塞/解阻塞
<ul>
<li>syscalls情况下，线程经常被阻塞和解阻塞，增加了很多额外开销</li>
<li>通俗点说，M+G syscall，M阻塞，syscall完成后，M解阻塞继续执行G（如果是通过M数量控制并发度，这是不是就导致了并发度降低？）</li>
</ul>
</li>
</ul>
<h2 id="gmp">GMP</h2>
<p>基于以上说的GM的问题，go1.1以后开始使用GMP调度模型。
G、M、P的定义如下(***/src/runtime/runtime2.go)。</p>
<pre><code>type g struct {
	// Stack parameters.
	// stack describes the actual stack memory: [stack.lo, stack.hi).
	// stackguard0 is the stack pointer compared in the Go stack growth prologue.
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
	// stackguard1 is the stack pointer compared in the C stack growth prologue.
	// It is stack.lo+StackGuard on g0 and gsignal stacks.
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
	stack       stack   // offset known to runtime/cgo
	stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink

	_panic       *_panic // innermost panic - offset known to liblink
	_defer       *_defer // innermost defer
	m            *m      // current m; offset known to arm liblink
	sched        gobuf
	syscallsp    uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc
	syscallpc    uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc
	stktopsp     uintptr        // expected sp at top of stack, to check in traceback
	param        unsafe.Pointer // passed parameter on wakeup
	atomicstatus uint32
	stackLock    uint32 // sigprof/scang lock; TODO: fold in to atomicstatus
	goid         int64
	schedlink    guintptr
	waitsince    int64      // approx time when the g become blocked
	waitreason   waitReason // if status==Gwaiting

	preempt       bool // preemption signal, duplicates stackguard0 = stackpreempt
	preemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule
	preemptShrink bool // shrink stack at synchronous safe point

	// asyncSafePoint is set if g is stopped at an asynchronous
	// safe point. This means there are frames on the stack
	// without precise pointer information.
	asyncSafePoint bool

	paniconfault bool // panic (instead of crash) on unexpected fault address
	gcscandone   bool // g has scanned stack; protected by _Gscan bit in status
	throwsplit   bool // must not split stack
	// activeStackChans indicates that there are unlocked channels
	// pointing into this goroutine's stack. If true, stack
	// copying needs to acquire channel locks to protect these
	// areas of the stack.
	activeStackChans bool
	// parkingOnChan indicates that the goroutine is about to
	// park on a chansend or chanrecv. Used to signal an unsafe point
	// for stack shrinking. It's a boolean value, but is updated atomically.
	parkingOnChan uint8

	raceignore     int8     // ignore race detection events
	sysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine
	sysexitticks   int64    // cputicks when syscall has returned (for tracing)
	traceseq       uint64   // trace event sequencer
	tracelastp     puintptr // last P emitted an event for this goroutine
	lockedm        muintptr
	sig            uint32
	writebuf       []byte
	sigcode0       uintptr
	sigcode1       uintptr
	sigpc          uintptr
	gopc           uintptr         // pc of go statement that created this goroutine
	ancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
	startpc        uintptr         // pc of goroutine function
	racectx        uintptr
	waiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order
	cgoCtxt        []uintptr      // cgo traceback context
	labels         unsafe.Pointer // profiler labels
	timer          *timer         // cached timer for time.Sleep
	selectDone     uint32         // are we participating in a select and did someone win the race?

	// Per-G GC state

	// gcAssistBytes is this G's GC assist credit in terms of
	// bytes allocated. If this is positive, then the G has credit
	// to allocate gcAssistBytes bytes without assisting. If this
	// is negative, then the G must correct this by performing
	// scan work. We track this in bytes to make it fast to update
	// and check for debt in the malloc hot path. The assist ratio
	// determines how this corresponds to scan work debt.
	gcAssistBytes int64
}

type m struct {
	g0      *g     // goroutine with scheduling stack
	morebuf gobuf  // gobuf arg to morestack
	divmod  uint32 // div/mod denominator for arm - known to liblink

	// Fields not known to debuggers.
	procid        uint64       // for debuggers, but offset not hard-coded
	gsignal       *g           // signal-handling g
	goSigStack    gsignalStack // Go-allocated signal handling stack
	sigmask       sigset       // storage for saved signal mask
	tls           [6]uintptr   // thread-local storage (for x86 extern register)
	mstartfn      func()
	curg          *g       // current running goroutine
	caughtsig     guintptr // goroutine running during fatal signal
	p             puintptr // attached p for executing go code (nil if not executing go code)
	nextp         puintptr
	oldp          puintptr // the p that was attached before executing a syscall
	id            int64
	mallocing     int32
	throwing      int32
	preemptoff    string // if != &quot;&quot;, keep curg running on this m
	locks         int32
	dying         int32
	profilehz     int32
	spinning      bool // m is out of work and is actively looking for work
	blocked       bool // m is blocked on a note
	newSigstack   bool // minit on C thread called sigaltstack
	printlock     int8
	incgo         bool   // m is executing a cgo call
	freeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)
	fastrand      [2]uint32
	needextram    bool
	traceback     uint8
	ncgocall      uint64      // number of cgo calls in total
	ncgo          int32       // number of cgo calls currently in progress
	cgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily
	cgoCallers    *cgoCallers // cgo traceback if crashing in cgo call
	park          note
	alllink       *m // on allm
	schedlink     muintptr
	lockedg       guintptr
	createstack   [32]uintptr // stack that created this thread.
	lockedExt     uint32      // tracking for external LockOSThread
	lockedInt     uint32      // tracking for internal lockOSThread
	nextwaitm     muintptr    // next m waiting for lock
	waitunlockf   func(*g, unsafe.Pointer) bool
	waitlock      unsafe.Pointer
	waittraceev   byte
	waittraceskip int
	startingtrace bool
	syscalltick   uint32
	freelink      *m // on sched.freem

	// these are here because they are too large to be on the stack
	// of low-level NOSPLIT functions.
	libcall   libcall
	libcallpc uintptr // for cpu profiler
	libcallsp uintptr
	libcallg  guintptr
	syscall   libcall // stores syscall parameters on windows

	vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)
	vdsoPC uintptr // PC for traceback while in VDSO call

	// preemptGen counts the number of completed preemption
	// signals. This is used to detect when a preemption is
	// requested, but fails. Accessed atomically.
	preemptGen uint32

	// Whether this is a pending preemption signal on this M.
	// Accessed atomically.
	signalPending uint32

	dlogPerM

	mOS

	// Up to 10 locks held by this m, maintained by the lock ranking code.
	locksHeldLen int
	locksHeld    [10]heldLockInfo
}

type p struct {
	id          int32
	status      uint32 // one of pidle/prunning/...
	link        puintptr
	schedtick   uint32     // incremented on every scheduler call
	syscalltick uint32     // incremented on every system call
	sysmontick  sysmontick // last tick observed by sysmon
	m           muintptr   // back-link to associated m (nil if idle)
	mcache      *mcache
	pcache      pageCache
	raceprocctx uintptr

	deferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)
	deferpoolbuf [5][32]*_defer

	// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
	goidcache    uint64
	goidcacheend uint64

	// Queue of runnable goroutines. Accessed without lock.
	runqhead uint32
	runqtail uint32
	runq     [256]guintptr
	// runnext, if non-nil, is a runnable G that was ready'd by
	// the current G and should be run next instead of what's in
	// runq if there's time remaining in the running G's time
	// slice. It will inherit the time left in the current time
	// slice. If a set of goroutines is locked in a
	// communicate-and-wait pattern, this schedules that set as a
	// unit and eliminates the (potentially large) scheduling
	// latency that otherwise arises from adding the ready'd
	// goroutines to the end of the run queue.
	runnext guintptr

	// Available G's (status == Gdead)
	gFree struct {
		gList
		n int32
	}

	sudogcache []*sudog
	sudogbuf   [128]*sudog

	// Cache of mspan objects from the heap.
	mspancache struct {
		// We need an explicit length here because this field is used
		// in allocation codepaths where write barriers are not allowed,
		// and eliminating the write barrier/keeping it eliminated from
		// slice updates is tricky, moreso than just managing the length
		// ourselves.
		len int
		buf [128]*mspan
	}

	tracebuf traceBufPtr

	// traceSweep indicates the sweep events should be traced.
	// This is used to defer the sweep start event until a span
	// has actually been swept.
	traceSweep bool
	// traceSwept and traceReclaimed track the number of bytes
	// swept and reclaimed by sweeping in the current sweep loop.
	traceSwept, traceReclaimed uintptr

	palloc persistentAlloc // per-P to avoid mutex

	_ uint32 // Alignment for atomic fields below

	// The when field of the first entry on the timer heap.
	// This is updated using atomic functions.
	// This is 0 if the timer heap is empty.
	timer0When uint64

	// Per-P GC state
	gcAssistTime         int64    // Nanoseconds in assistAlloc
	gcFractionalMarkTime int64    // Nanoseconds in fractional mark worker (atomic)
	gcBgMarkWorker       guintptr // (atomic)
	gcMarkWorkerMode     gcMarkWorkerMode

	// gcMarkWorkerStartTime is the nanotime() at which this mark
	// worker started.
	gcMarkWorkerStartTime int64

	// gcw is this P's GC work buffer cache. The work buffer is
	// filled by write barriers, drained by mutator assists, and
	// disposed on certain GC state transitions.
	gcw gcWork

	// wbBuf is this P's GC write barrier buffer.
	//
	// TODO: Consider caching this in the running G.
	wbBuf wbBuf

	runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point

	// Lock for timers. We normally access the timers while running
	// on this P, but the scheduler can also do it from a different P.
	timersLock mutex

	// Actions to take at some time. This is used to implement the
	// standard library's time package.
	// Must hold timersLock to access.
	timers []*timer

	// Number of timers in P's heap.
	// Modified using atomic instructions.
	numTimers uint32

	// Number of timerModifiedEarlier timers on P's heap.
	// This should only be modified while holding timersLock,
	// or while the timer status is in a transient state
	// such as timerModifying.
	adjustTimers uint32

	// Number of timerDeleted timers in P's heap.
	// Modified using atomic instructions.
	deletedTimers uint32

	// Race context used while executing timer functions.
	timerRaceCtx uintptr

	// preempt is set to indicate that this P should be enter the
	// scheduler ASAP (regardless of what G is running on it).
	preempt bool

	pad cpu.CacheLinePad
}
</code></pre><h3 id="gmp模型的一些概念">GMP模型的一些概念</h3>
<p>上面M中有两个g需要关注下，curg和g0。
curg就是M当前绑定的G。
g0是带有调度栈的goroutine，普通的G的栈是分配在堆上的可增长的栈，而g0的栈是M对应的线程的栈。所有调度相关的代码，会先切换到该goroutine的栈中执行。即，线程的栈也是用的g实现，而不是使用的OS。</p>
<p>反正上述定义我是没有逐个字段的去理解，还是靠嘴说吧：</p>
<ul>
<li>G(Goroutine): goroutine，<code>go func(){...}</code>创建的
<ul>
<li>G会保存他关联的M</li>
<li>G会保存全局队列中下一个G(按链表理解)</li>
<li>G默认栈2KB</li>
<li>G保存上下文，现场保护&amp;现场恢复的寄存器</li>
</ul>
</li>
<li>M(Machine): 抽象化代表内核线程
<ul>
<li>M保存了自身的栈信息，当前M上执行的G信息，以及绑定的P信息</li>
<li>M有线程栈，若没有为M的线程栈提供内存，则操作系统会为M提供内存</li>
<li>当指定线程栈，则<code>M.stack-&gt;G.stack</code>，M的PC寄存器指向G提供的函数，然后开始执行</li>
</ul>
</li>
<li>P(Processor): 处理器，一般P的数量默认为机器逻辑核数(go早期版本默认值1)，可以通过GOMAXPROCS修改，P的数量其实就是并发量
<ul>
<li>P负责调度goroutines，per-P维护一个本地goroutine队列，M从P获取goroutine并执行</li>
<li>per-P维护一个本地mcache
<ul>
<li>TODO：这个点怎么理解？</li>
</ul>
</li>
<li>综上呢，P是M执行所需要的上下文环境，是处理用户级代码逻辑的处理器，也可以看作是一个局部调度器，使go代码跑在线程上</li>
</ul>
</li>
</ul>
<p>再说几个相关概念：</p>
<ul>
<li>P列表：就是GOMAXPROCS这么多个P的列表</li>
<li>M列表：就是操作系统分配到当前go进程的内核线程数，可以通过runtime/debug包SetMaxThreads设置(一般比P多，但别超过10000个，如下)
<pre><code>file: ***/src/runtime/proc.go
-----------------------------
  func schedinit() {
        ...
       sched.maxmcount = 10000
       ...
  }
</code></pre></li>
<li>空闲P链表：当P的本地运行队列中的所有G都运行完毕, 又不能从其他地方拿到G时,拥有P的M会释放P并进入休眠状态, 释放的P会变为空闲状态并加到空闲P链表中, 空闲P链表保存在全局变量sched；下次待运行的G入队时如果发现有空闲的P, 但是又没有自旋中的M时会唤醒或者新建一个M, M会拥有这个P, P会重新变为运行中的状态
<ul>
<li>关于创建M，可以看下面的概念“保证有足够的M运行G”</li>
</ul>
</li>
<li>空闲M链表：当M发现无待运行的G时会进入休眠, 并添加到空闲M链表中, 空闲M链表保存在全局变量sched；进入休眠的M会等待一个信号量(m.park), 唤醒休眠的M会使用这个信号量</li>
<li>P本地队列：P维护runq_，存放等待执行的goroutines，P本地队列是lock-free的，无竞争问题
<ul>
<li>M执行从P上获取的G时，如果创建了新的G，优先放在P的本地队列，如果P的本地队列满了，才放在全局队列
<ul>
<li>TODO：关于“如果P的本地队列满了，才放在全局队列”这句话，描述并不精确。真正的动作应该(个人臆测，需要看源码)是P将本地队列一半移动到全局队列(这个移动本地一半的动作不是臆测的)，而且应该是&quot;FIFO&quot;，将较早创建的一些G移动走，这个新建的G应该是放在了本地。首先来看本地队列和全局队列的关系，全局队列应该是一个大的缓冲池，均衡各个P的负载，同时，看起来还有一个作用，就是提高P缓存的命中率，全局队列应该是存储一些“冷G”，而各个P的本地应该是存储一些“热G”，所以本着这个原则，新建的应该尽量留在本地</li>
</ul>
</li>
<li>本地队列容量: 256个</li>
</ul>
</li>
<li>全局队列：全局的等待执行的goroutines队列
<ul>
<li>TODO：全局队列容量大小？</li>
</ul>
</li>
<li>TODO：应该还有另一个全局的G队列，存放channel blocked goroutines，且也具备全局锁，下图有体现</li>
<li>M获取G：
<ul>
<li>首先从M关联的P的本地队列获取</li>
<li>若P本地队列空，则从全局队列获取</li>
<li>若全局队列也空，则<strong>从其他P的本地队列获取一部分任务放到关联P的本地队列(GMP的一个关键概念: work stealing，通常是偷来一半)</strong></li>
</ul>
</li>
<li>抢占式调度：当有很多goroutine需要执行的时候，P还未创建，在runtime.main中会创建一个额外m运行sysmon函数实现抢占。sysmon会进入一个无限循环, 第一轮休眠20us, 之后每次休眠时间倍增, 最终每一轮都会休眠10ms。 sysmon中有netpool(获取fd事件), retake(抢占), forcegc(按时间强制执行gc), scavenge heap(释放自由列表中多余的项减少内存占用)等处理</li>
<li>保证有足够的M运行G：
<ul>
<li>入队待运行的G后, 如果当前无自旋的M但是有空闲的P, 就唤醒或者新建一个M</li>
<li>当M离开自旋状态并准备运行出队的G时, 如果当前无自旋的M但是有空闲的P, 就唤醒或者新建一个M</li>
<li>当M离开自旋状态并准备休眠时, 会在离开自旋状态后再次检查所有运行队列, 如果有待运行的G则重新进入自旋状态</li>
<li>因为&quot;入队待运行的G&quot;和&quot;M离开自旋状态&quot;会同时进行, go会使用这样的检查顺序:<code>入队待运行的G =&gt; 内存屏障 =&gt; 检查当前自旋的M数量 =&gt; 唤醒或者新建一个M减少当前自旋的M数量 =&gt; 内存屏障 =&gt; 检查所有运行队列是否有待运行的G =&gt; 休眠</code>，这样可以保证不会出现待运行的G入队了, 也有空闲的资源P, 但无M去执行的情况</li>
</ul>
</li>
</ul>
<h3 id="状态汇总">状态汇总</h3>
<ul>
<li>G
<ul>
<li>_Gidle：刚刚被分配并且还没有被初始化，值为0，为创建goroutine后的默认值</li>
<li>_Grunnable： 没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个P的本地队列或全局队列中</li>
<li>_Grunning： 正在执行代码的goroutine，拥有栈的所有权</li>
<li>_Gsyscall：正在执行系统调用，拥有栈的所有权，与P脱离，但是与某个M绑定，会在调用结束后被分配到运行队列</li>
<li>_Gwaiting：被阻塞的goroutine，阻塞在某个channel的发送或者接收队列</li>
<li>_Gdead： 当前goroutine未被使用，没有执行代码，可能有分配的栈，分布在空闲列表gFree，可能是一个刚刚初始化的goroutine，也可能是执行了goexit退出的goroutine</li>
<li>_Gcopystac：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在</li>
<li>_Gscan ： GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</li>
</ul>
</li>
<li>P
<ul>
<li>_Pidle ：处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</li>
<li>_Prunning ：被线程 M 持有，并且正在执行用户代码或者调度器</li>
<li>_Psyscall：没有执行用户代码，当前线程陷入系统调用</li>
<li>_Pgcstop ：被线程 M 持有，当前处理器由于垃圾回收被停止</li>
<li>_Pdead ：当前处理器已经不被使用</li>
</ul>
</li>
<li>M
<ul>
<li>自旋线程：处于运行状态但是没有可执行goroutine的线程，数量最多为GOMAXPROC，若是数量大于GOMAXPROC就会进入休眠
<ul>
<li>通俗点说，空闲的M最多跟P的数量一样多，这样任何P已绑定的M陷入syscall都能迅速获得新的空闲M，减少M重新分配带来的开销，但空闲M又不能过多，否则导致内核线程浪费</li>
</ul>
</li>
<li>非自旋线程：处于运行状态有可执行goroutine的线程</li>
<li>休眠
<ul>
<li>TODO：休眠我理解应该是不自旋但是还没被回收的这个状态？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于p和m的创建时间">关于P和M的创建时间</h3>
<p>P一般在程序一开始，runtime确认了GOMAXPROCS后，就创建了相应的P。</p>
<p>但是对于M，是按需创建的，比如P绑定的M阻塞了，且此时没有休眠的M或自旋的M，就会向内核申请新的M，M最多10000个，但是其实内核一般也不允许创建这么多线程，还是会收到内核的限制。</p>
<p>有一个特殊的M在P创建之前就创建了，那就是运行sysmon的M。</p>
<h3 id="调度图解">调度图解</h3>
<p>下图来自Gao Chao的PPT <a href="https://speakerdeck.com/retervision/go-runtime-scheduler?slide=14">go-runtime-scheduler</a> ：</p>
<p><img src="/images/Golang-schedule/gmp-sched.png" alt="gmp-sched">
我们来画一张通俗易懂的图：
<img src="/images/Golang-schedule/gmp.png" alt="gmp"></p>
<p>如上图，GOMAXPROCS=3，有三个P，每个P分别绑定了一个M；P1的本地队列满，P2的本地队列空，P3本地队列不满不空；M队列目前有5个M，除了与P绑定的执行go代码的M，M4陷入syscall，M5空闲，M4完成任务后将自旋（自旋M不超过GOMAXPROCS），若此时M1、M2、M3中的某一个阻塞，则M4与P绑定开始执行用户逻辑；若无空闲or睡眠M，M1、M2、M3中的某一个阻塞，则将创建新的M6绑定对应P执行用户逻辑。</p>
<p>关于G、M的状态流转：</p>
<ul>
<li>图中（1）：此时P3本地队列不满不空，新创建的goroutine优先加入本地队列</li>
<li>图中（2）：此时P1本地队列满，新创建的goroutine将加入到全局队列
<ul>
<li>PS：关于这个动作，上面“P本地队列”概念中有提出疑问</li>
</ul>
</li>
<li>图中（3）：P2本地队列空，无G可执行，将从全局队列获取G
<ul>
<li>TODO：会一次获取多少过来呢？本地容量的一半吗？</li>
</ul>
</li>
<li>图中（4）：该图未体现，假设全局队列也空，则将执行work stealing，P2从其他P的本地队列“偷”一部分G过来
<ul>
<li>TODO：一般偷一半，怎么选择跟哪个P偷呢，负载最高的一个吗？</li>
</ul>
</li>
<li>图中（5）：若P3+M3执行G31时，G31发生channel阻塞，则G31将脱离P3+M3，P3将调度新的G到M3执行</li>
<li>图中（6）：若P1+M1执行G11时，发生syscall，则M1和G11该将脱离P1，执行syscall
<ul>
<li>P1此时寻找到空闲的M5并绑定，继续执行P1的本地队列；若无空闲M，需要创建or唤醒</li>
<li>M1+G11执行完syscall后，若P1仍未找到M(仍然为_Psyscall状态)，则M1继续绑定P1，否则M1自旋or休眠or被回收</li>
</ul>
</li>
</ul>
<h3 id="执行过程">执行过程</h3>
<ul>
<li><code>go func(){}</code>创建G，优先存P本地队列，否则存全局队列(再墨迹一次这个疑问上面提过)</li>
<li>P唤醒一个M，M从P的runq_弹出一个G，如果P本地队列空，从全局队列获取(此时应该会从全局队列加载一些G到P的本地队列)，如果全局队列也空，就去其他P偷取G放到自己的P的本地队列</li>
<li>M开始执行
<ul>
<li>若发生系统调用导致M阻塞，当前P本地队列还有其他G，则runtime会将M&amp;P分离，然后再获取一个M(空闲/唤醒/新建)与P绑定；阻塞调用完成后，M会去找刚才的P，如果刚才的P没有绑定其他M，则与之绑定，否则 自旋/睡眠/被回收</li>
<li>若由于channel阻塞当前G，该G会脱离当前的M和P，P会调度其他的G分配给M执行
<ul>
<li>TODO：阻塞完成后，G直接进全局队列还是优先刚才的P本地队列？</li>
</ul>
</li>
</ul>
</li>
<li>销毁G，返回执行结果，M寻找新的G执行</li>
</ul>
<p>M的执行过程简单概括就是：调用G对象-&gt;执行-&gt;清理线程→继续找新的G执行。
M执行过程中，随时会发生上下文切换。当发生上下文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go调度器M的栈保存在G对象上，只需要将M所需要的寄存器(SP、PC等)保存到G对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时G任务还没有执行完，M可以将任务重新丢到P的任务队列，等待下一次被调度执行。当再次被调度执行时，M通过访问G的vdsoSP、vdsoPC寄存器进行现场恢复(从上次中断位置继续执行)。</p>
<h3 id="调度场景">调度场景</h3>
<ul>
<li>Channel阻塞：当goroutine读写channel发生阻塞时候，会调用gopark函数，该G会脱离当前的M与P，调度器会执行schedule函数调度新的G到当前M</li>
<li>系统调用：当某个G、M由于系统调用陷入内核态时，该P就会脱离当前的M，此时P会更新自己的状态为Psyscall，M与G互相绑定，进行系统调用。结束以后若该P状态还是Psyscall，则直接关联该M和G，否则使用闲置的处理器处理该G
<ul>
<li>TODO：若无闲置的处理器，该G、M怎么处理？G优先回刚才的P，其次全局，M 自旋/休眠/被回收 ？</li>
</ul>
</li>
<li>系统监控：当某个G在P上运行的时间超过10ms，或者P处于Psyscall状态过长等情况就会调用retake函数，触发新的调度</li>
<li>主动让出：G运行时间过长，会主动让出当前的P，更新状态为Grunnable，该P会调度队列中的其他G运行
<ul>
<li>TODO：若本地队列空呢？</li>
</ul>
</li>
</ul>
<h2 id="gm---gmp">GM -&gt; GMP</h2>
<p>GM演化为GMP一定是在进步的。
之前我们说过，GM两个比较显著的问题</p>
<ul>
<li>一个是sched.lock全局队列锁
<ul>
<li>GMP per-P维护本地队列，减少了全局G队列的锁竞争</li>
</ul>
</li>
<li>一个是per-M本地缓存
<ul>
<li>GMP是per-P的mcache，避免了大量陷入系统调用M对内存的浪费</li>
</ul>
</li>
</ul>
<p>对于G空转的问题，GMP的per-P本地队列+workStealing模式，减少了G的空转，且新建G优先入P本地队列，提高缓存命中率。</p>
<p>此外，GMP还有&quot;hand off&quot;机制，当M1+P1执行G1时进入syscall，则P1与M1解绑(M1执行G1 syscall)，与空闲的M2(空闲的/新申请)绑定并继续工作，M1执行完G1后，进入空闲，后续将被其他P使用或被回收。</p>
<h3 id="为什么使用gmp取代gm">为什么使用GMP取代GM</h3>
<p>为什么GM演变到了GMP呢？</p>
<p>首先M是内核级线程，用户态无法进行调度和修改，借鉴GMP的思路，只能是M本地绑定一个队列。
那么为什么需要一个P层呢？</p>
<p>如果没有P层，每个M维护本地队列：</p>
<ul>
<li>由于M不停创建，本地队列数量同时增多，此时的&quot;work stealing&quot;将极其复杂，甚至可能导致调度性能严重下降</li>
<li>per-M内存问题并没有得到解决</li>
<li>每个M本地队列中其他G会由于M的syscall而被阻塞，若引入&quot;hand off&quot;机制，那么M数量将增长更快</li>
</ul>
<p>因此，引入P层，由P层维护本地队列，P数量代表并发度，per-P mcache缓存模式，这就完美的解决了上面说的问题(正所谓&quot;遇事不决加一层&quot;)。</p>
<h2 id="gmp数量">G、M、P数量</h2>
<p>G的数量理论上就是受内存的限制，一个G初始创建需2k的栈空间，后续根据需要会弹性连续增长，假设单机内存4G，那么理论上G数量上限约<code>2,000,000</code>，当然不可能内存全部给G，数量大概是这么个概念。</p>
<p>M的数量按照go默认值最高10000个，也可通过<code>debug.SetMaxThreads</code>来设置，但是其实还受到操作系统的限制，因为每一个M就对应操作系统的一个内核级线程。一个正常的go进程M数量一般比P多(hand off机制，空转M数量最大GOMAXPROCS，sysmon回收时间间隔 等机制导致)。</p>
<p>P的数量是通过<code>GOMAXPROCS</code>设置，一般使用单机逻辑核数，这是为了能够充分利用单机的多核并发，P的量也不是越多越好，P多了调度的开销也会增加，P的最佳数量一般通过大量的benchmark才能确定</p>
<ul>
<li>P数量不多，所以per-P缓存需要的空间不会成为P数量的瓶颈</li>
</ul>
<h2 id="参考材料">参考材料</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw">https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1683211">https://cloud.tencent.com/developer/article/1683211</a></li>
<li><a href="https://blog.csdn.net/diaosssss/article/details/92830782">https://blog.csdn.net/diaosssss/article/details/92830782</a></li>
<li>数据局部性: <a href="https://www.zhihu.com/question/25142664">https://www.zhihu.com/question/25142664</a></li>
</ul>

                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">Last modified on 2021-08-21</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="https://tianqizhang93.github.io/posts/cache-elimination-algorithm/">
			Next<br>缓存淘汰算法(TO BE DONE)
                </a>
                
                
                
                <a class="older-posts" href="https://tianqizhang93.github.io/posts/pruning/">
			Previous<br>剪枝(to be done)
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                


<div id="gitalk-container"></div>







        
            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer"><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Songti SC'; color: #000000; -webkit-text-stroke: #000000}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #0000e3}
    span.s3 {font: 12.0px Times; font-kerning: none}
  </style>
</head>
<body>
<p class="p1"><span class="s1">Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary"><span class="s2">Diary</span></a> by <a href="https://amazingrise.net/"><span class="s2">Rise</span></a></span><span class="s2">.</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1">学艺不精, 委屈您的眼睛了</span><span class="s3"><br>
</span></p>
<p class="p1"><span class="s1">©  ztq. </span></p>
</body>
</html>
</div>
            </div>
    <script>
let app;

app = new Vue({
    el: '#app',
    data: {
        scrollY: 0,
        navOpacity: 0,
        isDrawerOpen: false,
        mounted: false,
        isDarkMode: false
    },
    methods: {
            sgn(t, x) {
                let k = 1. / (1. - 2 * t);
                if (x <= t) return 0;
                else if (x >= 1 - t) return 1;
                else {
                    return k * (x - t);
                }
            },
            handleScroll() {
                this.scrollY = window.scrollY;
                this.navOpacity = this.sgn(.0, Math.min(1, Math.max(0, window.scrollY / (this.pageHeadHeight() - this.navBarHeight() * 0.8))));
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;

                if (this.navOpacity >= 1) {
                    navBackground.style.opacity = 1;
                    navTitle.style.opacity = 1;
                } else {
                    navBackground.style.opacity = 0;
                    navTitle.style.opacity = 0;
                }
            },
            handleResize() {
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;
                extraContainer.style.left = (streamContainer.offsetWidth - extraContainer.offsetWidth) + 'px';
            },
            navBarHeight() {
                return this.$refs.navBar.offsetHeight;
            },
            pageHeadHeight() {
                return this.$refs.pageHead.offsetHeight;
            },
            toggleDrawer() {
                this.isDrawerOpen = !this.isDrawerOpen;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            closeDrawer() {
                this.isDrawerOpen = false;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            toggleDarkMode() {
                this.isDarkMode = !this.isDarkMode;
                if (this.isDarkMode==true){
                    document.cookie = "night=1;path=/";
                    document.body.classList.add("night");
                } else {
                    document.cookie = "night=0;path=/";
                    document.body.classList.remove("night");
                }
            }
    },
    created() {
        window.addEventListener('scroll', this.handleScroll);
        window.addEventListener('resize', this.handleResize);
        window._nonDesktop = function () {
            let check = false;
            (function (a) {
                if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
            })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
        };
        
        var night = document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1");
        if (night==""){
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                
            }
        }else{
            
            if (night=="1") {
                this.toggleDarkMode();
            }
        }
    },
    mounted() {
        this.handleScroll();
        this.handleResize();
        this.mounted = true;

        
        
    },
    destroyed() {
        window.removeEventListener('scroll', this.handleScroll);
        window.removeEventListener('resize', this.handleResize);
    }
});
</script>

<script src="/js/journal.js"></script>

    </body>
</html>
