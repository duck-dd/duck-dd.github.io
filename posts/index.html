<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Duck</title><meta name=keywords content><meta name=description content="Posts - Duck"><meta name=author content><link rel=canonical href=https://duck-dd.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2a8ef18cccda149eb1cd8ec968ba463447d72022979e5c5cae43dcf5d7358750.css integrity="sha256-Ko7xjMzaFJ6xzY7JaLpGNEfXICKXnlxcrkPc9dc1h1A=" rel="preload stylesheet" as=style><link rel=icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://duck-dd.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://duck-dd.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><meta property="og:url" content="https://duck-dd.github.io/posts/"><meta property="og:site_name" content="Duck"><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://duck-dd.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://duck-dd.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://duck-dd.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://duck-dd.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://duck-dd.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://duck-dd.github.io/about_me title=关于我><span>关于我</span></a></li><li><a href=https://duck-dd.github.io/about_space title=关于这里><span>关于这里</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://duck-dd.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>越南</h2></header><div class=entry-content><p>今天简单了解一下越南。
名称：越南 越南社会主义共和国 Vietnam 语言：越南语 首都：河内(Ha Noi) 国土面积：33万平方公里 位置：中南半岛东部 气候：热带季风气候；高温多雨，北方分春、夏、秋、冬四季，南方雨旱两季分明 邻(近)国：北与中国接壤，西与老挝、柬埔寨交界，东和南 临南海 人口：1亿多一点 政治体制：一党制，越南共产党是越南唯一的政党 经济制度：社会主义定向的市场经济制度 社会制度：社会主义制度 货币：越南盾，简称越盾，货币代码VND，货币符号 “₫” GDP： 2024：11.511万亿越盾，约合4763亿美元 对比中国，2024 中国大陆名义GDP总量折合189433.42亿美元 立法：国会是越南的国家最高权力机关，也是全国唯一的立法机构 文化：越南文化融合了本土、中国影响、东南亚民族特色、殖民影响等因素；传统服饰：奥黛 宗教信仰：佛教、天主教、和好教、高台教 美食：以 “新鲜、清淡、均衡” 为核心，充满东南亚风情与中国饮食痕迹，使用筷子；“鲜 香 酸 辣”；河粉、春卷 国家内部 行政区域/地理区域 划分： 省/直辖市 —> 县/市社/郡 —> 社(农村)/市镇(介于农村和城市之间)/坊(城市) 全国划分为28个省和6个直辖市(河内市、胡志明市、海防市、岘港市、芹苴市和顺化市) 主要城市： 河内市：首都，越南政治、文化中心 胡志明市：旧称西贡，是越南的经济中心、全国最大的港口和交通枢纽，位于湄公河三角洲的东北侧、南临南中国海 海防：越南北部最大港口城市，位于红河三角洲东北端，京泰河下游，东临北部湾 岘港：位于越南中部，濒临南海，是全国重要的工业城市和海港 芹苴：在后江省南面，下辖4郡4县，是湄公河三角洲上最大的城市，是南部湄公河三角洲农产品集散地和轻工业基地 顺化：位于越南中部，是越南古都 下龙：广宁省省会，位于北部湾的西岸，濒临下龙湾，是越南著名的旅游城市和重要海港，也是越南乃至东南亚的煤都；其著名景点下龙湾有着“海上桂林”的美誉 历史进程简述： 红河三角洲地区早在新石器时代就有人类活动，公元前3世纪出现“瓯雒国”（传说由骆越部落建立），是越南最早的政权雏形 公元前214年，秦始皇征服岭南，越南北部纳入中国版图，此后历经两汉、三国、隋唐等朝代，设 “交趾”“安南都护府” 等行政机构 公元968年成为独立的封建国家，丁部领建立“丁朝”，定都华闾（今宁平省），正式脱离中国独立，称“大瞿越”，随后历经前黎朝、李朝、陈朝、胡朝、后黎朝等朝代 1858年，法国以传教士问题为借口，逐步占领越南 1887年，法国将越南与柬埔寨、老挝合并为 “法属印度支那联邦”，实行殖民统治，掠夺资源并推行西方化改革 1930年，越南民族主义觉醒，胡志明等革命者成立“越南共产党” 1940年，日本趁机占领越南，取代法国控制权，越南人民同时抗击法、日侵略 1945年，“八月革命”后，胡志明宣布成立“越南民主共和国”（北越）；但法国试图重建殖民统治，引发“抗法战争”（1946—1954年）。1954年“奠边府战役”北越获胜，《日内瓦协定》签订，越南以北纬17度线分为北越（社会主义）和南越（资本主义） 1955—1975年，南越在美国支持下成立政权，南北越矛盾激化。20世纪60年代，美国为遏制共产主义，逐步升级对越南的军事干预，发动“越南战争”（1961—1973年），美军最多投入50万兵力，战争造成巨大伤亡和破坏 1973年，美军撤军 1975年，北越军队攻占西贡（今胡志明市），南越政权覆灭 1976年，越南正式统一，定国名为 “越南社会主义共和国”，定都河内 1986年，越共六大推行 “革新开放” 政策，引入市场经济元素，吸引外资，发展出口加工产业，经济快速增长 额外说明：中国对越自卫反击战(苏联与越南签订军事同盟条约，试图通过越南牵制中国，形成对华战略包围圈) 作战阶段：1979年 边境轮战阶段：1980-1989 停战：1990越南主动寻求停战</p></div><footer class=entry-footer><span title='2025-08-19 00:00:00 +0000 UTC'>2025-08-19</span>&nbsp;·&nbsp;创建于:&nbsp;2025-08-19&nbsp;·&nbsp;1 min&nbsp;·&nbsp;72 words</footer><a class=entry-link aria-label="post link to 越南" href=https://duck-dd.github.io/posts/%E8%B6%8A%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>印尼</h2></header><div class=entry-content><p>最近深度参与一些海外业务，今天了解一下印尼。
名称：印度尼西亚 印尼 Indonesia 语言：印度尼西亚语 首都：雅加达(Jakarta，JKT) 逐步迁移至 努山塔拉(Ibu Kota Nusantara，缩写IKN) 国土面积：191.4万平方公里(陆) 316.6万平方公里(海) 位置：亚洲东南部，太平洋印度洋之间 气候：赤道海洋性气候；炎热，潮湿多雨；旱季6-9月，雨季12-3月 邻(近)国：巴布亚新几内亚 东帝汶 马来西亚 泰国 新加坡 菲律宾 澳大利亚 人口：约3亿 世界第四 政治体制：总统制共和制 经济制度：市场经济体制 社会制度：资本主义制度 货币：印度尼西亚盾，简称印尼盾，货币代码IDR，货币符号RP GDP： 2024：名义GDP为22138.96万亿印尼盾，折合13967.87亿美元 对比中国，2024 中国大陆名义GDP总量折合189433.42亿美元 立法：每个省有自己的立法机关 文化：传统服饰“巴迪克”；舞蹈(巴厘舞，爪哇舞)；雕塑 宗教信仰：伊斯兰教(87%) 基督教(6%) 天主教(3.6%) 美食：沙嗲、印尼炒饭、gado-gado（什锦蔬菜沙拉）等；口味融合了甜、辣、酸等 国家内部 行政区域/地理区域 划分： 省 —> 县/市 —> 区 —> 村/社区 38个省 主要城市： 雅加达(Jakarta, JKT)：印尼最大的城市，位于爪哇岛西北部沿海 泗水(Surabaya, SUB,SUR)：印尼第二大城市，东爪哇省的省会，位于爪哇岛东北沿海的泗水海峡西南侧 万隆（Bandung, BDO）：西爪哇省的省会，位于爪哇岛西部的万隆盆地中 棉兰（Medan, MES）：苏北省省会，位于苏门答腊岛北部，是苏门答腊岛最大城市 三宝垄（Semarang, SRG,CGK）：中爪哇省的省会，位于爪哇岛中部北岸，是爪哇岛中部地区重要的交通枢纽及商品集散地 望加锡（Makassar, MAK,UPG）：南苏拉威西省的省会，位于苏拉威西岛南端，是苏拉威西岛最大的城市 登巴萨（Denpasar, DPS）：巴厘省的省会，位于巴厘岛南部，是巴厘岛的政治、经济和文化中心 历史进程简述： 公元3-7世纪开始有部落记载 13世纪末14世纪初，满者伯夷帝国在东爪哇建立 1602年荷兰成立东印度公司，成为荷兰殖民地 1942年日本入侵，印尼进入日本统治时期 1945年8月15日，日本投降，苏加诺宣布印度尼西亚独立 1949年12月，荷兰正式承认印尼独立 1970年代后，从传统的计划经济向市场经济转变</p></div><footer class=entry-footer><span title='2025-08-15 00:00:00 +0000 UTC'>2025-08-15</span>&nbsp;·&nbsp;创建于:&nbsp;2025-08-15&nbsp;·&nbsp;1 min&nbsp;·&nbsp;71 words</footer><a class=entry-link aria-label="post link to 印尼" href=https://duck-dd.github.io/posts/%E5%8D%B0%E5%B0%BC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>目标管理法</h2></header><div class=entry-content><p>当我们写KPI时，我们在写什么？当我们写OKR时，我们在写什么？
这个问题困扰了许久，从个人的角度，我一直把这些东西当成枷锁，今晚突然寻思，我为什么不能认真审视这个东西，既然总是要花精力来处理，那不如把这个工具用起来。 人都是渴望自由的，或者至少这么说，放纵总是使绝大多数人快乐的；所以前面我们说目标管理是一种枷锁，但是枷锁未必是坏的东西，它也可能是一种推你向上的动力。 在第一次工作中接触OKR时，我当天就给自己的生活也定了好几个OKR，虽然一个也没实现，但是却还是给了我一些挣扎的动力来往前走了几步。求其上者得其中，求其下者无所得，希望无论是工作还是生活，我们能够永远保持对O的无上憧憬。
我理解的 O+KR 对于O，我认为就一个原则，把最终状态描述清楚，这个状态一般比较遥远(美好)但却不是遥不可及(务实)，精髓在于对于 遥远 的把控。
对于KR，人们常说的最关键的特性就是，可量化。一组KR是达成一个O的具体行动指引list，每一个KR的制定需要提前考虑好他的量化评估指标，每一个KR是可评估的这样才能够保证O是可评估的，那么这一组OKR才是有意义的。
举个简单的例子：
O1: 我要做一个帅哥(这个O很美好，能够充分激发主观能动性(牛马工厂管这叫owner意识)) KR1: 八块腹肌(这个KR制定的很好，量化方式很简单) KR2: 皮肤状态变好(这个KR定的不好，“状态变好”很难量化，都不如改成12点前睡觉/一年用光一瓶洗面奶/每个月用完10片面膜) KR3: 搞个酷酷的发型(这个KR制定的也不太好，有一点过于具体了，很容易就做完了，这种应该是某一个KR里面的一个子项) SMART目标法 下面记录巩固一下前人总结的制定目标的SMART法则(from 豆包)。
S（Specific）：明确具体 目标必须清晰、具体，避免模糊笼统，明确 “做什么、谁来做、怎么做”。 反面示例：“提高业绩”（模糊，未明确提高多少、针对哪个业务）。 正面示例：“销售团队在第三季度将产品 A 的销售额提升 20%”（明确主体、对象、时间、指标）。
M（Measurable）：可衡量 目标需有量化标准，便于跟踪进度和判断是否完成，避免 “完成了但说不清完成度” 的情况。 反面示例：“改善客户满意度”（无法量化 “改善” 的程度）。 正面示例：“通过季度调研，将客户满意度评分从 80 分提升至 90 分以上”（用具体分数衡量）。
A（Achievable）：可实现 目标需具有挑战性，但在现有资源（时间、能力、预算等）下可达成，避免因目标过高而失去动力，或过低而缺乏意义。 反面示例：“零基础 1 个月内成为 AI 专家”（资源和时间不匹配，难以实现）。 正面示例：“3 个月内通过系统学习，掌握 Python 基础编程并独立完成一个数据分析项目”（结合现有基础和学习路径，可实现）。
R（Relevant）：相关性 目标需与个人 / 团队的核心目标、长期愿景相关联，确保资源投入有价值，避免偏离核心方向。 反面示例：“市场部花大量时间学习财务软件”（与市场部核心职责关联度低）。 正面示例：“市场部学习新媒体运营工具，提升短视频内容曝光量”（直接服务于 “扩大品牌影响力” 的核心目标）。
T（Time-bound）：有时限 目标必须设定明确的完成时间，避免无限期拖延，同时便于规划阶段任务。 反面示例：“完成产品迭代”（无时间限制，易导致进度松散）。 正面示例：“在 2024 年 12 月 31 日前完成 V2.0 版本的功能开发并上线”（明确截止时间，可拆分阶段任务）。
...</p></div><footer class=entry-footer><span title='2025-08-13 00:00:00 +0000 UTC'>2025-08-13</span>&nbsp;·&nbsp;创建于:&nbsp;2025-08-13&nbsp;·&nbsp;1 min&nbsp;·&nbsp;73 words</footer><a class=entry-link aria-label="post link to 目标管理法" href=https://duck-dd.github.io/posts/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MCMF from scratch</h2></header><div class=entry-content><p>需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。 记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。
MCMF概念 Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：
有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；
求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量
在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。
最大流问题 最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：Ford-Fulkerson算法。
第一印象 简单描述，有向有权图，起点s，终点t，我们要寻找s->t的最大的流量。 那么朴素的第一印象来看，暴力呗，BFS把所有s->t路径集合P全部记录下来，然后逐条路径遍历P，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个边->剩余容量)，结束后得到一个总的流量值。 提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于s的所有出边都满，或者t的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，P的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，P中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对P剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。 好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：
图1 blocking-flow(黑色数字=容量,红色数字=流量) 如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，阻塞流，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。 结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点s以及他的出边，终点t以及他的入边，我们碰到了这样一个情况，我们选定了s的左出边以及t的右入边并且把它们两个给跑满了，而s的右出边和t的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，t的右入边跑满的流量不仅仅来自于s的左出边，还有s的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。
那么如何修正能够确保准确的找到最大流呢？
再继续暴力的把P的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度) 前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈) 我们避免使用到不合理的路径？那对路径打分？结合实时的 residual graph(残量图，余量图，残量网络 等)，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(s t除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖residual graph来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的 那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了 Ford-Fulkerson 一句话描述Ford-Fulkerson算法，就是在建立residual graph时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。 从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。 但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径) 不是的，还是用图1左举例，他的residual graph如下：
图2 图1左部的residual-graph 图2中，我们可以继续找到这样一条路径s->v2->v4->v1->v3->t 流量=1，其中v4->v1 流量=1这一段是我们选中的反向边(我们只对这一条边做了"撤销")，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明Ford-Fulkerson算法是正确的。 那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在residual graph中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在s—>t的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个H型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整H型的两条竖线之间的流量分配方式(即合理规划使用H的左上 左下 右上 右下四部分)，以使得整个H通过的流量最大。
...</p></div><footer class=entry-footer><span title='2025-06-24 00:00:00 +0000 UTC'>2025-06-24</span>&nbsp;·&nbsp;创建于:&nbsp;2025-06-24&nbsp;·&nbsp;1 min&nbsp;·&nbsp;201 words</footer><a class=entry-link aria-label="post link to MCMF from scratch" href=https://duck-dd.github.io/posts/mcmf/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>The Shortest Path</h2></header><div class=entry-content><p>最短路径问题 寻找有向图中两个顶点之间的路径，使得 路径最短 或 路径上各边的权重之和最小
1 无权图最短路径 所有边权重相同，最短路径退化为寻找两点间边数最少的路径，BFS搞定。
2 单源最短路径(SSSP, Single-Source Shortest Paths) 2.1 Dijkstra(堆优化) 限制：边权非负 思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径 步骤 初始化： 源点s的距离为0，源点s一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞) 所有节点标记为未访问 循环处理： 从未访问节点中选择距离最小的节点u，标记为已访问 对u的每个邻接节点v，进行 松弛操作: if distance[v] > distance[u] + weight(u, v): distance[v] = distance[u] + weight(u, v) predecessor[v] = u # 记录路径 终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点） 优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为O(logV) 记录路径：通过记录前驱节点可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序) 算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点 2.2 Bellman-Ford 限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小) 思路：通过 松弛操作 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边(u, v)，若从源点到u的距离 dist[u]加上边权w(u, v)小于当前到v的距离dist[v]，则更新dist[v] 步骤 初始化：源点距离dist[source] = 0，其他顶点距离dist[v] = ∞ 弛操作：对图中所有边进行n-1轮松弛（n为顶点数）；因为最短路径最多包含n-1条边(否则存在环，若为正权环可忽略，负权环则无法求解) 检测负权环：第n次松弛时，若仍能更新距离，则说明存在从源点可达的负权环 优化：下面的SPFA 算法正确性理解：n个节点，那么起点到终点路径最长就是 1->2->3->...->n 最多有n-1跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代x轮，那么x跳能到达的节点的最短路径都会被优化完成，所以经过n-1轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成 2.3 SPFA, Shortest Path Faster Algorithm SPFA其实只是Bellman-Ford的筛选优化，本质相同
...</p></div><footer class=entry-footer><span title='2025-06-23 00:00:00 +0000 UTC'>2025-06-23</span>&nbsp;·&nbsp;创建于:&nbsp;2025-06-23&nbsp;·&nbsp;2 min&nbsp;·&nbsp;267 words</footer><a class=entry-link aria-label="post link to The Shortest Path" href=https://duck-dd.github.io/posts/shortest-path/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang Tips</h2></header><div class=entry-content><p>说明：
持续更新(标题含TODO关键字的小节，都会以topic开始，后续会持续完善topic)。记录内容是一些对我而言：
小的骚操作(可能有些tricky) 容易理解偏差的点 冷门的点(没啥用的点) Golang代码执行顺序 没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。
了解更多可查看Golang内存模型规范。
internal包 internal包，只能被和internal目录有同一个父目录的包所导入。 例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。
变量交换 i, j = j, i // 交换 i 和 j 的值 for循环有其他识别break的关键字 for循环内有其他识别break的关键字时，其他关键字内的break会被其识别而不会跳出for，以下用select举例，switch同理。
for { select { case &lt;-sigChan: // exit for break default: // do something } } 以上break并不能退出for循环，可以使用标签或goto解决：
// 1 标签 FOR: for { select { case &lt;-sigChan: // exit for break FOR default: // do something } } ---------------------------- // 2 goto for { select { case &lt;-sigChan: // exit for goto ENDFOR default: // do something } } ENDFOR: 读取stdin(刷题别再因为stdin踩坑了喂) fmt包内 Scan系列 SScan系列 Fscan系列如下：
...</p></div><footer class=entry-footer><span title='2025-06-22 00:00:00 +0000 UTC'>2025-06-22</span>&nbsp;·&nbsp;创建于:&nbsp;2021-07-01&nbsp;·&nbsp;21 min&nbsp;·&nbsp;4386 words</footer><a class=entry-link aria-label="post link to Golang Tips" href=https://duck-dd.github.io/posts/go-tips/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>装修那些事儿</h2></header><div class=entry-content><p>这个行业，是一个没有监管，没有行业标准(有的大部分也是扯淡)，群魔乱舞的行业，这行业人的话，不要相信，不要相信，不要相信
从我自身经历来说，这件事真的不复杂，完全不值他现在的价钱；一开始这件事很神秘，你觉得付多少钱都是合理的，但真不是这样，到处都是骗钱的；所以装修开始前真正的第一件事，就是你要了解一下背景评估一下工作量，放心大胆的去砍价吧
本文从自己的亲身经历出发来分析一下装修这件令人头疼的事情，没有展开太多的细节，只以各个阶段的典型选择题为切入点，欢迎指正和交流，预祝你获得你的梦中情屋～
全包 or 半包 如果你刚开始考虑装修，那你一定是特别开心和兴奋的。你面临的第一个问题大概就是，“半包” or “全包”（自己找工人的方式，不太了解就不谈了）；很多声音会告诉你说，全包这种完全黑盒的行为会有太多坑了，给你用的东西都是差的balabala 但是，如果你想省心，或者在装修的这几个月里你没有太多的时间精力能够投入进这件事，那么还是建议你咬咬牙忽略这些有一丢丢危言耸听的说法，果断的选择全包；如果你选择了全包，那么我们对最终效果的确认无非靠两个关键指标
1 是不是我想要的样子 2 是不是环保 为了第一点，你需要查看素材库确认好自己喜欢的样子，跟设计师做充分的沟通，并在施工过程的关键节点约设计师一起去现场做阶段性的沟通和double check，因为省心，所以你做的功课可能不多，其实这比较依赖设计师的专业性 为了第二点，你需要做的功课是，查一查装修过程中哪些使用到的材料可能会不环保，然后直接在合同里声明好这些材料具体使用哪些品牌的哪些型号，并在这些材料入场时做好检查(其实可以找类似"监工"的角色来帮助你执行，应该总比你完全不去现场要好)
朋友，如果你选择了半包，那你是真的勇士，对你表示敬佩，以下的讨论咱们就默认你已经做了大量的背景&功课的学习。
入户门 换！你99%不喜欢开发商的这个，相比换锁，就干脆直接换门吧
窗户 如果允许，换！拉满配(可能很多地方政策不允许动外立面，那就没办法了)
隔音 如果你对声音要求很高，考虑做全屋音响，那是肯定得做了 如果你没有考虑做全屋音响，那么我还是强！烈！建！议！做隔音！
全屋定制 or 成品家具 个人观点，全屋定制真的不咋地，建议祛魅，认真的去逛一逛成品家具市场； 还往下看，你果然还是跟我一样，头铁的选择了全屋定制，那这个子方向发个千八百个论文感觉都泛不起一点水花； 商家贩卖的焦虑点：甲醛，苯系化合物；你要想死磕，得先学化学； 标准：国外国内太多标准，但有一点个人觉得有参考意义，就是 抽检 & 送检 ； 品牌选择：大商场大品牌的品牌溢价确实太高了，而且也确实代加工，所以有判断能力那就果断直接找工厂吧； 细节不展开讲了，说一点注意点，跟电位/管道做配合要提前做规划，这也是为什么把这个问题放得这么靠前
布局 该砸就砸别犹豫(非承重) 新砌墙时考虑好用途，如果有承重需求(例如挂电视 挂柜子等)，考虑好墙体的材料 砌墙后多晾一晾 否则后期墙上面搞得任何东西都容易剥离 墙的平的问题，从小白视角来看，就是表面是平面，并且这个平面跟其他平面的角度(一般90度)是正常的，这点不管施工方是冲筋 垂平还是啥方法，总之先讲清楚要求并让他们严格执行 坐便or蹲便？多个卫生间可以考虑留一个蹲便，不仅健康，而且后期小孩使用也方便，或者上面再放小马桶也好扩展（这个问题需要提前考虑因为可能影响卫生间地面高度布局）
水电 水管线管一定选择最好的品牌的好的型号，避免后期出问题太麻烦 至于是按使用长度算，还是一口价模式，自己来衡量对比，是否点对点走线？可以看网上大量的分析 电箱位置挪不挪？如果风水问题(那么你一定是相信这个的)，挪；如果只是为了好看，那后期挺多方法弄好看，可以看看效果自己能不能接受 前置过滤器：空间允许，就安；拉满配，本身没多贵，影响水压就不好了 全屋软水：没考虑清楚，就做 下水：有顾虑该做的位置就做，用不用得上再说 电位：有顾虑就做，总比后期拉插线板强(70个/100平 ？) 开关：一开多控别顾虑，想做就做，方便生活 全屋智能：已经在考虑这个问题了？那就做。。。有点贵，考虑好性价比吧，应了那句话，贵的东西，除了贵，没有其他的毛病；这里不展开讲了，太复杂了，完全可以单开一页的东西；PS:从初中物理来分析全屋智能，既然有智能控制开关，而这个开关本身也是需要供电的，那么如果把开关串联到电路里，他就不是yes or no的开关，关闭状态本身是一个大电阻，也就是还是有微弱的电流通过电路，这一定是不好的，所以还是预留好控制路的零线吧
有两个容易忽略的点
1 墙面不能开长的横槽(脑补一下这确实会影响墙的稳定性) 2 强弱电磁场干扰问题，物理已经还给老师了，但是避免干扰这个要保持距离还是符合常识的 接下来让我们一起进入木瓦油环节
全屋吊顶 or 部分吊顶 如果考虑做无主灯，那么肯定全屋吊顶 如果对层高有要求，那么就别吊顶 如果犹豫，那么就别做(我认为全部吊顶的目的就是做光线的规划，犹豫的话说明没有要求或规划，那就别做算了)
...</p></div><footer class=entry-footer><span title='2023-06-24 00:00:00 +0000 UTC'>2023-06-24</span>&nbsp;·&nbsp;创建于:&nbsp;2023-06-24&nbsp;·&nbsp;1 min&nbsp;·&nbsp;134 words</footer><a class=entry-link aria-label="post link to 装修那些事儿" href=https://duck-dd.github.io/posts/decoration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>软件架构设计原则</h2></header><div class=entry-content><p>每次接手一些老旧系统，总是很头疼，最近想，会不会别人接手了我的系统以后也是一样的感受，想到可能有人每天都在吐槽(骂)我头皮发麻啊…
知易行难，其实怎么做好一个后端服务大家都是门清的，只是受限于 排期 业务价值 协作 等太多因素，往往事与愿违。只能说但行好事莫问前程吧，下面再把这些原则列一下，时刻提醒自己吧；以下原则从个人角度分先后，不是说有重要性区别，而是有些原则很高频，或者很容易被忽略，需要时刻牢记。
一 职责/逻辑 清晰 单一职责原则（Single Responsibility Principle, SRP） 每个单元只负责一件事。 从总体架构上讲，这个单元是一个子系统，例如订单系统，日志系统；从系统架构上讲，这个单元是一个模块，例如文章管理模块，评论管理模块等；从代码模块内部讲，这个单元是一个组件，一个类，一个struct等。再往下看，一个类还有N多个方法… 就像分子，原子，质子/电子，夸克…从宏观到微观的过程，就是我们把一套复杂的系统一点一点拆解开的过程，而每次向下拆解一层的时候，这一层的个体，尽量做到每个都负责一件事
迪米特法则（Law of Demeter, LoD） 一个模块应尽可能少地了解其他模块的内部细节。 反过来看，一个模块向外不暴露细节，别人就没法了解细节了；所以还是在讲控制耦合。
高内聚，低耦合（High Cohesion, Low Coupling） 模块内部的功能紧密相关(高内聚)，模块间通过明确接口交互，依赖关系简单(低耦合)。 明牌了，直接再提醒你一下，控制耦合控制耦合控制耦合…
接口隔离原则（Interface Segregation Principle, ISP） 客户端不应被迫依赖它不需要的接口，应将大接口拆分为多个专用小接口。 这里不是对使用者的要求，而是对接口提供(设计)者提出要求，在设计对外暴露接口时，要尽可能小，单一，独立，这样使用起来更灵活。 对外是这样的，但是内部接口，说实话我做不到尽可能小。
二 破坏性(侵入性)控制 开闭原则（Open-Closed Principle, OCP） 对扩展开放，对修改关闭。 从我的理解，这条原则更多还是在指导代码层面的设计；世界是动态发展的，没有一成不变的东西，那么对于代码，可扩展是必然的需求，那为什么对修改关闭呢？可能更多还是对原系统的侵入吧，你不知道你的使用方对你做出了怎么样的假设，总之目前为止世界和平，但当你修改了你的行为，假设被打破，世界就崩塌了
里氏替换原则（Liskov Substitution Principle, LSP） 子类必须能无缝替换父类，且不破坏原有系统的正确性。即父类出现的地方，子类可替代，且行为一致。
三 依赖管理 分层架构原则（Layered Architecture Principle） 将系统按职责划分为清晰的层次，层间单向依赖，禁止跨层调用。
依赖倒置原则（Dependency Inversion Principle, DIP） 高层模块不应依赖低层模块，两者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。
四 可扩展性 演进式架构原则（Evolutionary Architecture） 架构设计应预留扩展空间，支持系统随业务需求逐步演进，而非追求 “一步到位” 的完美设计。
五 安全(代码安全，服务安全，业务安全等) 安全性原则（Security by Design） 将安全性嵌入架构设计的每个环节，而非事后补丁。
...</p></div><footer class=entry-footer><span title='2023-04-16 00:00:00 +0000 UTC'>2023-04-16</span>&nbsp;·&nbsp;创建于:&nbsp;2023-04-16&nbsp;·&nbsp;1 min&nbsp;·&nbsp;71 words</footer><a class=entry-link aria-label="post link to 软件架构设计原则" href=https://duck-dd.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang schedule</h2></header><div class=entry-content><p>写在前面 runtime包实现了所有goroutine scheduler、memory allocator、garbage collector细节，理论上可以从runtime包获取一切信息，没有直接怼源码，而是站在巨人的肩膀上（直接吃大佬们吃剩下的）。
搜集到的材料，大家都是基于不同的go版本做的分析，而go版本迭代调度算法也在持续更新，所以整理的可能有些乱。但是可以保证的是，所有材料都是GM->GMP演化后的材料。
GM go1.1版本以前，调度使用GM模型，如下图所示。简单的理解GM模型，就是有一个始终执行的调度函数schedule不停的执行调度计算，当某个M的G执行完成了，调度器就把这个M放回M队列，可绑定执行其他G（如果某个M+G发生了syscall，那么本来并发度是通过M数量控制的，此时并发度就降低了？）；如果G执行过程中创建新的G，会将新的G放入到G全局可执行队列中。G全局可执行队列的操作有一把全局锁，这导致了各个M对G全局队列的操作存在严重的竞争。
下面这段完全是我的臆测，请别太相信：
简单概括呢，所以可以认为有：
G全局可执行队列(以下也可能简称G可执行队列) M可用队列 调度器要做的事就是：
从G的可执行队列取G并从M的可用队列取M，将二者绑定开始执行G 对于已经执行完的G，销毁G并立即将M释放回M可用队列供后续使用 那么GM模型有哪些问题呢？
(重点问题)单一的全局mutex(sched.lock)和集中状态管理 mutex需要保护所有与全局goroutine队列相关操作(创建、完成、重排等等)，竞争严重 (重点问题)per-M内存(M.mcache)问题 每个M都需要一个mcache，会导致资源消耗过大(每个mcache可以吸纳到2MB的内存缓存和其他缓存) 举个栗子，一个陷入syscall的M并不需要使用cache，但是在全部的M中，陷入系统调用的M与执行goroutine的M的比例可能是N:1(N>>1)，这就导致了N/(N+1)比例的mcache在闲置 数据局部性差: 举个栗子，M1执行G1，此时创建了G2，G2通常是立刻进入了G全局可执行队列，而此时M1还在执行G1，所以G2通常被其他M执行，但是G1和G2通常强相关，所以G2最好也在M1上执行，因为G2对M1的缓存命中率更高 goroutine传递问题 goroutine(G)交接(G.nextg)，M之间会经常交接可运行的G 再通俗点说，就是G空转，本来能够好好在一个M上执行完，但是由于全局队列的存在，G一旦回全局队列了，下次就不知道被哪个M取走了，所以叫“空转”；M加载G的上下文是有开销的，所以空转会导致性能下降 频繁的线程阻塞/解阻塞 syscalls情况下，线程经常被阻塞和解阻塞，增加了很多额外开销 通俗点说，M+G syscall，M阻塞，syscall完成后，M解阻塞继续执行G（如果是通过M数量控制并发度，这是不是就导致了并发度降低？） GMP 基于以上说的GM的问题，go1.1以后开始使用GMP调度模型。 G、M、P的定义如下(***/src/runtime/runtime2.go)。
type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). stack stack // offset known to runtime/cgo stackguard0 uintptr // offset known to liblink stackguard1 uintptr // offset known to liblink _panic *_panic // innermost panic - offset known to liblink _defer *_defer // innermost defer m *m // current m; offset known to arm liblink sched gobuf syscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc syscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc stktopsp uintptr // expected sp at top of stack, to check in traceback param unsafe.Pointer // passed parameter on wakeup atomicstatus uint32 stackLock uint32 // sigprof/scang lock; TODO: fold in to atomicstatus goid int64 schedlink guintptr waitsince int64 // approx time when the g become blocked waitreason waitReason // if status==Gwaiting preempt bool // preemption signal, duplicates stackguard0 = stackpreempt preemptStop bool // transition to _Gpreempted on preemption; otherwise, just deschedule preemptShrink bool // shrink stack at synchronous safe point // asyncSafePoint is set if g is stopped at an asynchronous // safe point. This means there are frames on the stack // without precise pointer information. asyncSafePoint bool paniconfault bool // panic (instead of crash) on unexpected fault address gcscandone bool // g has scanned stack; protected by _Gscan bit in status throwsplit bool // must not split stack // activeStackChans indicates that there are unlocked channels // pointing into this goroutine's stack. If true, stack // copying needs to acquire channel locks to protect these // areas of the stack. activeStackChans bool // parkingOnChan indicates that the goroutine is about to // park on a chansend or chanrecv. Used to signal an unsafe point // for stack shrinking. It's a boolean value, but is updated atomically. parkingOnChan uint8 raceignore int8 // ignore race detection events sysblocktraced bool // StartTrace has emitted EvGoInSyscall about this goroutine sysexitticks int64 // cputicks when syscall has returned (for tracing) traceseq uint64 // trace event sequencer tracelastp puintptr // last P emitted an event for this goroutine lockedm muintptr sig uint32 writebuf []byte sigcode0 uintptr sigcode1 uintptr sigpc uintptr gopc uintptr // pc of go statement that created this goroutine ancestors *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors) startpc uintptr // pc of goroutine function racectx uintptr waiting *sudog // sudog structures this g is waiting on (that have a valid elem ptr); in lock order cgoCtxt []uintptr // cgo traceback context labels unsafe.Pointer // profiler labels timer *timer // cached timer for time.Sleep selectDone uint32 // are we participating in a select and did someone win the race? // Per-G GC state // gcAssistBytes is this G's GC assist credit in terms of // bytes allocated. If this is positive, then the G has credit // to allocate gcAssistBytes bytes without assisting. If this // is negative, then the G must correct this by performing // scan work. We track this in bytes to make it fast to update // and check for debt in the malloc hot path. The assist ratio // determines how this corresponds to scan work debt. gcAssistBytes int64 } type m struct { g0 *g // goroutine with scheduling stack morebuf gobuf // gobuf arg to morestack divmod uint32 // div/mod denominator for arm - known to liblink // Fields not known to debuggers. procid uint64 // for debuggers, but offset not hard-coded gsignal *g // signal-handling g goSigStack gsignalStack // Go-allocated signal handling stack sigmask sigset // storage for saved signal mask tls [6]uintptr // thread-local storage (for x86 extern register) mstartfn func() curg *g // current running goroutine caughtsig guintptr // goroutine running during fatal signal p puintptr // attached p for executing go code (nil if not executing go code) nextp puintptr oldp puintptr // the p that was attached before executing a syscall id int64 mallocing int32 throwing int32 preemptoff string // if != "", keep curg running on this m locks int32 dying int32 profilehz int32 spinning bool // m is out of work and is actively looking for work blocked bool // m is blocked on a note newSigstack bool // minit on C thread called sigaltstack printlock int8 incgo bool // m is executing a cgo call freeWait uint32 // if == 0, safe to free g0 and delete m (atomic) fastrand [2]uint32 needextram bool traceback uint8 ncgocall uint64 // number of cgo calls in total ncgo int32 // number of cgo calls currently in progress cgoCallersUse uint32 // if non-zero, cgoCallers in use temporarily cgoCallers *cgoCallers // cgo traceback if crashing in cgo call park note alllink *m // on allm schedlink muintptr lockedg guintptr createstack [32]uintptr // stack that created this thread. lockedExt uint32 // tracking for external LockOSThread lockedInt uint32 // tracking for internal lockOSThread nextwaitm muintptr // next m waiting for lock waitunlockf func(*g, unsafe.Pointer) bool waitlock unsafe.Pointer waittraceev byte waittraceskip int startingtrace bool syscalltick uint32 freelink *m // on sched.freem // these are here because they are too large to be on the stack // of low-level NOSPLIT functions. libcall libcall libcallpc uintptr // for cpu profiler libcallsp uintptr libcallg guintptr syscall libcall // stores syscall parameters on windows vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call) vdsoPC uintptr // PC for traceback while in VDSO call // preemptGen counts the number of completed preemption // signals. This is used to detect when a preemption is // requested, but fails. Accessed atomically. preemptGen uint32 // Whether this is a pending preemption signal on this M. // Accessed atomically. signalPending uint32 dlogPerM mOS // Up to 10 locks held by this m, maintained by the lock ranking code. locksHeldLen int locksHeld [10]heldLockInfo } type p struct { id int32 status uint32 // one of pidle/prunning/... link puintptr schedtick uint32 // incremented on every scheduler call syscalltick uint32 // incremented on every system call sysmontick sysmontick // last tick observed by sysmon m muintptr // back-link to associated m (nil if idle) mcache *mcache pcache pageCache raceprocctx uintptr deferpool [5][]*_defer // pool of available defer structs of different sizes (see panic.go) deferpoolbuf [5][32]*_defer // Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen. goidcache uint64 goidcacheend uint64 // Queue of runnable goroutines. Accessed without lock. runqhead uint32 runqtail uint32 runq [256]guintptr // runnext, if non-nil, is a runnable G that was ready'd by // the current G and should be run next instead of what's in // runq if there's time remaining in the running G's time // slice. It will inherit the time left in the current time // slice. If a set of goroutines is locked in a // communicate-and-wait pattern, this schedules that set as a // unit and eliminates the (potentially large) scheduling // latency that otherwise arises from adding the ready'd // goroutines to the end of the run queue. runnext guintptr // Available G's (status == Gdead) gFree struct { gList n int32 } sudogcache []*sudog sudogbuf [128]*sudog // Cache of mspan objects from the heap. mspancache struct { // We need an explicit length here because this field is used // in allocation codepaths where write barriers are not allowed, // and eliminating the write barrier/keeping it eliminated from // slice updates is tricky, moreso than just managing the length // ourselves. len int buf [128]*mspan } tracebuf traceBufPtr // traceSweep indicates the sweep events should be traced. // This is used to defer the sweep start event until a span // has actually been swept. traceSweep bool // traceSwept and traceReclaimed track the number of bytes // swept and reclaimed by sweeping in the current sweep loop. traceSwept, traceReclaimed uintptr palloc persistentAlloc // per-P to avoid mutex _ uint32 // Alignment for atomic fields below // The when field of the first entry on the timer heap. // This is updated using atomic functions. // This is 0 if the timer heap is empty. timer0When uint64 // Per-P GC state gcAssistTime int64 // Nanoseconds in assistAlloc gcFractionalMarkTime int64 // Nanoseconds in fractional mark worker (atomic) gcBgMarkWorker guintptr // (atomic) gcMarkWorkerMode gcMarkWorkerMode // gcMarkWorkerStartTime is the nanotime() at which this mark // worker started. gcMarkWorkerStartTime int64 // gcw is this P's GC work buffer cache. The work buffer is // filled by write barriers, drained by mutator assists, and // disposed on certain GC state transitions. gcw gcWork // wbBuf is this P's GC write barrier buffer. // // TODO: Consider caching this in the running G. wbBuf wbBuf runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point // Lock for timers. We normally access the timers while running // on this P, but the scheduler can also do it from a different P. timersLock mutex // Actions to take at some time. This is used to implement the // standard library's time package. // Must hold timersLock to access. timers []*timer // Number of timers in P's heap. // Modified using atomic instructions. numTimers uint32 // Number of timerModifiedEarlier timers on P's heap. // This should only be modified while holding timersLock, // or while the timer status is in a transient state // such as timerModifying. adjustTimers uint32 // Number of timerDeleted timers in P's heap. // Modified using atomic instructions. deletedTimers uint32 // Race context used while executing timer functions. timerRaceCtx uintptr // preempt is set to indicate that this P should be enter the // scheduler ASAP (regardless of what G is running on it). preempt bool pad cpu.CacheLinePad } GMP模型的一些概念 上面M中有两个g需要关注下，curg和g0。 curg就是M当前绑定的G。 g0是带有调度栈的goroutine，普通的G的栈是分配在堆上的可增长的栈，而g0的栈是M对应的线程的栈。所有调度相关的代码，会先切换到该goroutine的栈中执行。即，线程的栈也是用的g实现，而不是使用的OS。
...</p></div><footer class=entry-footer><span title='2021-08-21 00:00:00 +0000 UTC'>2021-08-21</span>&nbsp;·&nbsp;创建于:&nbsp;2021-08-21&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1904 words</footer><a class=entry-link aria-label="post link to Golang schedule" href=https://duck-dd.github.io/posts/go-schedule/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DNS</h2></header><div class=entry-content><p>DNS，挺好，啥是DNS？ 一些概念 FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。 cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源 forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。 CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15 A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号 DNS做什么 ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。
主机名的解析有一个发展的过程。
最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。
这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。
这种方式问题很多：
例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大） 例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了 时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。
BIND，Berkeley Internet Name Domain BIND管理方式 BIND是一套阶层式的管理主机名与IP对应关系的系统。
阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。
以www.baidu.com为例，最上层根服务器，domain name是"."，然后有三个hostname “net com cn”，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个".“都拆分domain name&amp;hostname，例如上图 video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。
DNS阶层系统的最上方是一个”."，root，是根服务器，本质上讲，这里的".“后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。
每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括”.")；同一层内不允许同名，确保唯一性。
BIND查询流程 当浏览器输入 https://www.baidu.com ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录 client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？ 其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认) .并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧 然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果 .com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧 .com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？) ...</p></div><footer class=entry-footer><span title='2021-05-13 00:00:00 +0000 UTC'>2021-05-13</span>&nbsp;·&nbsp;创建于:&nbsp;2021-05-13&nbsp;·&nbsp;4 min&nbsp;·&nbsp;847 words</footer><a class=entry-link aria-label="post link to DNS" href=https://duck-dd.github.io/posts/dns/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://duck-dd.github.io/>Duck</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>