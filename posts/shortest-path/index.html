<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Shortest Path | Duck</title><meta name=keywords content="Algorithm,2025"><meta name=description content="最短路径问题
寻找有向图中两个顶点之间的路径，使得 路径最短 或 路径上各边的权重之和最小
1 无权图最短路径
所有边权重相同，最短路径退化为寻找两点间边数最少的路径，BFS搞定。
2 单源最短路径(SSSP, Single-Source Shortest Paths)
2.1 Dijkstra(堆优化)

限制：边权非负
思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径
步骤

初始化：

源点s的距离为0，源点s一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞)
所有节点标记为未访问


循环处理：

从未访问节点中选择距离最小的节点u，标记为已访问
对u的每个邻接节点v，进行 松弛操作:
if distance[v] > distance[u] + weight(u, v):
    distance[v] = distance[u] + weight(u, v)
    predecessor[v] = u  # 记录路径



终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点）


优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为O(logV)
记录路径：通过记录前驱节点可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序)
算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点

2.2 Bellman-Ford

限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小)
思路：通过 松弛操作 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边(u, v)，若从源点到u的距离 dist[u]加上边权w(u, v)小于当前到v的距离dist[v]，则更新dist[v]
步骤

初始化：源点距离dist[source] = 0，其他顶点距离dist[v] = ∞
弛操作：对图中所有边进行n-1轮松弛（n为顶点数）；因为最短路径最多包含n-1条边(否则存在环，若为正权环可忽略，负权环则无法求解)
检测负权环：第n次松弛时，若仍能更新距离，则说明存在从源点可达的负权环


优化：下面的SPFA
算法正确性理解：n个节点，那么起点到终点路径最长就是 1->2->3->...->n 最多有n-1跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代x轮，那么x跳能到达的节点的最短路径都会被优化完成，所以经过n-1轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成

2.3 SPFA, Shortest Path Faster Algorithm
SPFA其实只是Bellman-Ford的筛选优化，本质相同"><meta name=author content><link rel=canonical href=https://duck-dd.github.io/posts/shortest-path/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2a8ef18cccda149eb1cd8ec968ba463447d72022979e5c5cae43dcf5d7358750.css integrity="sha256-Ko7xjMzaFJ6xzY7JaLpGNEfXICKXnlxcrkPc9dc1h1A=" rel="preload stylesheet" as=style><link rel=icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://duck-dd.github.io/posts/shortest-path/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><meta property="og:url" content="https://duck-dd.github.io/posts/shortest-path/"><meta property="og:site_name" content="Duck"><meta property="og:title" content="The Shortest Path"><meta property="og:description" content="最短路径问题 寻找有向图中两个顶点之间的路径，使得 路径最短 或 路径上各边的权重之和最小
1 无权图最短路径 所有边权重相同，最短路径退化为寻找两点间边数最少的路径，BFS搞定。
2 单源最短路径(SSSP, Single-Source Shortest Paths) 2.1 Dijkstra(堆优化) 限制：边权非负 思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径 步骤 初始化： 源点s的距离为0，源点s一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞) 所有节点标记为未访问 循环处理： 从未访问节点中选择距离最小的节点u，标记为已访问 对u的每个邻接节点v，进行 松弛操作: if distance[v] > distance[u] + weight(u, v): distance[v] = distance[u] + weight(u, v) predecessor[v] = u # 记录路径 终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点） 优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为O(logV) 记录路径：通过记录前驱节点可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序) 算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点 2.2 Bellman-Ford 限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小) 思路：通过 松弛操作 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边(u, v)，若从源点到u的距离 dist[u]加上边权w(u, v)小于当前到v的距离dist[v]，则更新dist[v] 步骤 初始化：源点距离dist[source] = 0，其他顶点距离dist[v] = ∞ 弛操作：对图中所有边进行n-1轮松弛（n为顶点数）；因为最短路径最多包含n-1条边(否则存在环，若为正权环可忽略，负权环则无法求解) 检测负权环：第n次松弛时，若仍能更新距离，则说明存在从源点可达的负权环 优化：下面的SPFA 算法正确性理解：n个节点，那么起点到终点路径最长就是 1->2->3->...->n 最多有n-1跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代x轮，那么x跳能到达的节点的最短路径都会被优化完成，所以经过n-1轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成 2.3 SPFA, Shortest Path Faster Algorithm SPFA其实只是Bellman-Ford的筛选优化，本质相同"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-23T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-23T00:00:00+00:00"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="2025"><meta property="og:image" content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="The Shortest Path"><meta name=twitter:description content="最短路径问题
寻找有向图中两个顶点之间的路径，使得 路径最短 或 路径上各边的权重之和最小
1 无权图最短路径
所有边权重相同，最短路径退化为寻找两点间边数最少的路径，BFS搞定。
2 单源最短路径(SSSP, Single-Source Shortest Paths)
2.1 Dijkstra(堆优化)

限制：边权非负
思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径
步骤

初始化：

源点s的距离为0，源点s一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞)
所有节点标记为未访问


循环处理：

从未访问节点中选择距离最小的节点u，标记为已访问
对u的每个邻接节点v，进行 松弛操作:
if distance[v] > distance[u] + weight(u, v):
    distance[v] = distance[u] + weight(u, v)
    predecessor[v] = u  # 记录路径



终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点）


优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为O(logV)
记录路径：通过记录前驱节点可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序)
算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点

2.2 Bellman-Ford

限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小)
思路：通过 松弛操作 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边(u, v)，若从源点到u的距离 dist[u]加上边权w(u, v)小于当前到v的距离dist[v]，则更新dist[v]
步骤

初始化：源点距离dist[source] = 0，其他顶点距离dist[v] = ∞
弛操作：对图中所有边进行n-1轮松弛（n为顶点数）；因为最短路径最多包含n-1条边(否则存在环，若为正权环可忽略，负权环则无法求解)
检测负权环：第n次松弛时，若仍能更新距离，则说明存在从源点可达的负权环


优化：下面的SPFA
算法正确性理解：n个节点，那么起点到终点路径最长就是 1->2->3->...->n 最多有n-1跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代x轮，那么x跳能到达的节点的最短路径都会被优化完成，所以经过n-1轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成

2.3 SPFA, Shortest Path Faster Algorithm
SPFA其实只是Bellman-Ford的筛选优化，本质相同"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://duck-dd.github.io/posts/"},{"@type":"ListItem","position":2,"name":"The Shortest Path","item":"https://duck-dd.github.io/posts/shortest-path/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Shortest Path","name":"The Shortest Path","description":"最短路径问题 寻找有向图中两个顶点之间的路径，使得 路径最短 或 路径上各边的权重之和最小\n1 无权图最短路径 所有边权重相同，最短路径退化为寻找两点间边数最少的路径，BFS搞定。\n2 单源最短路径(SSSP, Single-Source Shortest Paths) 2.1 Dijkstra(堆优化) 限制：边权非负 思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径 步骤 初始化： 源点s的距离为0，源点s一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞) 所有节点标记为未访问 循环处理： 从未访问节点中选择距离最小的节点u，标记为已访问 对u的每个邻接节点v，进行 松弛操作: if distance[v] \u0026gt; distance[u] + weight(u, v): distance[v] = distance[u] + weight(u, v) predecessor[v] = u # 记录路径 终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点） 优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为O(logV) 记录路径：通过记录前驱节点可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序) 算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点 2.2 Bellman-Ford 限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小) 思路：通过 松弛操作 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边(u, v)，若从源点到u的距离 dist[u]加上边权w(u, v)小于当前到v的距离dist[v]，则更新dist[v] 步骤 初始化：源点距离dist[source] = 0，其他顶点距离dist[v] = ∞ 弛操作：对图中所有边进行n-1轮松弛（n为顶点数）；因为最短路径最多包含n-1条边(否则存在环，若为正权环可忽略，负权环则无法求解) 检测负权环：第n次松弛时，若仍能更新距离，则说明存在从源点可达的负权环 优化：下面的SPFA 算法正确性理解：n个节点，那么起点到终点路径最长就是 1-\u0026gt;2-\u0026gt;3-\u0026gt;...-\u0026gt;n 最多有n-1跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代x轮，那么x跳能到达的节点的最短路径都会被优化完成，所以经过n-1轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成 2.3 SPFA, Shortest Path Faster Algorithm SPFA其实只是Bellman-Ford的筛选优化，本质相同\n","keywords":["Algorithm","2025"],"articleBody":"最短路径问题 寻找有向图中两个顶点之间的路径，使得 路径最短 或 路径上各边的权重之和最小\n1 无权图最短路径 所有边权重相同，最短路径退化为寻找两点间边数最少的路径，BFS搞定。\n2 单源最短路径(SSSP, Single-Source Shortest Paths) 2.1 Dijkstra(堆优化) 限制：边权非负 思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径 步骤 初始化： 源点s的距离为0，源点s一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞) 所有节点标记为未访问 循环处理： 从未访问节点中选择距离最小的节点u，标记为已访问 对u的每个邻接节点v，进行 松弛操作: if distance[v] \u003e distance[u] + weight(u, v): distance[v] = distance[u] + weight(u, v) predecessor[v] = u # 记录路径 终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点） 优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为O(logV) 记录路径：通过记录前驱节点可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序) 算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点 2.2 Bellman-Ford 限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小) 思路：通过 松弛操作 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边(u, v)，若从源点到u的距离 dist[u]加上边权w(u, v)小于当前到v的距离dist[v]，则更新dist[v] 步骤 初始化：源点距离dist[source] = 0，其他顶点距离dist[v] = ∞ 弛操作：对图中所有边进行n-1轮松弛（n为顶点数）；因为最短路径最多包含n-1条边(否则存在环，若为正权环可忽略，负权环则无法求解) 检测负权环：第n次松弛时，若仍能更新距离，则说明存在从源点可达的负权环 优化：下面的SPFA 算法正确性理解：n个节点，那么起点到终点路径最长就是 1-\u003e2-\u003e3-\u003e...-\u003en 最多有n-1跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代x轮，那么x跳能到达的节点的最短路径都会被优化完成，所以经过n-1轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成 2.3 SPFA, Shortest Path Faster Algorithm SPFA其实只是Bellman-Ford的筛选优化，本质相同\n思路：利用队列减少不必要的松弛操作，只有当一个顶点的距离被更新时，其邻接点才可能需要松弛，因此仅将更新过的顶点加入队列等待处理 优化本质：Bellman-Ford每次迭代都会遍历所有边，而SPFA只遍历 “可能需要更新” 的边，减少冗余操作 步骤 初始化：源点距离dist[source] = 0，其他顶点dist[v] = ∞；队列初始加入源点，标记顶点是否在队列中（避免重复入队） 队列处理： 取出队首顶点 u，遍历其所有邻接边 (u, v)。 若 dist[u] + w(u, v) \u003c dist[v]，则更新 dist[v] 若 v 不在队列中，则将其入队，并标记；若已在队列中，可跳过（或优化为 “若距离减少较多，可提前入队”） 检测负权环：记录每个顶点入队次数，若某顶点入队次数 ≥ n，则存在负权环（因为正常最短路径最多 n-1 条边，入队次数不会超过 n-1） 3 所有点对最短路径 3.1 Floyd 用于求解图中 所有顶点对之间最短路径 的动态规划算法，适用于带权图（包括有向图和无向图），且能处理负权边（无法处理负环）\n思路 Floyd 算法通过 “中间顶点” 逐步优化最短路径，具体来说，对于图中任意两个顶点i和j，算法考虑 “是否经过顶点k” 来更新 i -\u003e j 的最短路径： 若 i -\u003e k -\u003e j 的路径比当前已知的 i -\u003e j 路径更短，则更新最短路径长度 这里的 k 从所有顶点中依次选取，作为 “中间顶点” 进行尝试 步骤(图的顶点数为n，用邻接矩阵dist存储最短路径长度，其中dist[i][j]表示从顶点i到顶点j的最短路径长度) 初始 若i = j，则dist[i][j] = 0 若顶点i和j直接相连，且边权为w，则dist[i][j] = w 若顶点i和j不直接相连，则dist[i][j] = ∞(无穷大) 三重循环更新邻接矩阵 外层循环：枚举中间顶点k（从 0 到 n-1） 中层循环：枚举起点i（从 0 到 n-1） 内层循环：枚举终点j（从 0 到 n-1） 更新规则：对于每个 i, j, k，判断是否通过k能缩短路径：dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]) 记录路径：再开一个邻接矩阵，记录i j最短路径的绕行节点k，如果节点k存在，还需要递归查找 i -\u003e k k -\u003e j的绕行节点，直至找到完整路径 算法正确性理解：如图1，第一次绕行节点1,对比了i -\u003e j和i -\u003e 1 -\u003e j，第二次再加入对比节点2，由于是基于上一次结果计算，因此其实不仅对比了路径i -\u003e 2 -\u003e j，也对比了i -\u003e 1 -\u003e 2 -\u003e j和i -\u003e 2 -\u003e 1 -\u003e j，以此类推，所有路径全排列都参与了对比，因此是正确的 图1 floyd迭代过程 3.2 Johnson 解决带权有向图中所有节点对之间最短路径问题，尤其适用于图中 存在负权边但无负环 的场景;结合了 Bellman-Ford 和 Dijkstra 算法的优势，既保证了正确性又提高了效率\n注意一个问题，势函数优化后负环还是负环，势函数只能消除负边但是负环无法消除\n思路 预处理：通过 Bellman-Ford 算法引入虚拟节点，计算势函数（势能值），消除原图中的负权边 优化：利用势函数重新计算每条边的权重，使得所有边权非负 高效计算：对每个节点运行 Dijkstra 算法，得到所有节点对之间的最短路径 步骤 添加虚拟节点：在原图中添加一个虚拟节点（例如节点 0），并从该节点向所有其他节点连接一条权重为 0 的边 运行 Bellman-Ford：以虚拟节点为源点，使用 Bellman-Ford 算法计算到所有节点的最短路径，得到势函数 h[v] 重赋权边：对每条边 (u, v)，将其权重调整为 w'(u, v) = w(u, v) + h[u] - h[v]，确保所有边权非负 运行 Dijkstra：移除虚拟节点，对每个节点作为源点，运行 Dijkstra 算法计算最短路径 还原路径权重：将 Dijkstra 得到的路径权重通过公式 d(u, v) = d'(u, v) - h[u] + h[v] 还原为原图中的真实权重 ","wordCount":"267","inLanguage":"en","image":"https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-06-23T00:00:00Z","dateModified":"2025-06-23T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://duck-dd.github.io/posts/shortest-path/"},"publisher":{"@type":"Organization","name":"Duck","logo":{"@type":"ImageObject","url":"https://duck-dd.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://duck-dd.github.io/ accesskey=h title="首页 (Alt + H)"><img src=https://duck-dd.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://duck-dd.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://duck-dd.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://duck-dd.github.io/about_me title=关于我><span>关于我</span></a></li><li><a href=https://duck-dd.github.io/about_space title=关于这里><span>关于这里</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://duck-dd.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://duck-dd.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">The Shortest Path</h1><div class=post-meta><span title='2025-06-23 00:00:00 +0000 UTC'>2025-06-23</span>&nbsp;·&nbsp;创建于:&nbsp;2025-06-23&nbsp;·&nbsp;2 min&nbsp;·&nbsp;267 words<div class=meta-item>&nbsp·&nbsp
<a href=https://duck-dd.github.io/categories/cs/>CS</a></div><div class=meta-item>&nbsp·&nbsp
<a href=https://duck-dd.github.io/tags/algorithm/>Algorithm</a>
<span>,</span>
<a href=https://duck-dd.github.io/tags/2025/>2025</a></div></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98 aria-label=最短路径问题>最短路径问题</a><ul><li><a href=#1-%e6%97%a0%e6%9d%83%e5%9b%be%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84 aria-label="1 无权图最短路径">1 无权图最短路径</a></li><li><a href=#2-%e5%8d%95%e6%ba%90%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84sssp-single-source-shortest-paths aria-label="2 单源最短路径(SSSP, Single-Source Shortest Paths)">2 单源最短路径(SSSP, Single-Source Shortest Paths)</a><ul><li><a href=#21-dijkstra%e5%a0%86%e4%bc%98%e5%8c%96 aria-label="2.1 Dijkstra(堆优化)">2.1 Dijkstra(堆优化)</a></li><li><a href=#22-bellman-ford aria-label="2.2 Bellman-Ford">2.2 Bellman-Ford</a></li><li><a href=#23-spfa-shortest-path-faster-algorithm aria-label="2.3 SPFA, Shortest Path Faster Algorithm">2.3 SPFA, Shortest Path Faster Algorithm</a></li></ul></li><li><a href=#3-%e6%89%80%e6%9c%89%e7%82%b9%e5%af%b9%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84 aria-label="3 所有点对最短路径">3 所有点对最短路径</a><ul><li><a href=#31-floyd aria-label="3.1 Floyd">3.1 Floyd</a></li><li><a href=#32-johnson aria-label="3.2 Johnson">3.2 Johnson</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=最短路径问题>最短路径问题<a hidden class=anchor aria-hidden=true href=#最短路径问题>#</a></h1><p>寻找有向图中两个顶点之间的路径，使得 <code>路径最短</code> 或 <code>路径上各边的权重之和最小</code></p><h2 id=1-无权图最短路径>1 无权图最短路径<a hidden class=anchor aria-hidden=true href=#1-无权图最短路径>#</a></h2><p>所有边权重相同，最短路径退化为寻找两点间边数最少的路径，<code>BFS</code>搞定。</p><h2 id=2-单源最短路径sssp-single-source-shortest-paths>2 单源最短路径(SSSP, Single-Source Shortest Paths)<a hidden class=anchor aria-hidden=true href=#2-单源最短路径sssp-single-source-shortest-paths>#</a></h2><h3 id=21-dijkstra堆优化>2.1 Dijkstra(堆优化)<a hidden class=anchor aria-hidden=true href=#21-dijkstra堆优化>#</a></h3><ul><li>限制：边权非负</li><li>思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径</li><li>步骤<ul><li>初始化：<ul><li>源点<code>s</code>的距离为0，源点<code>s</code>一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞)</li><li>所有节点标记为未访问</li></ul></li><li>循环处理：<ul><li>从未访问节点中选择距离最小的节点<code>u</code>，标记为已访问</li><li>对<code>u</code>的每个邻接节点<code>v</code>，进行 <strong>松弛操作</strong>:<pre tabindex=0><code>if distance[v] &gt; distance[u] + weight(u, v):
    distance[v] = distance[u] + weight(u, v)
    predecessor[v] = u  # 记录路径
</code></pre></li></ul></li><li>终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点）</li></ul></li><li>优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为<code>O(logV)</code></li><li>记录路径：通过记录<code>前驱节点</code>可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序)</li><li>算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点</li></ul><h3 id=22-bellman-ford>2.2 Bellman-Ford<a hidden class=anchor aria-hidden=true href=#22-bellman-ford>#</a></h3><ul><li>限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小)</li><li>思路：通过 <strong>松弛操作</strong> 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边<code>(u, v)</code>，若从源点到<code>u</code>的距离 <code>dist[u]</code>加上边权<code>w(u, v)</code>小于当前到<code>v</code>的距离<code>dist[v]</code>，则更新<code>dist[v]</code></li><li>步骤<ul><li>初始化：源点距离<code>dist[source] = 0</code>，其他顶点距离<code>dist[v] = ∞</code></li><li>弛操作：对图中所有边进行<code>n-1</code>轮松弛（<code>n</code>为顶点数）；因为最短路径最多包含<code>n-1</code>条边(否则存在环，若为正权环可忽略，负权环则无法求解)</li><li>检测负权环：第<code>n</code>次松弛时，若仍能更新距离，则说明存在从源点可达的负权环</li></ul></li><li>优化：下面的SPFA</li><li>算法正确性理解：<code>n</code>个节点，那么起点到终点路径最长就是 <code>1->2->3->...->n</code> 最多有<code>n-1</code>跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代<code>x</code>轮，那么<code>x</code>跳能到达的节点的最短路径都会被优化完成，所以经过<code>n-1</code>轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成</li></ul><h3 id=23-spfa-shortest-path-faster-algorithm>2.3 SPFA, Shortest Path Faster Algorithm<a hidden class=anchor aria-hidden=true href=#23-spfa-shortest-path-faster-algorithm>#</a></h3><p>SPFA其实只是Bellman-Ford的筛选优化，本质相同</p><ul><li>思路：利用队列减少不必要的松弛操作，只有当一个顶点的距离被更新时，其邻接点才可能需要松弛，因此仅将更新过的顶点加入队列等待处理</li><li>优化本质：Bellman-Ford每次迭代都会遍历所有边，而SPFA只遍历 <strong>&ldquo;可能需要更新&rdquo;</strong> 的边，减少冗余操作</li><li>步骤<ul><li>初始化：源点距离<code>dist[source] = 0</code>，其他顶点<code>dist[v] = ∞</code>；队列初始加入源点，标记顶点是否在队列中（避免重复入队）</li><li>队列处理：<ul><li>取出队首顶点 u，遍历其所有邻接边 (u, v)。</li><li>若 <code>dist[u] + w(u, v) &lt; dist[v]</code>，则更新 <code>dist[v]</code></li><li>若 <code>v</code> 不在队列中，则将其入队，并标记；若已在队列中，可跳过（或优化为 “若距离减少较多，可提前入队”）</li></ul></li><li>检测负权环：记录每个顶点入队次数，若某顶点入队次数 ≥ n，则存在负权环（因为正常最短路径最多 <code>n-1</code> 条边，入队次数不会超过 <code>n-1</code>）</li></ul></li></ul><h2 id=3-所有点对最短路径>3 所有点对最短路径<a hidden class=anchor aria-hidden=true href=#3-所有点对最短路径>#</a></h2><h3 id=31-floyd>3.1 Floyd<a hidden class=anchor aria-hidden=true href=#31-floyd>#</a></h3><p>用于求解图中 <strong>所有顶点对之间最短路径</strong> 的动态规划算法，适用于带权图（包括有向图和无向图），且能处理负权边（无法处理负环）</p><ul><li>思路<ul><li>Floyd 算法通过 <strong>&ldquo;中间顶点&rdquo;</strong> 逐步优化最短路径，具体来说，对于图中任意两个顶点<code>i</code>和<code>j</code>，算法考虑 <strong>&ldquo;是否经过顶点k&rdquo;</strong> 来更新 <code>i -> j</code> 的最短路径：<ul><li>若 <code>i -> k -> j</code> 的路径比当前已知的 <code>i -> j</code> 路径更短，则更新最短路径长度</li><li>这里的 <code>k</code> 从所有顶点中依次选取，作为 <strong>&ldquo;中间顶点&rdquo;</strong> 进行尝试</li></ul></li></ul></li><li>步骤(图的顶点数为<code>n</code>，用邻接矩阵<code>dist</code>存储最短路径长度，其中<code>dist[i][j]</code>表示从顶点<code>i</code>到顶点<code>j</code>的最短路径长度)<ul><li>初始<ul><li>若<code>i = j</code>，则<code>dist[i][j] = 0</code></li><li>若顶点<code>i</code>和<code>j</code>直接相连，且边权为<code>w</code>，则<code>dist[i][j] = w</code></li><li>若顶点<code>i</code>和<code>j</code>不直接相连，则<code>dist[i][j] = ∞(无穷大)</code></li></ul></li><li>三重循环更新邻接矩阵<ul><li>外层循环：枚举中间顶点<code>k</code>（从 <code>0</code> 到 <code>n-1</code>）</li><li>中层循环：枚举起点<code>i</code>（从 <code>0</code> 到 <code>n-1</code>）</li><li>内层循环：枚举终点<code>j</code>（从 <code>0</code> 到 <code>n-1</code>）</li><li>更新规则：对于每个 <code>i, j, k</code>，判断是否通过<code>k</code>能缩短路径：<code>dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j])</code></li></ul></li></ul></li><li>记录路径：再开一个邻接矩阵，记录<code>i</code> <code>j</code>最短路径的绕行节点<code>k</code>，如果节点<code>k</code>存在，还需要递归查找 <code>i -> k</code> <code>k -> j</code>的绕行节点，直至找到完整路径</li><li>算法正确性理解：如图1，第一次绕行<code>节点1</code>,对比了<code>i -> j</code>和<code>i -> 1 -> j</code>，第二次再加入对比<code>节点2</code>，由于是基于上一次结果计算，因此其实不仅对比了路径<code>i -> 2 -> j</code>，也对比了<code>i -> 1 -> 2 -> j</code>和<code>i -> 2 -> 1 -> j</code>，以此类推，所有路径全排列都参与了对比，因此是正确的</li></ul><p><img alt="图1 floyd迭代过程" loading=lazy src=/images/shortest-path/floyd.png></p><center>图1 floyd迭代过程</center><h3 id=32-johnson>3.2 Johnson<a hidden class=anchor aria-hidden=true href=#32-johnson>#</a></h3><p>解决带权有向图中所有节点对之间最短路径问题，尤其适用于图中 <strong>存在负权边但无负环</strong> 的场景;结合了 Bellman-Ford 和 Dijkstra 算法的优势，既保证了正确性又提高了效率</p><p>注意一个问题，势函数优化后负环还是负环，势函数只能消除负边但是负环无法消除</p><ul><li>思路<ul><li>预处理：通过 Bellman-Ford 算法引入虚拟节点，计算势函数（势能值），消除原图中的负权边</li><li>优化：利用势函数重新计算每条边的权重，使得所有边权非负</li><li>高效计算：对每个节点运行 Dijkstra 算法，得到所有节点对之间的最短路径</li></ul></li><li>步骤<ul><li>添加虚拟节点：在原图中添加一个虚拟节点（例如节点 0），并从该节点向所有其他节点连接一条权重为 0 的边</li><li>运行 Bellman-Ford：以虚拟节点为源点，使用 Bellman-Ford 算法计算到所有节点的最短路径，得到势函数 <code>h[v]</code></li><li>重赋权边：对每条边 <code>(u, v)</code>，将其权重调整为 <code>w'(u, v) = w(u, v) + h[u] - h[v]</code>，确保所有边权非负</li><li>运行 Dijkstra：移除虚拟节点，对每个节点作为源点，运行 Dijkstra 算法计算最短路径</li><li>还原路径权重：将 Dijkstra 得到的路径权重通过公式 <code>d(u, v) = d'(u, v) - h[u] + h[v]</code> 还原为原图中的真实权重</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://duck-dd.github.io/tags/algorithm/>Algorithm</a></li><li><a href=https://duck-dd.github.io/tags/2025/>2025</a></li></ul><nav class=paginav><a class=prev href=https://duck-dd.github.io/posts/mcmf/><span class=title>« Prev</span><br><span>MCMF from scratch</span>
</a><a class=next href=https://duck-dd.github.io/posts/go-tips/><span class=title>Next »</span><br><span>go tips(持续更新)</span></a></nav></footer><script src=https://utteranc.es/client.js repo=duck-dd/blog-comment issue-term=pathname label='💬 Comments' theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://duck-dd.github.io/>Duck</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$",right:"$",display:!1},{left:"$$",right:"$$",display:!0}],throwOnError:!1})})</script></body></html>