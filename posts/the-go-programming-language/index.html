<!DOCTYPE html>
<html><head>
<title>The Go Programming Language</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">



<meta property="og:title" content="The Go Programming Language" />
<meta property="og:description" content="说明： 《The Go Programming Language》 所有源码见: gopl.io
 0 前言 GO演进，B-&gt;C-&gt;GO。
GO官方定位：Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。
0.1 GO语言起源 下图展示了有哪些早期语言对Go语言的设计产生了重要影响。 0.2 GO语言项目 Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。
Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。
Go语言源代码本身就包含了构建规范。
1 入门 把Go写的像Go。
1.1 Hello, World package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello, World&quot;) } Go是编译型语言，静态编译。
Go语言原生支持Unicode，可处理任何语言。
Go的工具都通过&quot;go&quot;命令调用，具体可&quot;go help&quot;。
Go语言通过包(package)组织。包引用使用&quot;import&quot;。
&ldquo;main&quot;包的&quot;main&quot;函数是这个程序执行的入口。
Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析。
1.2 命令行参数 Go区间索引左闭右开。 自增语句i&#43;&#43;给i加1；这和i &#43;= 1以及i = i &#43; 1都是等价的。对应的还有i&ndash;给i减1。它们是语句，而不像C系的其它语言那样是表达式。所以j = i&#43;&#43;非法，而且&#43;&#43;和&ndash;都只能放在变量名后面，因此&ndash;i也非法。
Go语言只有for循环这一种循环语句，for循环有多种形式。
// situation 1 for initialization; condition; post { // zero or more statements } // situation 2 // a traditional &quot;while&quot; loop for condition { // ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://duck-dd.github.io/posts/the-go-programming-language/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-25T22:35:37+08:00" />
<meta property="article:modified_time" content="2021-06-25T22:35:37+08:00" /><meta property="og:site_name" content="ZTQ&#39;s Blog" />






<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Go Programming Language"/>
<meta name="twitter:description" content="说明： 《The Go Programming Language》 所有源码见: gopl.io
 0 前言 GO演进，B-&gt;C-&gt;GO。
GO官方定位：Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。
0.1 GO语言起源 下图展示了有哪些早期语言对Go语言的设计产生了重要影响。 0.2 GO语言项目 Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。
Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。
Go语言源代码本身就包含了构建规范。
1 入门 把Go写的像Go。
1.1 Hello, World package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello, World&quot;) } Go是编译型语言，静态编译。
Go语言原生支持Unicode，可处理任何语言。
Go的工具都通过&quot;go&quot;命令调用，具体可&quot;go help&quot;。
Go语言通过包(package)组织。包引用使用&quot;import&quot;。
&ldquo;main&quot;包的&quot;main&quot;函数是这个程序执行的入口。
Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析。
1.2 命令行参数 Go区间索引左闭右开。 自增语句i&#43;&#43;给i加1；这和i &#43;= 1以及i = i &#43; 1都是等价的。对应的还有i&ndash;给i减1。它们是语句，而不像C系的其它语言那样是表达式。所以j = i&#43;&#43;非法，而且&#43;&#43;和&ndash;都只能放在变量名后面，因此&ndash;i也非法。
Go语言只有for循环这一种循环语句，for循环有多种形式。
// situation 1 for initialization; condition; post { // zero or more statements } // situation 2 // a traditional &quot;while&quot; loop for condition { // ."/>







<script src="/vendor/js/jquery.min.js" ></script>
<script src="/vendor/js/popper.min.js" ></script>
<script src="/vendor/js/bootstrap.min.js" ></script>
<script src="/vendor/js/smooth-scroll.polyfills.min.js" ></script>
<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>


  






<link rel="stylesheet" href="https://duck-dd.github.io/scss/journal.min.5e8f3f653e9f6ce67bf72ff8ee6fee69decf7b5639a3ae7f8344750ad4e065b1.css" integrity="sha256-Xo8/ZT6fbOZ79y/47m/uad7Pe1Y5o65/g0R1CtTgZbE=" media="screen">



<link rel="stylesheet" href="https://duck-dd.github.io/scss/dark-mode.min.bdfa63b2e89903517dcbb1032b537d54cff3f425c19d008a78dfe49e6cd07ced.css" integrity="sha256-vfpjsuiZA1F9y7EDK1N9VM/z9CXBnQCKeN/knmzQfO0=" media="screen">


<script src="/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");
</script>




  
    <script src="/js/toc-collapse.js"></script>
  



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/vendor/js/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
  clientID: '639d751c6c921e5529a0',
  clientSecret: '50b656593456becbb7f009b1f3a2271dcf55ce79',
  repo: 'duck-dd.github.io',
  owner: 'duck-dd',
  admin: ['duck-dd'],
  id: md5(location.pathname),
  distractionFreeMode: 'false'
  });
  window.onload = function () {
        gitalk.render('gitalk-container')
  }
</script>










</head>
<body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://duck-dd.github.io/">
    
        <div class="nav-title">
            Home Page
        </div>
        
        <div class="nav-subtitle">
            ZTQ&#39;s Space.
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/posts">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/about">
                About
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Songti SC'; color: #000000; -webkit-text-stroke: #000000}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #0000e3}
    span.s3 {font: 12.0px Times; font-kerning: none}
  </style>
</head>
<body>
<p class="p1"><span class="s1">Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary"><span class="s2">Diary</span></a> by <a href="https://amazingrise.net/"><span class="s2">Rise</span></a></span><span class="s2">.</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1">学艺不精, 委屈您的眼睛了</span><span class="s3"><br>
</span></p>
<p class="p1"><span class="s1">©  ztq. </span></p>
</body>
</html>

    </div>
    
</div><div ref="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#0-%e5%89%8d%e8%a8%80" onclick="onNavClick(`#0-前言-nav`)" id="0-前言-nav">
									0 前言
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#01-go%e8%af%ad%e8%a8%80%e8%b5%b7%e6%ba%90" onclick="onNavClick(`#01-go语言起源-nav`)" id="01-go语言起源-nav">
									0.1 GO语言起源
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#02-go%e8%af%ad%e8%a8%80%e9%a1%b9%e7%9b%ae" onclick="onNavClick(`#02-go语言项目-nav`)" id="02-go语言项目-nav">
									0.2 GO语言项目
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#1-%e5%85%a5%e9%97%a8" onclick="onNavClick(`#1-入门-nav`)" id="1-入门-nav">
									1 入门
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#11-hello-world" onclick="onNavClick(`#11-hello-world-nav`)" id="11-hello-world-nav">
									1.1 Hello, World
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#12-%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0" onclick="onNavClick(`#12-命令行参数-nav`)" id="12-命令行参数-nav">
									1.2 命令行参数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#13-%e6%9f%a5%e6%89%be%e9%87%8d%e5%a4%8d%e7%9a%84%e8%a1%8c" onclick="onNavClick(`#13-查找重复的行-nav`)" id="13-查找重复的行-nav">
									1.3 查找重复的行
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#14-gif%e5%8a%a8%e7%94%bb" onclick="onNavClick(`#14-gif动画-nav`)" id="14-gif动画-nav">
									1.4 GIF动画
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#15-%e8%8e%b7%e5%8f%96url" onclick="onNavClick(`#15-获取url-nav`)" id="15-获取url-nav">
									1.5 获取URL
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#16-%e5%b9%b6%e5%8f%91%e8%8e%b7%e5%8f%96%e5%a4%9a%e4%b8%aaurl" onclick="onNavClick(`#16-并发获取多个url-nav`)" id="16-并发获取多个url-nav">
									1.6 并发获取多个URL
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#17-web%e6%9c%8d%e5%8a%a1" onclick="onNavClick(`#17-web服务-nav`)" id="17-web服务-nav">
									1.7 Web服务
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#2-%e7%a8%8b%e5%ba%8f%e7%bb%93%e6%9e%84" onclick="onNavClick(`#2-程序结构-nav`)" id="2-程序结构-nav">
									2 程序结构
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#21-%e5%91%bd%e5%90%8d" onclick="onNavClick(`#21-命名-nav`)" id="21-命名-nav">
									2.1 命名
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#22-%e5%a3%b0%e6%98%8e" onclick="onNavClick(`#22-声明-nav`)" id="22-声明-nav">
									2.2 声明
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#23-%e5%8f%98%e9%87%8f" onclick="onNavClick(`#23-变量-nav`)" id="23-变量-nav">
									2.3 变量
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e7%ae%80%e7%9f%ad%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e" onclick="onNavClick(`#简短变量声明-nav`)" id="简短变量声明-nav">
									简短变量声明
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%8c%87%e9%92%88" onclick="onNavClick(`#指针-nav`)" id="指针-nav">
									指针
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#new%e5%87%bd%e6%95%b0" onclick="onNavClick(`#new函数-nav`)" id="new函数-nav">
									new函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" onclick="onNavClick(`#变量的生命周期-nav`)" id="变量的生命周期-nav">
									变量的生命周期
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#24-%e8%b5%8b%e5%80%bc" onclick="onNavClick(`#24-赋值-nav`)" id="24-赋值-nav">
									2.4 赋值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%8f%af%e8%b5%8b%e5%80%bc%e6%80%a7" onclick="onNavClick(`#可赋值性-nav`)" id="可赋值性-nav">
									可赋值性
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#25-%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#25-类型-nav`)" id="25-类型-nav">
									2.5 类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#26-%e5%8c%85%e5%92%8c%e6%96%87%e4%bb%b6" onclick="onNavClick(`#26-包和文件-nav`)" id="26-包和文件-nav">
									2.6 包和文件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%8c%85%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96" onclick="onNavClick(`#包的初始化-nav`)" id="包的初始化-nav">
									包的初始化
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#27-%e4%bd%9c%e7%94%a8%e5%9f%9f" onclick="onNavClick(`#27-作用域-nav`)" id="27-作用域-nav">
									2.7 作用域
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#3-%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#3-基础数据类型-nav`)" id="3-基础数据类型-nav">
									3 基础数据类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#31-%e6%95%b4%e5%9e%8b" onclick="onNavClick(`#31-整型-nav`)" id="31-整型-nav">
									3.1 整型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#32-%e6%b5%ae%e7%82%b9%e6%95%b0" onclick="onNavClick(`#32-浮点数-nav`)" id="32-浮点数-nav">
									3.2 浮点数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#33-%e5%a4%8d%e6%95%b0" onclick="onNavClick(`#33-复数-nav`)" id="33-复数-nav">
									3.3 复数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#34-%e5%b8%83%e5%b0%94%e5%9e%8b" onclick="onNavClick(`#34-布尔型-nav`)" id="34-布尔型-nav">
									3.4 布尔型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#35-%e5%ad%97%e7%ac%a6%e4%b8%b2" onclick="onNavClick(`#35-字符串-nav`)" id="35-字符串-nav">
									3.5 字符串
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%9d%a2%e5%80%bc" onclick="onNavClick(`#字符串面值-nav`)" id="字符串面值-nav">
									字符串面值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%92%8cbyte%e5%88%87%e7%89%87" onclick="onNavClick(`#字符串和byte切片-nav`)" id="字符串和byte切片-nav">
									字符串和byte切片
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#36-%e5%b8%b8%e9%87%8f" onclick="onNavClick(`#36-常量-nav`)" id="36-常量-nav">
									3.6 常量
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e6%97%a0%e7%b1%bb%e5%9e%8b%e5%b8%b8%e9%87%8f" onclick="onNavClick(`#无类型常量-nav`)" id="无类型常量-nav">
									无类型常量
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#4-%e5%a4%8d%e5%90%88%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#4-复合数据类型-nav`)" id="4-复合数据类型-nav">
									4 复合数据类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#41-%e6%95%b0%e7%bb%84" onclick="onNavClick(`#41-数组-nav`)" id="41-数组-nav">
									4.1 数组
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#42-slice" onclick="onNavClick(`#42-slice-nav`)" id="42-slice-nav">
									4.2 slice
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#append" onclick="onNavClick(`#append-nav`)" id="append-nav">
									append
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#43-map" onclick="onNavClick(`#43-map-nav`)" id="43-map-nav">
									4.3 map
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#44-%e7%bb%93%e6%9e%84%e4%bd%93" onclick="onNavClick(`#44-结构体-nav`)" id="44-结构体-nav">
									4.4 结构体
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#45-json" onclick="onNavClick(`#45-json-nav`)" id="45-json-nav">
									4.5 JSON
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#46-text-template--html-template" onclick="onNavClick(`#46-text-template--html-template-nav`)" id="46-text-template--html-template-nav">
									4.6 text template &amp; HTML template
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#text-template%e5%ae%9e%e4%be%8b" onclick="onNavClick(`#text-template实例-nav`)" id="text-template实例-nav">
									text template实例
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#html-template%e5%ae%9e%e4%be%8b" onclick="onNavClick(`#html-template实例-nav`)" id="html-template实例-nav">
									HTML template实例
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#5-%e5%87%bd%e6%95%b0" onclick="onNavClick(`#5-函数-nav`)" id="5-函数-nav">
									5 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#51-%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e" onclick="onNavClick(`#51-函数声明-nav`)" id="51-函数声明-nav">
									5.1 函数声明
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#52-%e9%80%92%e5%bd%92" onclick="onNavClick(`#52-递归-nav`)" id="52-递归-nav">
									5.2 递归
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#53-%e5%a4%9a%e8%bf%94%e5%9b%9e%e5%80%bc" onclick="onNavClick(`#53-多返回值-nav`)" id="53-多返回值-nav">
									5.3 多返回值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#54-%e9%94%99%e8%af%af" onclick="onNavClick(`#54-错误-nav`)" id="54-错误-nav">
									5.4 错误
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#55-%e5%87%bd%e6%95%b0%e5%80%bc" onclick="onNavClick(`#55-函数值-nav`)" id="55-函数值-nav">
									5.5 函数值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#56-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0" onclick="onNavClick(`#56-匿名函数-nav`)" id="56-匿名函数-nav">
									5.6 匿名函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#57-%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0" onclick="onNavClick(`#57-可变参数-nav`)" id="57-可变参数-nav">
									5.7 可变参数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#58-defer%e5%87%bd%e6%95%b0" onclick="onNavClick(`#58-defer函数-nav`)" id="58-defer函数-nav">
									5.8 defer函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#59-panic" onclick="onNavClick(`#59-panic-nav`)" id="59-panic-nav">
									5.9 panic
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#510-recover" onclick="onNavClick(`#510-recover-nav`)" id="510-recover-nav">
									5.10 recover
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#6-%e6%96%b9%e6%b3%95" onclick="onNavClick(`#6-方法-nav`)" id="6-方法-nav">
									6 方法
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#61-%e6%96%b9%e6%b3%95%e5%a3%b0%e6%98%8e" onclick="onNavClick(`#61-方法声明-nav`)" id="61-方法声明-nav">
									6.1 方法声明
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#62-%e5%9f%ba%e4%ba%8e%e6%8c%87%e9%92%88%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95" onclick="onNavClick(`#62-基于指针对象的方法-nav`)" id="62-基于指针对象的方法-nav">
									6.2 基于指针对象的方法
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#nil%e4%b9%9f%e6%98%af%e5%90%88%e6%b3%95%e7%9a%84%e6%8e%a5%e6%94%b6%e5%99%a8" onclick="onNavClick(`#nil也是合法的接收器-nav`)" id="nil也是合法的接收器-nav">
									nil也是合法的接收器
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#63-%e9%80%9a%e8%bf%87%e5%b5%8c%e5%85%a5%e7%bb%93%e6%9e%84%e4%bd%93%e6%9d%a5%e6%89%a9%e5%b1%95%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#63-通过嵌入结构体来扩展类型-nav`)" id="63-通过嵌入结构体来扩展类型-nav">
									6.3 通过嵌入结构体来扩展类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#64-%e6%96%b9%e6%b3%95%e5%80%bc%e5%92%8c%e6%96%b9%e6%b3%95%e8%a1%a8%e8%be%be%e5%bc%8f" onclick="onNavClick(`#64-方法值和方法表达式-nav`)" id="64-方法值和方法表达式-nav">
									6.4 方法值和方法表达式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#66-%e5%b0%81%e8%a3%85" onclick="onNavClick(`#66-封装-nav`)" id="66-封装-nav">
									6.6 封装
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#7-%e6%8e%a5%e5%8f%a3" onclick="onNavClick(`#7-接口-nav`)" id="7-接口-nav">
									7 接口
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#71-%e6%8e%a5%e5%8f%a3%e5%90%88%e7%ba%a6" onclick="onNavClick(`#71-接口合约-nav`)" id="71-接口合约-nav">
									7.1 接口==“合约”
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#72-%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#72-接口类型-nav`)" id="72-接口类型-nav">
									7.2 接口类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#73-%e5%ae%9e%e7%8e%b0%e6%8e%a5%e5%8f%a3%e7%9a%84%e6%9d%a1%e4%bb%b6" onclick="onNavClick(`#73-实现接口的条件-nav`)" id="73-实现接口的条件-nav">
									7.3 实现接口的条件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#75-%e6%8e%a5%e5%8f%a3%e5%80%bc" onclick="onNavClick(`#75-接口值-nav`)" id="75-接口值-nav">
									7.5 接口值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#710-%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80" onclick="onNavClick(`#710-类型断言-nav`)" id="710-类型断言-nav">
									7.10 类型断言
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#713-%e7%b1%bb%e5%9e%8b%e5%88%86%e6%94%af" onclick="onNavClick(`#713-类型分支-nav`)" id="713-类型分支-nav">
									7.13 类型分支
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#8-goroutine-%e5%92%8c-channel" onclick="onNavClick(`#8-goroutine-和-channel-nav`)" id="8-goroutine-和-channel-nav">
									8 goroutine 和 channel
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#81-goroutine" onclick="onNavClick(`#81-goroutine-nav`)" id="81-goroutine-nav">
									8.1 goroutine
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#82-channel" onclick="onNavClick(`#82-channel-nav`)" id="82-channel-nav">
									8.2 channel
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%8d%95%e6%96%b9%e5%90%91channeleg-chan--int-%e5%92%8c--chan-int" onclick="onNavClick(`#单方向channeleg-chan--int-和--chan-int-nav`)" id="单方向channeleg-chan--int-和--chan-int-nav">
									单方向channel(e.g. chan&lt;- int 和 &lt;-chan int)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e4%b8%8d%e5%b8%a6%e7%bc%93%e5%ad%98%e7%9a%84channel" onclick="onNavClick(`#不带缓存的channel-nav`)" id="不带缓存的channel-nav">
									不带缓存的channel
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%b8%a6%e7%bc%93%e5%ad%98%e7%9a%84channel" onclick="onNavClick(`#带缓存的channel-nav`)" id="带缓存的channel-nav">
									带缓存的channel
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#89-%e5%b9%b6%e5%8f%91%e7%9a%84%e9%80%80%e5%87%ba" onclick="onNavClick(`#89-并发的退出-nav`)" id="89-并发的退出-nav">
									8.9 并发的退出
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#9-%e5%9f%ba%e4%ba%8e%e5%85%b1%e4%ba%ab%e5%8f%98%e9%87%8f%e7%9a%84%e5%b9%b6%e5%8f%91" onclick="onNavClick(`#9-基于共享变量的并发-nav`)" id="9-基于共享变量的并发-nav">
									9 基于共享变量的并发
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#91-%e7%ab%9e%e4%ba%89%e6%9d%a1%e4%bb%b6" onclick="onNavClick(`#91-竞争条件-nav`)" id="91-竞争条件-nav">
									9.1 竞争条件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#92-syncmutex" onclick="onNavClick(`#92-syncmutex-nav`)" id="92-syncmutex-nav">
									9.2 sync.Mutex
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#93-syncrwmutex" onclick="onNavClick(`#93-syncrwmutex-nav`)" id="93-syncrwmutex-nav">
									9.3 sync.RWMutex
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#94-%e5%86%85%e5%ad%98%e5%90%8c%e6%ad%a5" onclick="onNavClick(`#94-内存同步-nav`)" id="94-内存同步-nav">
									9.4 内存同步
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#95-synconce%e6%83%b0%e6%80%a7%e5%88%9d%e5%a7%8b%e5%8c%96" onclick="onNavClick(`#95-synconce惰性初始化-nav`)" id="95-synconce惰性初始化-nav">
									9.5 sync.Once惰性初始化
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#96-golang-race-detector" onclick="onNavClick(`#96-golang-race-detector-nav`)" id="96-golang-race-detector-nav">
									9.6 Golang Race Detector
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#98-goroutine-%e5%92%8c-%e7%ba%bf%e7%a8%8b" onclick="onNavClick(`#98-goroutine-和-线程-nav`)" id="98-goroutine-和-线程-nav">
									9.8 goroutine 和 线程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%8a%a8%e6%80%81%e6%a0%88" onclick="onNavClick(`#动态栈-nav`)" id="动态栈-nav">
									动态栈
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#gouroutine%e8%b0%83%e5%ba%a6" onclick="onNavClick(`#gouroutine调度-nav`)" id="gouroutine调度-nav">
									gouroutine调度
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#gomaxprocs" onclick="onNavClick(`#gomaxprocs-nav`)" id="gomaxprocs-nav">
									GOMAXPROCS
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#goroutine%e6%b2%a1%e6%9c%89id%e5%8f%b7" onclick="onNavClick(`#goroutine没有id号-nav`)" id="goroutine没有id号-nav">
									goroutine没有ID号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#10-%e5%8c%85%e5%92%8c%e5%b7%a5%e5%85%b7" onclick="onNavClick(`#10-包和工具-nav`)" id="10-包和工具-nav">
									10 包和工具
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#107-golang%e5%b7%a5%e5%85%b7" onclick="onNavClick(`#107-golang工具-nav`)" id="107-golang工具-nav">
									10.7 Golang工具
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#11-%e6%b5%8b%e8%af%95" onclick="onNavClick(`#11-测试-nav`)" id="11-测试-nav">
									11 测试
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#12-%e5%8f%8d%e5%b0%84" onclick="onNavClick(`#12-反射-nav`)" id="12-反射-nav">
									12 反射
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#122-reflecttype%e5%92%8creflectvalue" onclick="onNavClick(`#122-reflecttype和reflectvalue-nav`)" id="122-reflecttype和reflectvalue-nav">
									12.2 reflect.Type和reflect.Value
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#123-%e9%80%9a%e8%bf%87reflectvalue%e4%bf%ae%e6%94%b9%e5%80%bc" onclick="onNavClick(`#123-通过reflectvalue修改值-nav`)" id="123-通过reflectvalue修改值-nav">
									12.3 通过reflect.Value修改值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#127-%e8%8e%b7%e5%8f%96%e7%bb%93%e6%9e%84%e4%bd%93%e5%ad%97%e6%ae%b5%e6%a0%87%e7%ad%be" onclick="onNavClick(`#127-获取结构体字段标签-nav`)" id="127-获取结构体字段标签-nav">
									12.7 获取结构体字段标签
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#128-%e6%98%be%e7%a4%ba%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%96%b9%e6%b3%95%e9%9b%86" onclick="onNavClick(`#128-显示一个类型的方法集-nav`)" id="128-显示一个类型的方法集-nav">
									12.8 显示一个类型的方法集
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#129-%e5%85%b3%e4%ba%8ereflect%e7%9a%84%e5%87%a0%e7%82%b9%e5%bf%a0%e5%91%8a" onclick="onNavClick(`#129-关于reflect的几点忠告-nav`)" id="129-关于reflect的几点忠告-nav">
									12.9 关于reflect的几点忠告
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#13-%e5%ba%95%e5%b1%82%e7%bc%96%e7%a8%8b" onclick="onNavClick(`#13-底层编程-nav`)" id="13-底层编程-nav">
									13 底层编程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#131-unsafe-sizeof-alignof-offsetof" onclick="onNavClick(`#131-unsafe-sizeof-alignof-offsetof-nav`)" id="131-unsafe-sizeof-alignof-offsetof-nav">
									13.1 unsafe: Sizeof, Alignof, Offsetof
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#132-unsafepointer" onclick="onNavClick(`#132-unsafepointer-nav`)" id="132-unsafepointer-nav">
									13.2 unsafe.Pointer
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#134-%e9%80%9a%e8%bf%87cgo%e8%b0%83%e7%94%a8c%e4%bb%a3%e7%a0%81" onclick="onNavClick(`#134-通过cgo调用c代码-nav`)" id="134-通过cgo调用c代码-nav">
									13.4 通过cgo调用C代码
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#135-%e5%bf%a0%e5%91%8a" onclick="onNavClick(`#135-忠告-nav`)" id="135-忠告-nav">
									13.5 忠告
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a class="pagination-action" v-on:click="toggleDarkMode">
            <i class="material-icons pagination-action-icon" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons pagination-action-icon" v-else="isDarkMode">
                brightness_7
            </i>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/posts">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/about">
                    About
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#0-%e5%89%8d%e8%a8%80" onclick="onNavClick(`#0-前言-nav`)" id="0-前言-nav">
									0 前言
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#01-go%e8%af%ad%e8%a8%80%e8%b5%b7%e6%ba%90" onclick="onNavClick(`#01-go语言起源-nav`)" id="01-go语言起源-nav">
									0.1 GO语言起源
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#02-go%e8%af%ad%e8%a8%80%e9%a1%b9%e7%9b%ae" onclick="onNavClick(`#02-go语言项目-nav`)" id="02-go语言项目-nav">
									0.2 GO语言项目
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#1-%e5%85%a5%e9%97%a8" onclick="onNavClick(`#1-入门-nav`)" id="1-入门-nav">
									1 入门
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#11-hello-world" onclick="onNavClick(`#11-hello-world-nav`)" id="11-hello-world-nav">
									1.1 Hello, World
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#12-%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0" onclick="onNavClick(`#12-命令行参数-nav`)" id="12-命令行参数-nav">
									1.2 命令行参数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#13-%e6%9f%a5%e6%89%be%e9%87%8d%e5%a4%8d%e7%9a%84%e8%a1%8c" onclick="onNavClick(`#13-查找重复的行-nav`)" id="13-查找重复的行-nav">
									1.3 查找重复的行
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#14-gif%e5%8a%a8%e7%94%bb" onclick="onNavClick(`#14-gif动画-nav`)" id="14-gif动画-nav">
									1.4 GIF动画
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#15-%e8%8e%b7%e5%8f%96url" onclick="onNavClick(`#15-获取url-nav`)" id="15-获取url-nav">
									1.5 获取URL
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#16-%e5%b9%b6%e5%8f%91%e8%8e%b7%e5%8f%96%e5%a4%9a%e4%b8%aaurl" onclick="onNavClick(`#16-并发获取多个url-nav`)" id="16-并发获取多个url-nav">
									1.6 并发获取多个URL
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#17-web%e6%9c%8d%e5%8a%a1" onclick="onNavClick(`#17-web服务-nav`)" id="17-web服务-nav">
									1.7 Web服务
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#2-%e7%a8%8b%e5%ba%8f%e7%bb%93%e6%9e%84" onclick="onNavClick(`#2-程序结构-nav`)" id="2-程序结构-nav">
									2 程序结构
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#21-%e5%91%bd%e5%90%8d" onclick="onNavClick(`#21-命名-nav`)" id="21-命名-nav">
									2.1 命名
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#22-%e5%a3%b0%e6%98%8e" onclick="onNavClick(`#22-声明-nav`)" id="22-声明-nav">
									2.2 声明
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#23-%e5%8f%98%e9%87%8f" onclick="onNavClick(`#23-变量-nav`)" id="23-变量-nav">
									2.3 变量
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e7%ae%80%e7%9f%ad%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e" onclick="onNavClick(`#简短变量声明-nav`)" id="简短变量声明-nav">
									简短变量声明
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%8c%87%e9%92%88" onclick="onNavClick(`#指针-nav`)" id="指针-nav">
									指针
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#new%e5%87%bd%e6%95%b0" onclick="onNavClick(`#new函数-nav`)" id="new函数-nav">
									new函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%8f%98%e9%87%8f%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" onclick="onNavClick(`#变量的生命周期-nav`)" id="变量的生命周期-nav">
									变量的生命周期
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#24-%e8%b5%8b%e5%80%bc" onclick="onNavClick(`#24-赋值-nav`)" id="24-赋值-nav">
									2.4 赋值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%8f%af%e8%b5%8b%e5%80%bc%e6%80%a7" onclick="onNavClick(`#可赋值性-nav`)" id="可赋值性-nav">
									可赋值性
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#25-%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#25-类型-nav`)" id="25-类型-nav">
									2.5 类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#26-%e5%8c%85%e5%92%8c%e6%96%87%e4%bb%b6" onclick="onNavClick(`#26-包和文件-nav`)" id="26-包和文件-nav">
									2.6 包和文件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%8c%85%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96" onclick="onNavClick(`#包的初始化-nav`)" id="包的初始化-nav">
									包的初始化
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#27-%e4%bd%9c%e7%94%a8%e5%9f%9f" onclick="onNavClick(`#27-作用域-nav`)" id="27-作用域-nav">
									2.7 作用域
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#3-%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#3-基础数据类型-nav`)" id="3-基础数据类型-nav">
									3 基础数据类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#31-%e6%95%b4%e5%9e%8b" onclick="onNavClick(`#31-整型-nav`)" id="31-整型-nav">
									3.1 整型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#32-%e6%b5%ae%e7%82%b9%e6%95%b0" onclick="onNavClick(`#32-浮点数-nav`)" id="32-浮点数-nav">
									3.2 浮点数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#33-%e5%a4%8d%e6%95%b0" onclick="onNavClick(`#33-复数-nav`)" id="33-复数-nav">
									3.3 复数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#34-%e5%b8%83%e5%b0%94%e5%9e%8b" onclick="onNavClick(`#34-布尔型-nav`)" id="34-布尔型-nav">
									3.4 布尔型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#35-%e5%ad%97%e7%ac%a6%e4%b8%b2" onclick="onNavClick(`#35-字符串-nav`)" id="35-字符串-nav">
									3.5 字符串
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%9d%a2%e5%80%bc" onclick="onNavClick(`#字符串面值-nav`)" id="字符串面值-nav">
									字符串面值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%92%8cbyte%e5%88%87%e7%89%87" onclick="onNavClick(`#字符串和byte切片-nav`)" id="字符串和byte切片-nav">
									字符串和byte切片
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#36-%e5%b8%b8%e9%87%8f" onclick="onNavClick(`#36-常量-nav`)" id="36-常量-nav">
									3.6 常量
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e6%97%a0%e7%b1%bb%e5%9e%8b%e5%b8%b8%e9%87%8f" onclick="onNavClick(`#无类型常量-nav`)" id="无类型常量-nav">
									无类型常量
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#4-%e5%a4%8d%e5%90%88%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#4-复合数据类型-nav`)" id="4-复合数据类型-nav">
									4 复合数据类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#41-%e6%95%b0%e7%bb%84" onclick="onNavClick(`#41-数组-nav`)" id="41-数组-nav">
									4.1 数组
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#42-slice" onclick="onNavClick(`#42-slice-nav`)" id="42-slice-nav">
									4.2 slice
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#append" onclick="onNavClick(`#append-nav`)" id="append-nav">
									append
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#43-map" onclick="onNavClick(`#43-map-nav`)" id="43-map-nav">
									4.3 map
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#44-%e7%bb%93%e6%9e%84%e4%bd%93" onclick="onNavClick(`#44-结构体-nav`)" id="44-结构体-nav">
									4.4 结构体
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#45-json" onclick="onNavClick(`#45-json-nav`)" id="45-json-nav">
									4.5 JSON
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#46-text-template--html-template" onclick="onNavClick(`#46-text-template--html-template-nav`)" id="46-text-template--html-template-nav">
									4.6 text template &amp; HTML template
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#text-template%e5%ae%9e%e4%be%8b" onclick="onNavClick(`#text-template实例-nav`)" id="text-template实例-nav">
									text template实例
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#html-template%e5%ae%9e%e4%be%8b" onclick="onNavClick(`#html-template实例-nav`)" id="html-template实例-nav">
									HTML template实例
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#5-%e5%87%bd%e6%95%b0" onclick="onNavClick(`#5-函数-nav`)" id="5-函数-nav">
									5 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#51-%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e" onclick="onNavClick(`#51-函数声明-nav`)" id="51-函数声明-nav">
									5.1 函数声明
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#52-%e9%80%92%e5%bd%92" onclick="onNavClick(`#52-递归-nav`)" id="52-递归-nav">
									5.2 递归
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#53-%e5%a4%9a%e8%bf%94%e5%9b%9e%e5%80%bc" onclick="onNavClick(`#53-多返回值-nav`)" id="53-多返回值-nav">
									5.3 多返回值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#54-%e9%94%99%e8%af%af" onclick="onNavClick(`#54-错误-nav`)" id="54-错误-nav">
									5.4 错误
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#55-%e5%87%bd%e6%95%b0%e5%80%bc" onclick="onNavClick(`#55-函数值-nav`)" id="55-函数值-nav">
									5.5 函数值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#56-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0" onclick="onNavClick(`#56-匿名函数-nav`)" id="56-匿名函数-nav">
									5.6 匿名函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#57-%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0" onclick="onNavClick(`#57-可变参数-nav`)" id="57-可变参数-nav">
									5.7 可变参数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#58-defer%e5%87%bd%e6%95%b0" onclick="onNavClick(`#58-defer函数-nav`)" id="58-defer函数-nav">
									5.8 defer函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#59-panic" onclick="onNavClick(`#59-panic-nav`)" id="59-panic-nav">
									5.9 panic
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#510-recover" onclick="onNavClick(`#510-recover-nav`)" id="510-recover-nav">
									5.10 recover
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#6-%e6%96%b9%e6%b3%95" onclick="onNavClick(`#6-方法-nav`)" id="6-方法-nav">
									6 方法
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#61-%e6%96%b9%e6%b3%95%e5%a3%b0%e6%98%8e" onclick="onNavClick(`#61-方法声明-nav`)" id="61-方法声明-nav">
									6.1 方法声明
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#62-%e5%9f%ba%e4%ba%8e%e6%8c%87%e9%92%88%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95" onclick="onNavClick(`#62-基于指针对象的方法-nav`)" id="62-基于指针对象的方法-nav">
									6.2 基于指针对象的方法
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#nil%e4%b9%9f%e6%98%af%e5%90%88%e6%b3%95%e7%9a%84%e6%8e%a5%e6%94%b6%e5%99%a8" onclick="onNavClick(`#nil也是合法的接收器-nav`)" id="nil也是合法的接收器-nav">
									nil也是合法的接收器
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#63-%e9%80%9a%e8%bf%87%e5%b5%8c%e5%85%a5%e7%bb%93%e6%9e%84%e4%bd%93%e6%9d%a5%e6%89%a9%e5%b1%95%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#63-通过嵌入结构体来扩展类型-nav`)" id="63-通过嵌入结构体来扩展类型-nav">
									6.3 通过嵌入结构体来扩展类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#64-%e6%96%b9%e6%b3%95%e5%80%bc%e5%92%8c%e6%96%b9%e6%b3%95%e8%a1%a8%e8%be%be%e5%bc%8f" onclick="onNavClick(`#64-方法值和方法表达式-nav`)" id="64-方法值和方法表达式-nav">
									6.4 方法值和方法表达式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#66-%e5%b0%81%e8%a3%85" onclick="onNavClick(`#66-封装-nav`)" id="66-封装-nav">
									6.6 封装
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#7-%e6%8e%a5%e5%8f%a3" onclick="onNavClick(`#7-接口-nav`)" id="7-接口-nav">
									7 接口
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#71-%e6%8e%a5%e5%8f%a3%e5%90%88%e7%ba%a6" onclick="onNavClick(`#71-接口合约-nav`)" id="71-接口合约-nav">
									7.1 接口==“合约”
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#72-%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b" onclick="onNavClick(`#72-接口类型-nav`)" id="72-接口类型-nav">
									7.2 接口类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#73-%e5%ae%9e%e7%8e%b0%e6%8e%a5%e5%8f%a3%e7%9a%84%e6%9d%a1%e4%bb%b6" onclick="onNavClick(`#73-实现接口的条件-nav`)" id="73-实现接口的条件-nav">
									7.3 实现接口的条件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#75-%e6%8e%a5%e5%8f%a3%e5%80%bc" onclick="onNavClick(`#75-接口值-nav`)" id="75-接口值-nav">
									7.5 接口值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#710-%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80" onclick="onNavClick(`#710-类型断言-nav`)" id="710-类型断言-nav">
									7.10 类型断言
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#713-%e7%b1%bb%e5%9e%8b%e5%88%86%e6%94%af" onclick="onNavClick(`#713-类型分支-nav`)" id="713-类型分支-nav">
									7.13 类型分支
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#8-goroutine-%e5%92%8c-channel" onclick="onNavClick(`#8-goroutine-和-channel-nav`)" id="8-goroutine-和-channel-nav">
									8 goroutine 和 channel
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#81-goroutine" onclick="onNavClick(`#81-goroutine-nav`)" id="81-goroutine-nav">
									8.1 goroutine
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#82-channel" onclick="onNavClick(`#82-channel-nav`)" id="82-channel-nav">
									8.2 channel
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%8d%95%e6%96%b9%e5%90%91channeleg-chan--int-%e5%92%8c--chan-int" onclick="onNavClick(`#单方向channeleg-chan--int-和--chan-int-nav`)" id="单方向channeleg-chan--int-和--chan-int-nav">
									单方向channel(e.g. chan&lt;- int 和 &lt;-chan int)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e4%b8%8d%e5%b8%a6%e7%bc%93%e5%ad%98%e7%9a%84channel" onclick="onNavClick(`#不带缓存的channel-nav`)" id="不带缓存的channel-nav">
									不带缓存的channel
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%b8%a6%e7%bc%93%e5%ad%98%e7%9a%84channel" onclick="onNavClick(`#带缓存的channel-nav`)" id="带缓存的channel-nav">
									带缓存的channel
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#89-%e5%b9%b6%e5%8f%91%e7%9a%84%e9%80%80%e5%87%ba" onclick="onNavClick(`#89-并发的退出-nav`)" id="89-并发的退出-nav">
									8.9 并发的退出
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#9-%e5%9f%ba%e4%ba%8e%e5%85%b1%e4%ba%ab%e5%8f%98%e9%87%8f%e7%9a%84%e5%b9%b6%e5%8f%91" onclick="onNavClick(`#9-基于共享变量的并发-nav`)" id="9-基于共享变量的并发-nav">
									9 基于共享变量的并发
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#91-%e7%ab%9e%e4%ba%89%e6%9d%a1%e4%bb%b6" onclick="onNavClick(`#91-竞争条件-nav`)" id="91-竞争条件-nav">
									9.1 竞争条件
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#92-syncmutex" onclick="onNavClick(`#92-syncmutex-nav`)" id="92-syncmutex-nav">
									9.2 sync.Mutex
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#93-syncrwmutex" onclick="onNavClick(`#93-syncrwmutex-nav`)" id="93-syncrwmutex-nav">
									9.3 sync.RWMutex
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#94-%e5%86%85%e5%ad%98%e5%90%8c%e6%ad%a5" onclick="onNavClick(`#94-内存同步-nav`)" id="94-内存同步-nav">
									9.4 内存同步
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#95-synconce%e6%83%b0%e6%80%a7%e5%88%9d%e5%a7%8b%e5%8c%96" onclick="onNavClick(`#95-synconce惰性初始化-nav`)" id="95-synconce惰性初始化-nav">
									9.5 sync.Once惰性初始化
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#96-golang-race-detector" onclick="onNavClick(`#96-golang-race-detector-nav`)" id="96-golang-race-detector-nav">
									9.6 Golang Race Detector
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#98-goroutine-%e5%92%8c-%e7%ba%bf%e7%a8%8b" onclick="onNavClick(`#98-goroutine-和-线程-nav`)" id="98-goroutine-和-线程-nav">
									9.8 goroutine 和 线程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e5%8a%a8%e6%80%81%e6%a0%88" onclick="onNavClick(`#动态栈-nav`)" id="动态栈-nav">
									动态栈
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#gouroutine%e8%b0%83%e5%ba%a6" onclick="onNavClick(`#gouroutine调度-nav`)" id="gouroutine调度-nav">
									gouroutine调度
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#gomaxprocs" onclick="onNavClick(`#gomaxprocs-nav`)" id="gomaxprocs-nav">
									GOMAXPROCS
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#goroutine%e6%b2%a1%e6%9c%89id%e5%8f%b7" onclick="onNavClick(`#goroutine没有id号-nav`)" id="goroutine没有id号-nav">
									goroutine没有ID号
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#10-%e5%8c%85%e5%92%8c%e5%b7%a5%e5%85%b7" onclick="onNavClick(`#10-包和工具-nav`)" id="10-包和工具-nav">
									10 包和工具
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#107-golang%e5%b7%a5%e5%85%b7" onclick="onNavClick(`#107-golang工具-nav`)" id="107-golang工具-nav">
									10.7 Golang工具
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#11-%e6%b5%8b%e8%af%95" onclick="onNavClick(`#11-测试-nav`)" id="11-测试-nav">
									11 测试
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#12-%e5%8f%8d%e5%b0%84" onclick="onNavClick(`#12-反射-nav`)" id="12-反射-nav">
									12 反射
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#122-reflecttype%e5%92%8creflectvalue" onclick="onNavClick(`#122-reflecttype和reflectvalue-nav`)" id="122-reflecttype和reflectvalue-nav">
									12.2 reflect.Type和reflect.Value
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#123-%e9%80%9a%e8%bf%87reflectvalue%e4%bf%ae%e6%94%b9%e5%80%bc" onclick="onNavClick(`#123-通过reflectvalue修改值-nav`)" id="123-通过reflectvalue修改值-nav">
									12.3 通过reflect.Value修改值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#127-%e8%8e%b7%e5%8f%96%e7%bb%93%e6%9e%84%e4%bd%93%e5%ad%97%e6%ae%b5%e6%a0%87%e7%ad%be" onclick="onNavClick(`#127-获取结构体字段标签-nav`)" id="127-获取结构体字段标签-nav">
									12.7 获取结构体字段标签
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#128-%e6%98%be%e7%a4%ba%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%96%b9%e6%b3%95%e9%9b%86" onclick="onNavClick(`#128-显示一个类型的方法集-nav`)" id="128-显示一个类型的方法集-nav">
									12.8 显示一个类型的方法集
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#129-%e5%85%b3%e4%ba%8ereflect%e7%9a%84%e5%87%a0%e7%82%b9%e5%bf%a0%e5%91%8a" onclick="onNavClick(`#129-关于reflect的几点忠告-nav`)" id="129-关于reflect的几点忠告-nav">
									12.9 关于reflect的几点忠告
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#13-%e5%ba%95%e5%b1%82%e7%bc%96%e7%a8%8b" onclick="onNavClick(`#13-底层编程-nav`)" id="13-底层编程-nav">
									13 底层编程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#131-unsafe-sizeof-alignof-offsetof" onclick="onNavClick(`#131-unsafe-sizeof-alignof-offsetof-nav`)" id="131-unsafe-sizeof-alignof-offsetof-nav">
									13.1 unsafe: Sizeof, Alignof, Offsetof
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#132-unsafepointer" onclick="onNavClick(`#132-unsafepointer-nav`)" id="132-unsafepointer-nav">
									13.2 unsafe.Pointer
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#134-%e9%80%9a%e8%bf%87cgo%e8%b0%83%e7%94%a8c%e4%bb%a3%e7%a0%81" onclick="onNavClick(`#134-通过cgo调用c代码-nav`)" id="134-通过cgo调用c代码-nav">
									13.4 通过cgo调用C代码
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#135-%e5%bf%a0%e5%91%8a" onclick="onNavClick(`#135-忠告-nav`)" id="135-忠告-nav">
									13.5 忠告
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="https://duck-dd.github.io/">
            Home Page
        </a>
        
        <button type="button" class="nav-darkmode-toggle" v-on:click="toggleDarkMode">
            <i class="material-icons" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons" v-else="isDarkMode">
                brightness_7
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://duck-dd.github.io/">
        <div class="single-column-header-title">Home Page</div>
        
        <div class="single-column-header-subtitle">ZTQ&#39;s Space.</div>
        

    </a>
</div>

            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                
            >
                <div class="post-title">
                    The Go Programming Language
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2021-06-25 22:35
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/cs">CS</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">读书笔记</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <p>说明：
《The Go Programming Language》
所有源码见: <a href="https://github.com/adonovan/gopl.io">gopl.io</a></p>
<hr>
<h1 id="0-前言">0 前言</h1>
<p>GO演进，B-&gt;C-&gt;GO。</p>
<p>GO官方定位：Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。</p>
<h2 id="01-go语言起源">0.1 GO语言起源</h2>
<p>下图展示了有哪些早期语言对Go语言的设计产生了重要影响。
<img src="/images/The-Go-Programming-Language/go-origin.png" alt="gpl-01"></p>
<h2 id="02-go语言项目">0.2 GO语言项目</h2>
<p>Go语言的<strong>动态栈</strong>使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。</p>
<p>Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。</p>
<p>Go语言源代码本身就包含了构建规范。</p>
<h1 id="1-入门">1 入门</h1>
<p>把Go写的像Go。</p>
<h2 id="11-hello-world">1.1 Hello, World</h2>
<pre><code>package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello, World&quot;)
}
</code></pre><p>Go是编译型语言，静态编译。</p>
<p>Go语言原生支持Unicode，可处理任何语言。</p>
<p>Go的工具都通过&quot;go&quot;命令调用，具体可&quot;go help&quot;。</p>
<p>Go语言通过包(package)组织。包引用使用&quot;import&quot;。</p>
<p>&ldquo;main&quot;包的&quot;main&quot;函数是这个程序执行的入口。</p>
<p>Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析。</p>
<h2 id="12-命令行参数">1.2 命令行参数</h2>
<p>Go区间索引左闭右开。
自增语句i++给i加1；这和i += 1以及i = i + 1都是等价的。对应的还有i&ndash;给i减1。它们是语句，而不像C系的其它语言那样是表达式。所以j = i++非法，而且++和&ndash;都只能放在变量名后面，因此&ndash;i也非法。</p>
<p>Go语言只有for循环这一种循环语句，for循环有多种形式。</p>
<pre><code>// situation 1
for initialization; condition; post {
    // zero or more statements
}

// situation 2
// a traditional &quot;while&quot; loop
for condition {
    // ...
}

// situation 3
// a traditional infinite loop
for {
    // ...
}

// situation 4
for index, value := range someSlice {
    // ...
}
</code></pre><p>声明一个变量有几种方式，如下：</p>
<pre><code>s := &quot;&quot;
var s string
var s = &quot;&quot;
var s string = &quot;&quot;
</code></pre><p>用哪种不用哪种，为什么呢？第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为&rdquo;&quot;。第三种形式用得很少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。</p>
<h2 id="13-查找重复的行">1.3 查找重复的行</h2>
<pre><code>// Dup1 prints the text of each line that appears more than
// once in the standard input, preceded by its count.
package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    counts := make(map[string]int)
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        // map中不含某个键时不用担心，首次读到新行时，等号右边的表达式counts[line]的值将被计算为其类型的零值，对于int即0
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
    for line, n := range counts {
        // map的迭代顺序并不确定，从实践来看，该顺序随机，每次运行都会变化
        if n &gt; 1 {
            fmt.Printf(&quot;%d\t%s\n&quot;, n, line)
        }
    }
}
</code></pre><pre><code>// Dup2 prints the count and text of lines that appear more than once
// in the input.  It reads from stdin or from a list of named files.
package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    counts := make(map[string]int)
    files := os.Args[1:]
    if len(files) == 0 {
        countLines(os.Stdin, counts)
    } else {
        for _, arg := range files {
            f, err := os.Open(arg)
            if err != nil {
                fmt.Fprintf(os.Stderr, &quot;dup2: %v\n&quot;, err)
                continue
            }
            countLines(f, counts)
            f.Close()
        }
    }
    for line, n := range counts {
        if n &gt; 1 {
            fmt.Printf(&quot;%d\t%s\n&quot;, n, line)
        }
    }
}

func countLines(f *os.File, counts map[string]int) {
    input := bufio.NewScanner(f)
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
}
</code></pre><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

func main() {
    counts := make(map[string]int)
    for _, filename := range os.Args[1:] {
        data, err := ioutil.ReadFile(filename)
        if err != nil {
            fmt.Fprintf(os.Stderr, &quot;dup3: %v\n&quot;, err)
            continue
        }
        for _, line := range strings.Split(string(data), &quot;\n&quot;) {
            counts[line]++
        }
    }
    for line, n := range counts {
        if n &gt; 1 {
            fmt.Printf(&quot;%d\t%s\n&quot;, n, line)
        }
    }
}
</code></pre><h2 id="14-gif动画">1.4 GIF动画</h2>
<pre><code>// Lissajous generates GIF animations of random Lissajous figures.
package main

import (
    &quot;image&quot;
    &quot;image/color&quot;
    &quot;image/gif&quot;
    &quot;io&quot;
    &quot;math&quot;
    &quot;math/rand&quot;
    &quot;os&quot;
)

var palette = []color.Color{color.White, color.Black}

const (
    whiteIndex = 0 // first color in palette
    blackIndex = 1 // next color in palette
)

func main() {
    // The sequence of images is deterministic unless we seed
    // the pseudo-random number generator using the current time.
    // Thanks to Randall McPherson for pointing out the omission.
    rand.Seed(time.Now().UTC().UnixNano())
    lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
    const (
        cycles  = 5     // number of complete x oscillator revolutions
        res     = 0.001 // angular resolution
        size    = 100   // image canvas covers [-size..+size]
        nframes = 64    // number of animation frames
        delay   = 8     // delay between frames in 10ms units
    )

    freq := rand.Float64() * 3.0 // relative frequency of y oscillator
    anim := gif.GIF{LoopCount: nframes}
    phase := 0.0 // phase difference
    for i := 0; i &lt; nframes; i++ {
        rect := image.Rect(0, 0, 2*size+1, 2*size+1)
        img := image.NewPaletted(rect, palette)
        for t := 0.0; t &lt; cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
                blackIndex)
        }
        phase += 0.1
        anim.Delay = append(anim.Delay, delay)
        anim.Image = append(anim.Image, img)
    }
    gif.EncodeAll(out, &amp;anim) // NOTE: ignoring encoding errors
}
</code></pre><h2 id="15-获取url">1.5 获取URL</h2>
<pre><code>// Fetch prints the content found at a URL.
package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;os&quot;
)

func main() {
    for _, url := range os.Args[1:] {
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, &quot;fetch: %v\n&quot;, err)
            os.Exit(1)
        }
        b, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil {
            fmt.Fprintf(os.Stderr, &quot;fetch: reading %s: %v\n&quot;, url, err)
            os.Exit(1)
        }
        fmt.Printf(&quot;%s&quot;, b)
    }
}
</code></pre><h2 id="16-并发获取多个url">1.6 并发获取多个URL</h2>
<pre><code>// Fetchall fetches URLs in parallel and reports their times and sizes.
package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;time&quot;
)

func main() {
    start := time.Now()
    ch := make(chan string)
    for _, url := range os.Args[1:] {
        go fetch(url, ch) // start a goroutine
    }
    for range os.Args[1:] {
        fmt.Println(&lt;-ch) // receive from channel ch
    }
    fmt.Printf(&quot;%.2fs elapsed\n&quot;, time.Since(start).Seconds())
}

func fetch(url string, ch chan&lt;- string) {
    start := time.Now()
    resp, err := http.Get(url)
    if err != nil {
        ch &lt;- fmt.Sprint(err) // send to channel ch
        return
    }
    nbytes, err := io.Copy(ioutil.Discard, resp.Body)
    resp.Body.Close() // don't leak resources
    if err != nil {
        ch &lt;- fmt.Sprintf(&quot;while reading %s: %v&quot;, url, err)
        return
    }
    secs := time.Since(start).Seconds()
    ch &lt;- fmt.Sprintf(&quot;%.2fs  %7d  %s&quot;, secs, nbytes, url)
}
</code></pre><h2 id="17-web服务">1.7 Web服务</h2>
<pre><code>// Server1 is a minimal &quot;echo&quot; server.
package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

func main() {
    http.HandleFunc(&quot;/&quot;, handler) // each request calls handler
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))
}

// handler echoes the Path component of the request URL r.
func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;URL.Path = %q\n&quot;, r.URL.Path)
}
</code></pre><pre><code>// Server2 is a minimal &quot;echo&quot; and counter server.
package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;sync&quot;
)

var mu sync.Mutex
var count int

func main() {
    http.HandleFunc(&quot;/&quot;, handler)
    http.HandleFunc(&quot;/count&quot;, counter)
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))
}

// handler echoes the Path component of the requested URL.
func handler(w http.ResponseWriter, r *http.Request) {
    mu.Lock()
    count++
    mu.Unlock()
    fmt.Fprintf(w, &quot;URL.Path = %q\n&quot;, r.URL.Path)
}

// counter echoes the number of calls so far.
func counter(w http.ResponseWriter, r *http.Request) {
    mu.Lock()
    fmt.Fprintf(w, &quot;Count %d\n&quot;, count)
    mu.Unlock()
}
</code></pre><h1 id="2-程序结构">2 程序结构</h1>
<p>Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用if和for之类的控制语句来组织和控制表达式的执行流程。然后多个语句被组织到一个个函数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。</p>
<h2 id="21-命名">2.1 命名</h2>
<p>Golang有25个关键字：</p>
<pre><code>break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
</code></pre><p>Golang内建常量、类型、函数如下：</p>
<pre><code>内建常量: true false iota nil

内建类型:  int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover
</code></pre><p>如果一个名字是在函数内部定义，那么它就只在函数内部有效（函数内的开头字母大写变量也只是函数内可见）。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。</p>
<p>Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样，Go语言命名驼峰式，缩略词&amp;专有名词全部大写。</p>
<h2 id="22-声明">2.2 声明</h2>
<p>Golang声明：</p>
<pre><code>var     变量
const   常量
type    类型
func    函数
</code></pre><p>Golang包一级的各种类型的声明语句的顺序无关紧要（函数内部的名字则必须先声明之后才能使用）。</p>
<h2 id="23-变量">2.3 变量</h2>
<pre><code>var 变量名 类型 = 表达式
</code></pre><p>其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p>
<p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。例如：</p>
<pre><code>var s string
fmt.Println(s) // &quot;&quot;
// 这段代码将打印一个空字符串，而不是导致错误或产生不可预知的行为。
// Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。
</code></pre><p>也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：</p>
<pre><code>var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, &quot;four&quot; // bool, float64, string
</code></pre><p><strong>在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。</strong></p>
<h3 id="简短变量声明">简短变量声明</h3>
<p>函数内部，名字:=表达式，变量的类型根据表达式自动推导。简短变量声明语句也可以用来声明和初始化一组变量，简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了，简短变量声明语句中必须至少要声明一个新的变量。</p>
<pre><code>var i = 10
i, j := 0, 1
</code></pre><p>如果变量是在外部词法域声明，那么简短变量声明语句将会在当前词法域重新声明一个新的变量：</p>
<pre><code>var title = &quot;new title outside of printTitle&quot;

func printTitle(){
    title := &quot;new title in printTitle&quot;
    fmt.Println(title)
    // 将输出 new title in printTitle
}
</code></pre><p>var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p>
<h3 id="指针">指针</h3>
<p>一个变量对应一个保存了变量对应类型值的内存空间。</p>
<p>一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。<strong>并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址</strong>。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。</p>
<p>任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>
<p>在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量：</p>
<pre><code>var p = f()

func f() *int {
    v := 1
    return &amp;v
}
</code></pre><h3 id="new函数">new函数</h3>
<p>另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T：</p>
<pre><code>p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // &quot;0&quot;
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // &quot;2&quot;
</code></pre><p>每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：</p>
<pre><code>p := new(int)
q := new(int)
fmt.Println(p == q) // &quot;false&quot;
</code></pre><h3 id="变量的生命周期">变量的生命周期</h3>
<p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p>
<p>那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p>
<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p>
<pre><code>var global *int

func f() {
    var x int
    x = 1
    global = &amp;x
}

func g() {
    y := new(int)
    *y = 1
}
</code></pre><p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，<em>y并没有从函数g中逃逸，编译器可以选择在栈上分配</em>y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>
<p>Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。<strong>例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）</strong>。</p>
<h2 id="24-赋值">2.4 赋值</h2>
<pre><code>// =
=

// 特定的二元运算符
*=
+=
-=
/=
%=
++
--

// 元组赋值
// 允许同时更新多个变量的值，在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值
var a, b, c int
a, b, c = 1, 2, 3
</code></pre><p>利用元组赋值 &ldquo;<strong>在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值</strong>&rdquo; 这一特性，可以做如下操作：</p>
<pre><code>// 交换两个变量值
a, b = b, a
a[i], a[j] = a[j], a[i]

// 计算两个整数的最大公约数(GCD)
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}

// 计算斐波那契数列(Fibonacci)的第n个数：
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i &lt; n; i++ {
        x, y = y, x+y
    }
    return x
}
</code></pre><p>下划线可丢弃不需要的值：</p>
<pre><code>_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T)              // 只检测类型，忽略具体值
</code></pre><h3 id="可赋值性">可赋值性</h3>
<p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：</p>
<pre><code>medals := []string{&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;}
</code></pre><p>隐式地对slice的每个元素进行赋值操作，类似这样写的行为：</p>
<pre><code>medals[0] = &quot;gold&quot;
medals[1] = &quot;silver&quot;
medals[2] = &quot;bronze&quot;
</code></pre><p>map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。
不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
nil可以赋值给任何指针或引用类型的变量。
常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。
对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。</p>
<h2 id="25-类型">2.5 类型</h2>
<p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p>
<pre><code>type 类型名字 底层类型
</code></pre><p>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。
为了说明类型声明，我们将不同温度单位分别定义为不同的类型：</p>
<pre><code>// Package tempconv performs Celsius and Fahrenheit temperature computations.
package tempconv

import &quot;fmt&quot;

type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
</code></pre><p>Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。</p>
<p><strong>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型,如果T是指针类型，可能会需要用小括弧包装T，比如(*int)(0)。
只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型。</strong></p>
<p>数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的，这类转换可能改变值的表现。例如，将一个浮点数转为整数将丢弃小数部分，将一个字符串转为[]byte类型的slice将拷贝一个字符串数据的副本。在任何情况下，运行时不会发生转换失败的错误（错误只会发生在编译阶段）。</p>
<p>底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的：</p>
<pre><code>fmt.Printf(&quot;%g\n&quot;, BoilingC-FreezingC) // &quot;100&quot; °C
boilingF := CToF(BoilingC)
fmt.Printf(&quot;%g\n&quot;, boilingF-CToF(FreezingC)) // &quot;180&quot; °F
fmt.Printf(&quot;%g\n&quot;, boilingF-FreezingC)       // compile error: type mismatch
</code></pre><p>比较运算符==和&lt;也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：</p>
<pre><code>var c Celsius
var f Fahrenheit
fmt.Println(c == 0)          // &quot;true&quot;
fmt.Println(f &gt;= 0)          // &quot;true&quot;
fmt.Println(c == f)          // compile error: type mismatch
fmt.Println(c == Celsius(f)) // &quot;true&quot;!
</code></pre><h2 id="26-包和文件">2.6 包和文件</h2>
<p>Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、<strong>单独编译</strong>和代码重用。</p>
<p>import导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容，在默认情况下，导入的包绑定到该包声明语句指定的名字，但是我们也可以绑定到另一个名称（别名），以避免名字冲突。</p>
<p>如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理，这种强制规则可以有效减少不必要的依赖。</p>
<h3 id="包的初始化">包的初始化</h3>
<p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：</p>
<pre><code>var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
</code></pre><p>如果<strong>包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译</strong>。</p>
<p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个<strong>特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数</strong>：</p>
<pre><code>func init() { /* ... */ }
</code></pre><p>这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时<strong>按照它们声明的顺序被自动调用</strong>。</p>
<p><strong>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。</strong></p>
<h2 id="27-作用域">2.7 作用域</h2>
<p>不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p>
<p>声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。</p>
<p>当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。<strong>在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。</strong> 要特别注意短变量声明语句的作用域范围：</p>
<pre><code>var cwd string

func init() {
    cwd, err := os.Getwd() // compile error: unused: cwd
    if err != nil {
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    }
}
</code></pre><p>虽然cwd在外部已经声明过，但是:=语句还是将cwd和err重新声明为新的局部变量。因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使用:=的简短声明方式：</p>
<pre><code>var cwd string

func init() {
    var err error
    cwd, err = os.Getwd()
    if err != nil {
        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)
    }
}
</code></pre><h1 id="3-基础数据类型">3 基础数据类型</h1>
<p>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。</p>
<p>基础类型：数字、字符串、布尔型。</p>
<p>复合数据类型：数组、结构体。</p>
<p>引用类型：指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用，这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。</p>
<p>接口类型，interface后面介绍。</p>
<h2 id="31-整型">3.1 整型</h2>
<pre><code>// 有符号
int8        // 8bit, [-128,127]
int16       // 16bit
int32       // 32bit
int64       // 64bit

// 无符号
uint8       // 8bit, [0,255]
uint16      // 16bit
uint32      // 32bit
uint64      // 64bit

// PS
rune == int32
byte == uint8
int != int32 // 即使int也是32bit，转换时需显示的类型转换
uintptr     // 无符号整数类型，没有指定具体的bit大小但是足以容纳指针

/*
PS, Golang中不能直接使用二进制表示一个整数；十进制直接表示；
八进制以数字0开头，011==72；十六进制以0x或0X开头，0x11==17.
*/
</code></pre><p>下面是Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：</p>
<pre><code>*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^
+      -      |      ^
==     !=     &lt;      &lt;=       &gt;      &gt;=
&amp;&amp;
||

// PS. 逻辑非 ! 为单目运算符
// PS. &amp;^ , 按位置零 (AND NOT): 如果对应y中bit位为1的话, 表达式z = x &amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值
// PS. 取模运算符%仅用于整数间的运算，%取模运算符的符号和被取模数的符号总是一致的
</code></pre><h2 id="32-浮点数">3.2 浮点数</h2>
<pre><code>float32     // float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差
float64
</code></pre><h2 id="33-复数">3.3 复数</h2>
<pre><code>complex32       // 对应float32精度
complex64       // 对应float64精度
</code></pre><p>内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：</p>
<pre><code>var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // &quot;(-5+10i)&quot;
fmt.Println(real(x*y))           // &quot;-5&quot;
fmt.Println(imag(x*y))           // &quot;10&quot;
</code></pre><p>如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0(换句话说，用i表示复数虚部时前面必须带float或int，直接 &ldquo;8 * i&rdquo; 这种表述是非法的，应该使用 &ldquo;8 * 1i&rdquo; 才能表示 &ldquo;(0+8i)&quot;)：</p>
<pre><code>fmt.Println(1i * 1i) // &quot;(-1+0i)&quot;, i^2 = -1
</code></pre><h2 id="34-布尔型">3.4 布尔型</h2>
<pre><code>// Golang中boolean true和false定义如下：
// true and false are the two untyped boolean values.
const (
	true  = 0 == 0 // Untyped bool.
	false = 0 != 0 // Untyped bool.
)
</code></pre><h2 id="35-字符串">3.5 字符串</h2>
<p>文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。</p>
<p>内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i&lt; len(s)条件约束，如果试图访问超出字符串索引范围的字节将会导致panic异常。</p>
<p>子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节（如果索引超出字符串范围或者j小于i的话将导致panic异常）。不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置：</p>
<pre><code>s := &quot;hello, world&quot;

fmt.Println(s[:5]) // &quot;hello&quot;
fmt.Println(s[7:]) // &quot;world&quot;
fmt.Println(s[:])  // &quot;hello, world&quot;
</code></pre><p>+操作符将两个字符串连接构造一个新字符串。字符串可以用==和&lt;进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。</p>
<p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，但是可以给一个字符串变量分配一个新字符串值。</p>
<pre><code>s := &quot;left foot&quot;
t := s
s += &quot;, right foot&quot;

fmt.Println(s) // left foot, right foot
fmt.Println(t) // left foot
</code></pre><p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p>
<pre><code>s := &quot;left foot&quot;
s[0] = 'L' // compile error: cannot assign to s[0]
</code></pre><p>不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得<strong>复制任何长度的字符串代价是低廉的</strong>。同样，<strong>一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的</strong>。在这两种情况下都没有必要分配新的内存。</p>
<h3 id="字符串面值">字符串面值</h3>
<p>在一个双引号包含的字符串面值中，可以用以反斜杠\开头的转义序列插入任意的数据：</p>
<pre><code>\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\'      单引号 (只用在 '\'' 形式的rune符号面值中)
\&quot;      双引号 (只用在 &quot;...&quot; 形式的字符串面值中)
\\      反斜杠
</code></pre><p>一个原生的字符串面值形式是`&hellip;`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+&quot;`&ldquo;连接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（Windows系统会把回车和换行一起放入文本文件中）。</p>
<pre><code>const GoUsage = `Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...`
</code></pre><h3 id="字符串和byte切片">字符串和byte切片</h3>
<p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。</p>
<p>strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p>
<p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。</p>
<p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>
<p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p>
<p>一个字符串是包含只读字节的数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。字符串和字节slice之间可以相互转换：</p>
<pre><code>s := &quot;abc&quot;
b := []byte(s)
s2 := string(b)

// 从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组
// 编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变
// 将一个字节slice转换到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的

// bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数
// 据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的
</code></pre><h2 id="36-常量">3.6 常量</h2>
<p>常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。
常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof。
如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：</p>
<pre><code>const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // &quot;1 1 2 2&quot;

------------------------------------------------------

// iota常量生成器：常量声明可以使用iota常量生成器初始化，它用于
// 生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表
// 达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将
// 会被置为0，然后在每一个有常量声明的行加1
type Weekday int

const (
    Sunday Weekday = iota   // 0
    Monday                  // 1
    Tuesday                 // 2
    Wednesday               // 3
    Thursday
    Friday
    Saturday
)

// 下面是一个更复杂的例子，每个常量都是1024的幂：
const (
    _ = 1 &lt;&lt; (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 &lt;&lt; 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 &lt;&lt; 64)
    YiB // 1208925819614629174706176
)
</code></pre><h3 id="无类型常量">无类型常量</h3>
<p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。
通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p>
<p>举个例子，math包：</p>
<pre><code>package math

// Mathematical constants.
const (
	E   = 2.71828182845904523536028747135266249775724709369995957496696763 // https://oeis.org/A001113
	Pi  = 3.14159265358979323846264338327950288419716939937510582097494459 // https://oeis.org/A000796
	Phi = 1.61803398874989484820458683436563811772030917980576286213544862 // https://oeis.org/A001622

	Sqrt2   = 1.41421356237309504880168872420969807856967187537694807317667974 // https://oeis.org/A002193
	SqrtE   = 1.64872127070012814684865078781416357165377610071014801157507931 // https://oeis.org/A019774
	SqrtPi  = 1.77245385090551602729816748334114518279754945612238712821380779 // https://oeis.org/A002161
	SqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038 // https://oeis.org/A139339

	Ln2    = 0.693147180559945309417232121458176568075500134360255254120680009 // https://oeis.org/A002162
	Log2E  = 1 / Ln2
	Ln10   = 2.30258509299404568401799145468436420760110148862877297603332790 // https://oeis.org/A002392
	Log10E = 1 / Ln10
)
</code></pre><p>math.Pi是一个无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p>
<pre><code>var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
</code></pre><p>如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：</p>
<pre><code>const Pi64 float64 = math.Pi

var x float32 = float32(Pi64)
var y float64 = Pi64
var z complex128 = complex128(Pi64)
</code></pre><p>对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和\u0000虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。
只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话:</p>
<pre><code>var f float64 = 3 + 0i // untyped complex -&gt; float64, 相当于：var f float64 = float64(3 + 0i)
f = 2                  // untyped integer -&gt; float64, 相当于：f = float64(2)
f = 1e123              // untyped floating-point -&gt; float64, 相当于：f = float64(1e123)
f = 'a'                // untyped rune -&gt; float64, 相当于：f = float64('a')
</code></pre><h1 id="4-复合数据类型">4 复合数据类型</h1>
<p>我们主要讨论四种类型——数组、slice、map和结构体。
数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。</p>
<h2 id="41-数组">4.1 数组</h2>
<p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值。</p>
<p>在数组字面值中，如果在数组的长度位置出现的是“&hellip;”省略号，则表示数组的长度是根据初始化值的个数来计算：</p>
<pre><code>q := [...]int{1, 2, 3}
fmt.Printf(&quot;%T\n&quot;, q) // &quot;[3]int&quot;
</code></pre><p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定:</p>
<pre><code>q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int
</code></pre><p>上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化:</p>
<pre><code>type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: &quot;$&quot;, EUR: &quot;€&quot;, GBP: &quot;￡&quot;, RMB: &quot;￥&quot;}

fmt.Println(RMB, symbol[RMB]) // &quot;3 ￥&quot;
</code></pre><p>在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化:</p>
<pre><code>r := [...]int{4: -1} // {0, 0, 0, 0, -1}
</code></pre><p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则:</p>
<pre><code>a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // &quot;true false false&quot;
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
</code></pre><p><strong>数组类型作为函数参数传递时会发生值拷贝。</strong>
PS：要理解这句话：</p>
<ul>
<li>首先需要先弄清楚 传值 传指针 传引用 三者的差别</li>
<li>然后要知道，GO只有传值</li>
<li>那么为什么对于引用类型修改形参会影响实参呢？这是因为饮用类型内部有一个指针指向了底层数据</li>
<li>引用类型和传引用是两个完全不同的概念</li>
</ul>
<h2 id="42-slice">4.2 slice</h2>
<p>slice的语法和数组很像，只是没有固定长度而已。slice的底层引用一个数组对象。多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</p>
<p>slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。</p>
<pre><code>months := [...]string{1: &quot;January&quot;, /* ... */, 12: &quot;December&quot;}

Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // [&quot;April&quot; &quot;May&quot; &quot;June&quot;]
fmt.Println(summer) // [&quot;June&quot; &quot;July&quot; &quot;August&quot;]

fmt.Println(summer[:20]) // panic: out of range

endlessSummer := summer[:5] // extend a slice (within capacity)
fmt.Println(endlessSummer)  // &quot;[June July August September October]&quot;
</code></pre><p>和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。slice唯一合法的比较操作是和nil比较。
一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。</p>
<h3 id="append">append</h3>
<p>Go内置的append函数使用比较复杂的内存扩展策略。因此，通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。</p>
<pre><code>first := make([]int, 3, 4)
first[0] = 0
first[1] = 1
first[2] = 2
fmt.Println(first, &amp;first[0], len(first), cap(first))

second := append(first, 3)
fmt.Println(second, &amp;second[0], len(second), cap(second))

third := append(first, []int{3, 4, 5}...)
// &amp;third[0] != &amp;first[0], 因为发生了一次扩容，底层结构不共用
fmt.Println(third, &amp;third[0], len(third), cap(third))

// 1. 修改first，由于second通过append生成时未发生扩容，所以second与first共用底层数组，将同时被修改
// 2. 由于third通过append生成时，超过first的容量，发生扩容，将申请新的空间，
// 将first拷贝过来后再执行append动作，因此third与first不共用底层数组，修改first不影响third
first[1] = 10
fmt.Println(first, second, third)

----------------------------------------------------------------------------
output:

[0 1 2] 0xc000126020 3 4
[0 1 2 3] 0xc000126020 4 4
[0 1 2 3 4 5] 0xc000134000 6 8
[0 10 2] [0 10 2 3] [0 1 2 3 4 5]
</code></pre><h2 id="43-map">4.3 map</h2>
<p>哈希表是一种巧妙并且实用的数据结构。它是一个无序的key-value对的集合（key必须是支持==比较运算符的数据类型，但是将浮点数用做key类型则是一个坏的想法，浮点数==判断受精度影响，最坏的情况是可能出现的NaN和任何浮点数都不相等），其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。在Go语言中，一个map就是一个哈希表的引用。</p>
<p>map索引失败时将返回零值。</p>
<p>map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：</p>
<pre><code>ages := map[string]int{&quot;bob&quot;: 22}
_ = &amp;ages[&quot;bob&quot;] // compile error: cannot take address of map element
</code></pre><p>map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。</p>
<p><strong>向一个nil值的map存入元素将导致一个panic异常。</strong></p>
<p>map之间也不能进行相等比较；唯一的例外是和nil进行比较。</p>
<h2 id="44-结构体">4.4 结构体</h2>
<p>结构体相邻成员类型相同可合并到一行：</p>
<pre><code>type Employee struct{
    ID          int
    Name, Addr  string
    ... 
}
</code></pre><p>结构体成员顺序不同定义为不同的结构体类型。</p>
<p><strong>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身，但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。</strong></p>
<p>结构体类型的零值是每个成员都是零值。</p>
<p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。</p>
<p>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指:</p>
<pre><code>type Point struct {
    X, Y int
}

type Circle struct {
    Point
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}
</code></pre><p>得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径。在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分：</p>
<pre><code>var w Wheel
w.X = 8            // equivalent to w.Circle.Point.X = 8
w.Y = 8            // equivalent to w.Circle.Point.Y = 8
w.Radius = 5       // equivalent to w.Circle.Radius = 5
w.Spokes = 20
</code></pre><p>结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</p>
<pre><code>w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields
</code></pre><p>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</p>
<pre><code>w = Wheel{Circle{Point{8, 8}, 5}, 20}

w = Wheel{
    Circle: Circle{
        Point:  Point{X: 8, Y: 8},
        Radius: 5,
    },
    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
}
</code></pre><p>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。</p>
<p>因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员，<strong>但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的</strong>。</p>
<pre><code>w.X = 8 // equivalent to w.circle.point.X = 8
</code></pre><p><strong>外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。</strong></p>
<h2 id="45-json">4.5 JSON</h2>
<p>一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。</p>
<p>JSON在编码时，默认使用Go语言结构体的成员名字作为JSON的对象，只有导出的结构体成员才会被编码。</p>
<p>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:&ldquo;value&quot;键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/&hellip;下面其它的包也遵循这个约定。</p>
<p>除了json.Marshal&amp;json.Unmarshal的编解码，还有json.Encoder&amp;json.Decoder的基于流式的编解码:</p>
<pre><code>json.NewEncoder(w).Encode(src)
json.NewDecoder(r).Decode(des)
</code></pre><p>Golang结构体关于JSON的tag有很多，key==json，关于其含义，官方有解释<a href="https://golang.org/pkg/encoding/json/#Marshal">encoding/json/Marshal关于tag的解释</a>，鸟窝对此也转过一篇taowen的文章<a href="https://colobu.com/2017/06/21/json-tricks-in-Go/">鸟窝[转taowen]Golang 中使用 JSON 的小技巧</a></p>
<h2 id="46-text-template--html-template">4.6 text template &amp; HTML template</h2>
<p>text/template和html/template模板包提供将变量值填充到一个文本或HTML格式的模板的功能。</p>
<p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的{{action}}对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。</p>
<h3 id="text-template实例">text template实例</h3>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;text/template&quot;
)

// 对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”
// 当前值“.”最初被初始化为调用模板时的参数
// 模板中{{range .Items}}和{{end}}对应一个循环action
// printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用
// 在一个action中，|操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念
const personTextTempl = `Name: {{.Name}}, Titles:
{{range .Titles}}////////////////////////////
Title: {{.Title}}
Desc:  {{.Desc}}
Desc1: {{.Desc1 | printf &quot;%.64s&quot;}} (desc1)
Desc2: {{.Desc2 | printDesc}} (desc2)
{{end}}`

// text templates
var (
	personTempl *template.Template
)


type Person struct {
	Name   string
	Titles []Title
}

type Title struct {
	Title string
	Desc  string
	Desc1 string
	Desc2 string
}

func init() {
	var err error

	personTempl, err = template.New(&quot;personTempl&quot;).Funcs(template.FuncMap{&quot;printDesc&quot;: printDescWithPrefix}).Parse(personTextTempl)
	if err != nil {
		fmt.Println(&quot;template parse err: %v&quot;, err)
		os.Exit(-1)
	}
}

func printDescWithPrefix(desc string) string {
	return fmt.Sprintf(&quot;Desc is: %s&quot;, desc)
}

func main() {
	personInfo := Person{
		Name: &quot;ztq&quot;,
		Titles: []Title{
			Title{
				Title: &quot;title0&quot;,
				Desc:  &quot;desc0&quot;,
				Desc1: &quot;desc1&quot;,
				Desc2: &quot;desc2&quot;,
			},
			Title{
				Title: &quot;title1&quot;,
				Desc:  &quot;desc0&quot;,
				Desc1: &quot;desc1&quot;,
				Desc2: &quot;desc2&quot;,
			},
		},
	}
	if err := personTempl.Execute(os.Stdout, personInfo); err != nil {
		fmt.Println(&quot;template execute error: %v&quot;, err)
	}
}

---------------------------------------------
output:

Name: ztq, Titles:
////////////////////////////
Title: title0
Desc:  desc0
Desc1: desc1 (desc1)
Desc2: Desc is: desc2 (desc2)
////////////////////////////
Title: title1
Desc:  desc0
Desc1: desc1 (desc1)
Desc2: Desc is: desc2 (desc2)
</code></pre><p>一个小技巧，上述的这个调用：</p>
<pre><code>something, err = template.New(&quot;*&quot;).Funcs(template.FuncMap{&quot;*&quot;: *}).Parse(*)
if err != nil {
    ...
}
</code></pre><p>可以包在template.Must()里，template.Must()函数如下，如果模版构建有错误则直接panic，因为模版在编译阶段就构建好了，如果解析失败后面直接使用可能会导致一些考虑不到的panic，或者这里捕获一次panic，总好过后面每次使用模版都要考虑可能发生panic。</p>
<pre><code>// Must is a helper that wraps a call to a function returning (*Template, error)
// and panics if the error is non-nil. It is intended for use in variable
// initializations such as
//	var t = template.Must(template.New(&quot;name&quot;).Parse(&quot;text&quot;))
func Must(t *Template, err error) *Template {
	if err != nil {
		panic(err)
	}
	return t
}
</code></pre><h3 id="html-template实例">HTML template实例</h3>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	htemplate  &quot;html/template&quot;
)

const HTMLTempl = `
&lt;h1&gt;{{.HEAD1}} :&lt;/h1&gt;
&lt;table&gt;
&lt;tr style='text-align: left'&gt;
  &lt;th&gt;State&lt;/th&gt;
  &lt;th&gt;User&lt;/th&gt;
  &lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
{{range .Items}}
&lt;tr&gt;
  &lt;td&gt;{{.State}}&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;{{.User}}&lt;/td&gt;
  &lt;td&gt;{{.Title | printTitle}}&lt;/td&gt;
&lt;/tr&gt;
{{end}}
&lt;/table&gt;
`

// HTML templates
var (
	hTempl *htemplate.Template
)

func printTitleWithPrefix(title string) string {
	return fmt.Sprintf(&quot;Title: %s&quot;, title)
}

// Could panic when HTML template New failed.
func init() {
	hTempl = htemplate.Must(htemplate.New(&quot;ht&quot;).Funcs(htemplate.FuncMap{&quot;printTitle&quot;: printTitleWithPrefix}).Parse(HTMLTempl))
}

func main() {
	info := struct {
		Head  string
		Items []struct{ State, User, Title string }
	}{
		Head: &quot;ztq&quot;,
		Items: []struct{ State, User, Title string }{
			struct{ State, User, Title string }{&quot;state1&quot;, &quot;user1&quot;, &quot;title1&quot;},
			struct{ State, User, Title string }{&quot;state2&quot;, &quot;user2&quot;, &quot;title2&quot;},
			struct{ State, User, Title string }{&quot;state3&quot;, &quot;user3&quot;, &quot;title3&quot;},
		},
	}

	if err := hTempl.Execute(os.Stdout, &amp;info); err != nil {
		fmt.Println(&quot;HTML template failed: %v&quot;, err)
	}
}

------------------------------------------------------
output:

&lt;h1&gt;ztq :&lt;/h1&gt;
&lt;table&gt;
&lt;tr style='text-align: left'&gt;
  &lt;th&gt;State&lt;/th&gt;
  &lt;th&gt;User&lt;/th&gt;
  &lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;state1&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;user1&lt;/td&gt;
  &lt;td&gt;Title: title1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;state2&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;user2&lt;/td&gt;
  &lt;td&gt;Title: title2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
  &lt;td&gt;state3&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;user3&lt;/td&gt;
  &lt;td&gt;Title: title3&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;

页面效果如下：
</code></pre><p><img src="/images/The-Go-Programming-Language/html-template.jpg" alt=""></p>
<h1 id="5-函数">5 函数</h1>
<p>函数将一个语句序列打包为一个单元，然后可以从程序中其它地方多次调用。</p>
<h2 id="51-函数声明">5.1 函数声明</h2>
<p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体：</p>
<pre><code>func name(parameter-list) (result-list) {
    body
}
</code></pre><p>返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为0。(如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环。)</p>
<p>函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或标识符。形参和返回值的变量名不影响函数标识符，也不影响它们是否可以以省略参数类型的形式表示。</p>
<p>每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，<strong>Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参</strong>，因此形参和返回值的变量名对于函数调用者而言没有意义。</p>
<p>在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。</p>
<p><strong>实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。</strong></p>
<p><strong>没有函数体的函数声明，表示该函数不是以Go实现的，这样的声明仅仅定义函数标识符(也在go:linkname机制中使用到)</strong>：</p>
<pre><code>package math

func Sin(x float64) float //implemented in assembly language
</code></pre><h2 id="52-递归">5.2 递归</h2>
<p>函数可以是递归的，这意味着函数可以直接或间接的调用自身。</p>
<h2 id="53-多返回值">5.3 多返回值</h2>
<p>在Go中，一个函数可以返回多个值。
如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。</p>
<h2 id="54-错误">5.4 错误</h2>
<p>在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。</p>
<p>在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。</p>
<p>Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。</p>
<p>一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息。</p>
<p>如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试：</p>
<pre><code>// WaitForServer attempts to contact the server of a URL.
// It tries for one minute using exponential back-off.
// It reports an error if all attempts fail.
func WaitForServer(url string) error {
    const timeout = 1 * time.Minute
    deadline := time.Now().Add(timeout)
    for tries := 0; time.Now().Before(deadline); tries++ {
        _, err := http.Head(url)
        if err == nil {
            return nil // success
        }
        log.Printf(&quot;server not responding (%s);retrying…&quot;, err)
        time.Sleep(time.Second &lt;&lt; uint(tries)) // exponential back-off
    }
    return fmt.Errorf(&quot;server %s failed to respond after %s&quot;, url, timeout)
}
</code></pre><p>我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该清晰地写下你的意图。
在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</p>
<h2 id="55-函数值">5.5 函数值</h2>
<p>在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。例子如下：</p>
<pre><code>    func square(n int) int { return n * n }
    func negative(n int) int { return -n }
    func product(m, n int) int { return m * n }

    f := square
    fmt.Println(f(3)) // &quot;9&quot;

    f = negative
    fmt.Println(f(3))     // &quot;-3&quot;
    fmt.Printf(&quot;%T\n&quot;, f) // &quot;func(int) int&quot;

    f = product // compile error: can't assign func(int, int) int to func(int) int
</code></pre><p>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</p>
<pre><code>var f func(int) int
f(3) // 此处f的值为nil, 会引起panic错误
</code></pre><p>函数值之间不可比较，也不能用函数值作为map的key，但是函数值可以与nil比较。</p>
<p><strong>函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为：</strong></p>
<pre><code>// strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者

func add1(r rune) rune { return r + 1 }

fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) // &quot;IBM.:111&quot;
fmt.Println(strings.Map(add1, &quot;VMS&quot;))      // &quot;WNT&quot;
fmt.Println(strings.Map(add1, &quot;Admix&quot;))    // &quot;Benjy&quot;
</code></pre><h2 id="56-匿名函数">5.6 匿名函数</h2>
<p><strong>拥有函数名的函数只能在包级语法块中被声明</strong>，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。</p>
<p>通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：</p>
<pre><code>// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // &quot;1&quot;
    fmt.Println(f()) // &quot;4&quot;
    fmt.Println(f()) // &quot;9&quot;
    fmt.Println(f()) // &quot;16&quot;
}
</code></pre><p>以上例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</p>
<p>当匿名函数需要递归调用时，需要将匿名函数赋值给函数变量然后实现递归：</p>
<pre><code>var visitAll func(items []string)
visitAll = func(items []string) {
    for _, item := range items {
        if !seen[item] {
            seen[item] = true
            visitAll(m[item])
            order = append(order, item)
        }
    }
}

--------------------------------------------
visitAll := func(items []string) {
    // ...
    visitAll(m[item]) // compile error: undefined: visitAll
    // ...
}
</code></pre><h2 id="57-可变参数">5.7 可变参数</h2>
<p>参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。
在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“&hellip;”，这表示该函数会接收任意数量的该类型参数：</p>
<pre><code>func sum(vals...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}
</code></pre><h2 id="58-defer函数">5.8 defer函数</h2>
<p><strong>当执行到该条语句时，函数和参数表达式得到计算</strong>，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，<strong>不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束</strong>。</p>
<p>一个函数中执行多条defer语句，它们的<strong>执行顺序与声明顺序相反</strong>。</p>
<p><strong>defer可以读取具名返回值</strong>。</p>
<h2 id="59-panic">5.9 panic</h2>
<p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。
一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer ）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。</p>
<p>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。</p>
<h2 id="510-recover">5.10 recover</h2>
<p>如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。<strong>导致panic异常的函数不会继续运行，但能正常返回</strong>。在未发生panic时调用recover，recover会返回nil。</p>
<p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</p>
<p>基于以上原因，安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理：</p>
<pre><code>// soleTitle returns the text of the first non-empty title element
// in doc, and an error if there was not exactly one.
func soleTitle(doc *html.Node) (title string, err error) {
    type bailout struct{}
    defer func() {
        switch p := recover(); p {
        case nil:       // no panic
        case bailout{}: // &quot;expected&quot; panic
            err = fmt.Errorf(&quot;multiple title elements&quot;)
        default:
            panic(p) // unexpected panic; carry on panicking
        }
    }()
    // Bail out of recursion if we find more than one nonempty title.
    forEachNode(doc, func(n *html.Node) {
        if n.Type == html.ElementNode &amp;&amp; n.Data == &quot;title&quot; &amp;&amp;
            n.FirstChild != nil {
            if title != &quot;&quot; {
                panic(bailout{}) // multiple titleelements
            }
            title = n.FirstChild.Data
        }
    }, nil)
    if title == &quot;&quot; {
        return &quot;&quot;, fmt.Errorf(&quot;no title element&quot;)
    }
    return title, nil
}
</code></pre><h1 id="6-方法">6 方法</h1>
<h2 id="61-方法声明">6.1 方法声明</h2>
<p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p>
<pre><code>package geometry

import &quot;math&quot;

type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
</code></pre><p>上面的代码里那个附加的参数p，叫做方法的接收器(receiver)。
在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。接收器命名建议可以使用类型的第一个字母，比如这里使用了Point的首字母p。</p>
<p>在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前：</p>
<pre><code>p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // &quot;5&quot;, function call
fmt.Println(p.Distance(q))  // &quot;5&quot;, method call
</code></pre><p>这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如p.X。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用p.X时会有歧义。</p>
<h2 id="62-基于指针对象的方法">6.2 基于指针对象的方法</h2>
<p>当接受者变量本身比较大时，可以用其指针而不是对象来声明方法：</p>
<pre><code>type Point struct{ X, Y float64 }

func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
</code></pre><p>这个方法的名字是(*Point).ScaleBy。括号是必须的,没有括号的话这个表达式可能会被理解为*(Point.ScaleBy)。</p>
<p>只有类型(Point)和指向他们的指针(*Point)，才可能是出现在接收器声明里的两种接收器。在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的：</p>
<pre><code>type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
</code></pre><p>如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法，编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法：</p>
<pre><code>p.ScaleBy(2)
</code></pre><p>这种简写方法只适用于“变量”，我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到(临时变量不能隐式的转换为指针，如果显示声明还是可以的)：</p>
<pre><code>Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal

/////////////////////////

(&amp;Point{1, 2}).ScaleBy(2) // ok
</code></pre><h3 id="nil也是合法的接收器">nil也是合法的接收器</h3>
<pre><code>// An IntList is a linked list of integers.
// A nil *IntList represents the empty list.
type IntList struct {
    Value int
    Tail  *IntList
}
// Sum returns the sum of the list elements.
func (list *IntList) Sum() int {
    if list == nil {
        return 0
    }
    return list.Value + list.Tail.Sum()
}

</code></pre><h2 id="63-通过嵌入结构体来扩展类型">6.3 通过嵌入结构体来扩展类型</h2>
<pre><code>import &quot;image/color&quot;

type Point struct{ X, Y float64 }

type ColoredPoint struct {
    Point
    Color color.RGBA
}
</code></pre><p>是&quot;has a&rdquo;，而不是&quot;is a&rdquo;。</p>
<p>当编译器解析一个选择器到方法时，它会首先去找直接定义在这个类型里的方法，然后找被内嵌字段们引入的方法，然后去找内嵌字段的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错（同一级里有两个同名的方法）。</p>
<h2 id="64-方法值和方法表达式">6.4 方法值和方法表达式</h2>
<p>我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。p.Distance叫作“选择器”，选择器会返回一个方法&quot;值&rdquo;-&gt;一个将方法(Point.Distance)绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器(因为已经在前文中指定过了)，只要传入函数的参数即可：</p>
<pre><code>p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance        // method value
fmt.Println(distanceFromP(q))      // &quot;5&quot;
var origin Point                   // {0, 0}
fmt.Println(distanceFromP(origin)) // &quot;2.23606797749979&quot;, sqrt(5)

scaleP := p.ScaleBy // method value
scaleP(2)           // p becomes (2, 4)
scaleP(3)           //      then (6, 12)
scaleP(10)          //      then (60, 120)
</code></pre><p>在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法&quot;值&quot;会非常实用:</p>
<pre><code>type Rocket struct { /* ... */ }
func (r *Rocket) Launch() { /* ... */ }
r := new(Rocket)
time.AfterFunc(10 * time.Second, func() { r.Launch() })

------------------------------------------------------

// 直接用方法&quot;值&quot;传入AfterFunc的话可以更为简短, 省掉了上面例子里的匿名函数
time.AfterFunc(10 * time.Second, r.Launch)
</code></pre><p>和方法&quot;值&quot;相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器(p.Distance)语法来指定方法的接收器。</p>
<p>当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个函数&quot;值&quot;，这种函数会将其第一个参数用作接收器，所以可以用通常(不写选择器)的方式来对其进行调用：</p>
<pre><code>p := Point{1, 2}
q := Point{4, 6}

distance := Point.Distance   // method expression
fmt.Println(distance(p, q))  // &quot;5&quot;
fmt.Printf(&quot;%T\n&quot;, distance) // &quot;func(Point, Point) float64&quot;

scale := (*Point).ScaleBy
scale(&amp;p, 2)
fmt.Println(p)            // &quot;{2 4}&quot;
fmt.Printf(&quot;%T\n&quot;, scale) // &quot;func(*Point, float64)&quot;

// 译注：这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()
// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数
// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数
</code></pre><p>再看一个具体例子：</p>
<pre><code>package main

import &quot;fmt&quot;

type Title struct {
	Desc string
}

func (t *Title) PrintDesc(a, b, c string) (d string) {
	fmt.Println(t.Desc)

	return
}

func main() {
	fmt.Printf(&quot;%T\n&quot;, (&amp;Title{}).PrintDesc)

	fmt.Printf(&quot;%T\n&quot;, (*Title).PrintDesc)
}

----------------------------------------------
output:

func(string, string, string) string
func(*main.Title, string, string, string) string // 这里函数参数多了一个*main.Title，即接收器
</code></pre><h2 id="66-封装">6.6 封装</h2>
<p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。</p>
<p>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。</p>
<p>这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。</p>
<p>封装提供了三方面的优点：</p>
<ul>
<li>因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可</li>
<li>隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由</li>
<li>阻止了外部调用方对对象内部的值任意地进行修改</li>
</ul>
<p>Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证API兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。</p>
<h1 id="7-接口">7 接口</h1>
<p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。</p>
<p>很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足<strong>隐式实现</strong>的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。</p>
<h2 id="71-接口合约">7.1 接口==“合约”</h2>
<p>一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。</p>
<p>在Go语言中还存在着另外一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说<strong>当你看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么</strong>。</p>
<p>一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性(LSP里氏替换)。这是一个面向对象的特征。</p>
<h2 id="72-接口类型">7.2 接口类型</h2>
<p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p>
<h2 id="73-实现接口的条件">7.3 实现接口的条件</h2>
<p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</p>
<p>接口的使用场景实例：</p>
<pre><code>// 考虑在一个组织出售数字文化产品比如音乐，电影和书籍的程序中可能定义了下列的具体类型
Album
Book
Movie
Magazine
Podcast
TVEpisode
Track

// 把每个抽象的特点用接口来表示。一些特性对于所有的这些文化产品都是共通的，例如标题，创作日期和作者列表
type Artifact interface {
    Title() string
    Creators() []string
    Created() time.Time
}

// 其它的一些特性只对特定类型的文化产品才有。和文字排版特性相关的只有books和magazines，
// 还有只有movies和TV剧集和屏幕分辨率相关
type Text interface {
    Pages() int
    Words() int
    PageSize() int
}
type Audio interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string // e.g., &quot;MP3&quot;, &quot;WAV&quot;
}
type Video interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string // e.g., &quot;MP4&quot;, &quot;WMV&quot;
    Resolution() (x, y int)
}

// 这些接口不止是一种有用的方式来分组相关的具体类型和表示他们之间的共同特点。
// 我们后面可能会发现其它的分组。举例，如果我们发现我们需要以同样的方式处理Audio和Video，
// 我们可以定义一个Streamer接口来代表它们之间相同的部分而不必对已经存在的类型做改变
type Streamer interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string
}
</code></pre><p><strong>每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。<em>当具体的类型来自不同的作者时这种方式会特别有用</em>。当然也确实没有必要在具体的类型中指出这些共性。</strong></p>
<h2 id="75-接口值">7.5 接口值</h2>
<p><strong>接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。</strong>
下面4个语句中，变量w得到了3个不同的值（开始和最后的值是相同的）：</p>
<pre><code>var w io.Writer
w = os.Stdout
w = new(bytes.Buffer)
w = nil
</code></pre><p>第一个语句<code>var w io.Writer</code>定义了变量w。在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil:
<img src="/images/The-Go-Programming-Language/ch7-01.png" alt="ch7-01">
一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生panic:</p>
<pre><code>w.Write([]byte(&quot;hello&quot;)) // panic: nil pointer dereference
</code></pre><p>第二个语句<code>w = os.Stdout</code>将一个*os.File类型的值赋给变量w。这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用<code>io.Writer(os.Stdout)</code>是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为*os.File指针的类型描述符，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的os.File类型变量的指针:
<img src="/images/The-Go-Programming-Language/ch7-02.png" alt="ch7-02">
调用一个包含*os.File类型指针的接口值的Write方法，使得(*os.File).Write方法被调用。这个调用输出“hello”:</p>
<pre><code>w.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot;
</code></pre><p>通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样：</p>
<pre><code>os.Stdout.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot;
</code></pre><p>第三个语句<code>w = new(bytes.Buffer)</code>给接口值赋了一个*bytes.Buffer类型的值。现在动态类型是*bytes.Buffer并且动态值是一个指向新分配的缓冲区的指针：
<img src="/images/The-Go-Programming-Language/ch7-03.png" alt="ch7-03">
Write方法的调用也使用了和之前一样的机制：</p>
<pre><code>w.Write([]byte(&quot;hello&quot;)) // writes &quot;hello&quot; to the bytes.Buffers
</code></pre><p>这次类型描述符是*bytes.Buffer，所以调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。
最后，第四个语句<code>w = nil</code>将nil赋给了接口值。这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时相同的状态，在第一张图中可以看到。
使用fmt包的%T看到的效果：</p>
<pre><code>var w io.Writer
fmt.Printf(&quot;%T\n&quot;, w) // &quot;&lt;nil&gt;&quot;
w = os.Stdout
fmt.Printf(&quot;%T\n&quot;, w) // &quot;*os.File&quot;
w = new(bytes.Buffer)
fmt.Printf(&quot;%T\n&quot;, w) // &quot;*bytes.Buffer&quot;
</code></pre><p>一个接口值可以持有任意大的动态值。</p>
<p>接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。
然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:</p>
<pre><code>var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int
</code></pre><p>考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。</p>
<h2 id="710-类型断言">7.10 类型断言</h2>
<p>类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</p>
<ul>
<li>如果断言的类型T是一个具体类型，类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，会抛出panic。
<pre><code>var w io.Writer
w = os.Stdout
f := w.(*os.File)      // success: f == os.Stdout
c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer
</code></pre></li>
<li><strong>如果相反地断言的类型T是一个接口类型，类型断言检查是否x的动态类型满足T</strong>。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，<strong>对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分</strong>。
<pre><code>var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) // success: *os.File has both Read and Write
w = new(ByteCounter)
rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method
</code></pre></li>
</ul>
<p>如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况：</p>
<pre><code>w = rw             // io.ReadWriter is assignable to io.Writer
w = rw.(io.Writer) // fails only if rw == nil
</code></pre><p>如果类型断言出现在一个预期有两个结果的赋值操作中，这个操作不会在失败的时候发生panic，第二个结果是一个标识成功与否的布尔值：</p>
<pre><code>var w io.Writer = os.Stdout
f, ok := w.(*os.File)      // success:  ok, f == os.Stdout
b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil
</code></pre><h2 id="713-类型分支">7.13 类型分支</h2>
<p>接口被以两种不同的方式使用。</p>
<ul>
<li>在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。</li>
<li>第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。以这种方式使用的接口被描述为discriminated unions（可辨识联合）。</li>
</ul>
<p>在最简单的形式中，一个类型分支像普通的switch语句一样，它的运算对象是x.(type)——它使用了关键词字面量type——并且每个case有一到多个类型。一个类型分支基于这个接口值的动态类型使一个多路分支有效：</p>
<pre><code>switch x.(type) {
case nil:       // ...
case int, uint: // ...
case bool:      // ...
case string:    // ...
default:        // ...
}
</code></pre><h1 id="8-goroutine-和-channel">8 goroutine 和 channel</h1>
<h2 id="81-goroutine">8.1 goroutine</h2>
<p>在Go语言中，每一个并发的执行单元叫作一个goroutine。</p>
<p>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成:</p>
<pre><code>f()    // call f(); wait for it to return
go f() // create a new goroutine that calls f(); don't wait
</code></pre><p><strong>主函数返回时，所有的goroutine都会被直接打断，程序退出</strong>。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行（但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行）。</p>
<p><strong>go后跟的函数的参数会在go语句自身执行时被求值</strong>。</p>
<h2 id="82-channel">8.2 channel</h2>
<p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。</p>
<p>创建一个 int变量channel：</p>
<pre><code>ch := make(chan int) // ch has type 'chan int'
</code></pre><p>channel对应一个make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。</p>
<p>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。</p>
<p>一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用&lt;-运算符。在发送语句中，&lt;-运算符分割channel和要发送的值。在接收语句中，&lt;-运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的:</p>
<pre><code>ch &lt;- x  // a send statement
x = &lt;-ch // a receive expression in an assignment statement
&lt;-ch     // a receive statement; result is discarded
</code></pre><p><strong>channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic</strong>。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。
使用内置的close函数就可以关闭一个channel：</p>
<pre><code>close(ch)
</code></pre><p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel:</p>
<pre><code>ch = make(chan int)    // unbuffered channel
ch = make(chan int, 0) // unbuffered channel
ch = make(chan int, 3) // buffered channel with capacity 3
</code></pre><h3 id="单方向channeleg-chan--int-和--chan-int">单方向channel(e.g. chan&lt;- int 和 &lt;-chan int)</h3>
<p>当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。类型chan&lt;- int表示一个只发送int的channel，只能发送不能接收。相反，类型&lt;-chan int表示一个只接收int的channel，只能接收不能发送。（箭头&lt;-和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。</p>
<p>因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。</p>
<h3 id="不带缓存的channel">不带缓存的channel</h3>
<p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。
基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。<strong>当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前(happens before)</strong>。</p>
<h3 id="带缓存的channel">带缓存的channel</h3>
<p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel:</p>
<pre><code>ch = make(chan string, 3)
</code></pre><p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。
channel的缓存队列解耦了接收和发送的goroutine(发送和接收操作&quot;不同步&quot;了)。</p>
<p>cap和len可分别获取缓存channel的容量和长度：</p>
<pre><code>ch &lt;- &quot;test&quot;

println(cap(ch))    // 3
println(len(ch))    // 1
</code></pre><p>如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。</p>
<h2 id="89-并发的退出">8.9 并发的退出</h2>
<p>Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。
可以在某个goroutine中向一个channel发送一个简单的值，其他的goroutine将这个值理解为自己的退出信号；但是如果是有多个goroutine需要退出呢？一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的，不知道应该发送多少个退出信号。</p>
<p>为了达到退出goroutine的目的，需要一个更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。</p>
<p>关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。将这个机制扩展一下，来作为广播机制：不要向channel发送值，而是用关闭一个channel来进行广播:</p>
<pre><code>func main() {
	var exitSig = make(chan struct{})
	var wg = &amp;sync.WaitGroup{}
	var exigWg = &amp;sync.WaitGroup{}

	testFunc := func(msg string) {
		i := 0
	forSelect:
		for {
			select {
			case &lt;-exitSig:
				exigWg.Add(1)
				fmt.Println(msg, &quot; &quot;, &quot;exit&quot;)
				exigWg.Done()
				
				break forSelect
			default:
				wg.Add(1)
				
				fmt.Println(msg, &quot; &quot;, i)
				i++
				time.Sleep(200 * time.Millisecond)
            
				wg.Done()
			}
		}
	}

	go testFunc(&quot;func1&quot;)
	go testFunc(&quot;func2&quot;)

	// work
	time.Sleep(time.Second)

	// exit
	close(exitSig)

	// wait for wg
	wg.Wait()
	// wait for exit msg output
	exigWg.Wait()
}
---------------------------------------
output:

func2   0
func1   0
func1   1
func2   1
func1   2
func2   2
func2   3
func1   3
func1   4
func2   4
func1   exit
func2   exit
</code></pre><h1 id="9-基于共享变量的并发">9 基于共享变量的并发</h1>
<h2 id="91-竞争条件">9.1 竞争条件</h2>
<p>在一个线性(就是说只有一个goroutine的)的程序中，程序的执行顺序只由程序的逻辑来决定。例如，我们有一段语句序列，第一个在第二个之前，以此类推。在有两个或更多goroutine的程序中，每一个goroutine内的语句也是按照既定的顺序去执行的，但是一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。</p>
<p>一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是并发安全的，并发安全的函数不需要额外的同步工作。做个概括，对于某个类型来说，如果其所有可访问的方法和操作都是并发安全的话，那么该类型便是并发安全的。</p>
<p>包级别的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。</p>
<p>竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。</p>
<p>数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。根据上述定义，有三种方式可以避免数据竞争：</p>
<ul>
<li>不要去写变量</li>
<li>避免从多个goroutine访问变量：Go的一个口头禅“不要使用共享数据来通信；使用通信来共享数据”。一个提供对一个指定的变量通过channel来请求的goroutine叫做这个变量的monitor goroutine。例子中balance变量被限制在了monitor goroutine中，名为teller：
<pre><code>// Package bank provides a concurrency-safe bank with one account.
package bank

var deposits = make(chan int) // send amount to deposit
var balances = make(chan int) // receive balance

func Deposit(amount int) { deposits &lt;- amount }
func Balance() int       { return &lt;-balances }

func teller() {
    var balance int // balance is confined to teller goroutine
    for {
        select {
        case amount := &lt;-deposits:
            balance += amount
        case balances &lt;- balance:
        }
    }
}

func init() {
    go teller() // start the monitor goroutine
}
</code></pre></li>
<li>允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问:&ldquo;互斥&rdquo;</li>
</ul>
<h2 id="92-syncmutex">9.2 sync.Mutex</h2>
<pre><code>import &quot;sync&quot;

var (
    mu      sync.Mutex // guards balance
    balance int
)

func Deposit(amount int) {
    mu.Lock()
    balance = balance + amount
    mu.Unlock()
}

func Balance() int {
    mu.Lock()
    b := balance
    mu.Unlock()
    return b
}
</code></pre><p>如上，再考虑下下面的函数。当过多的取款操作同时执行时，balance可能会瞬时被减到0以下。这可能会引起一个并发的取款被不合逻辑地拒绝。</p>
<pre><code>// NOTE: not atomic!
func Withdraw(amount int) bool {
    Deposit(-amount)
    if Balance() &lt; 0 {
        Deposit(amount)
        return false // insufficient funds
    }
    return true
}
</code></pre><p>理想情况下，取款应该只在整个操作中获得一次互斥锁。下面这样的尝试是错误的，Deposit会调用mu.Lock()第二次去获取互斥锁，但因为mutex已经锁上了，会导致程序死锁，没法继续执行下去，Withdraw会永远阻塞下去。</p>
<pre><code>// NOTE: incorrect!
func Withdraw(amount int) bool {
    mu.Lock()
    defer mu.Unlock()
    Deposit(-amount)
    if Balance() &lt; 0 {
        Deposit(amount)
        return false // insufficient funds
    }
    return true
}
</code></pre><p>解决方案是将一个函数分离为多个函数，比如我们把Deposit分离成两个：一个不导出的函数deposit，这个函数假设锁总是会被保持并去做实际的操作，另一个是导出的函数Deposit，这个函数会调用deposit，但在调用前会先去获取锁。同理我们可以将Withdraw也表示成这种形式：</p>
<pre><code>func Withdraw(amount int) bool {
    mu.Lock()
    defer mu.Unlock()
    deposit(-amount)
    if balance &lt; 0 {
        deposit(amount)
        return false // insufficient funds
    }
    return true
}

func Deposit(amount int) {
    mu.Lock()
    defer mu.Unlock()
    deposit(amount)
}

func Balance() int {
    mu.Lock()
    defer mu.Unlock()
    return balance
}

// This function requires that the lock be held.
func deposit(amount int) { balance += amount }
</code></pre><h2 id="93-syncrwmutex">9.3 sync.RWMutex</h2>
<p>sync.RWMutex：&ldquo;多读单写&quot;锁(multiple readers, single writer lock)。</p>
<h2 id="94-内存同步">9.4 内存同步</h2>
<p>并发编程时，使用互斥量，不仅仅是为了控制并发时的&quot;顺序问题&rdquo;，更重要的，还会涉及&quot;内存问题&quot;。</p>
<p>在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存(local cache)。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到。</p>
<p>看下例：</p>
<pre><code>var x, y int
go func() {
    x = 1 // A1
    fmt.Print(&quot;y:&quot;, y, &quot; &quot;) // A2
}()
go func() {
    y = 1                   // B1
    fmt.Print(&quot;x:&quot;, x, &quot; &quot;) // B2
}()
</code></pre><p>两个goroutine并发，<code>x, y</code>没有加锁，两个goroutine存在数据竞争，那么输出会是什么样子呢？
按常规思路，执行顺序，假设第一个goroutine先执行，再假设A2在B2前，又有隐藏条件A1一定在A2前，B1一定在B2前，那么这时候执行顺序就是 (A1 A2 B1 B2 或 A1 B1 A2 B2)，其他情况依次类推，那么输出可能如下：</p>
<pre><code>y:0 x:1
y:1 x:1
x:0 y:1
x:1 y:1
</code></pre><p>但是实际上，可能会得到如下的输出：</p>
<pre><code>x:0 y:0
y:0 x:0
</code></pre><p>这两种情况要怎么解释呢？
在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的，也就是说goroutine内顺序是连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没法保证事件在不同的goroutine中看到的执行顺序是一致的了。尽管goroutine A中一定需要观察到x=1执行成功之后才会去读取y，但它没法确保自己观察得到goroutine B中对y的写入，所以A还可能会打印出y的一个旧版的值。</p>
<p>尽管去理解并发的一种尝试是去将其运行理解为不同goroutine语句的交错执行，但看看上面的例子，这已经不是现代的编译器和cpu的工作方式了。因为赋值和打印指向不同的变量，编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序。如果两个goroutine在不同的CPU上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其它goroutine的Print，在主存同步之前就是不可见的了。</p>
<p>所有并发的问题都可以用一致的、简单的既定的模式来规避。所以可能的话，将变量限定在goroutine内部；如果是多个goroutine都需要访问的变量，使用互斥条件来访问。</p>
<h2 id="95-synconce惰性初始化">9.5 sync.Once惰性初始化</h2>
<p>如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。如果在程序启动的时候就去做这类初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量，所以实际上有一些浪费。</p>
<p>下面是一个懒初始化(lazy initialization)的例子：</p>
<pre><code>var icons map[string]image.Image

func loadIcons() {
    icons = map[string]image.Image{
        &quot;spades.png&quot;:   loadIcon(&quot;spades.png&quot;),
        &quot;hearts.png&quot;:   loadIcon(&quot;hearts.png&quot;),
        &quot;diamonds.png&quot;: loadIcon(&quot;diamonds.png&quot;),
        &quot;clubs.png&quot;:    loadIcon(&quot;clubs.png&quot;),
    }
}

// NOTE: not concurrency-safe!
func Icon(name string) image.Image {
    if icons == nil {
        loadIcons() // one-time initialization
    }
    return icons[name]
}
</code></pre><p>上面的例程在单独的goroutine内工作OK，但是并发调用时不安全。</p>
<p>Icon函数由多个步骤组成：首先测试icons是否为空，然后load这些icons，之后将icons更新为一个非空的值。</p>
<p>那么并发场景下上面例程最差的情况是什么呢？
loadIcons函数被多次访问会带来数据竞争。当第一个goroutine在忙着loading这些icons的时候，另一个goroutine进入了Icon函数，发现变量是nil，然后也会调用loadIcons函数；这看起来不是很致命，貌似能够保证最终一致性。
其实不然。
由于缺少显示的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个goroutine自己的执行顺序一致。其中一种可能loadIcons的语句重排是下面这样。它会在填写icons变量的值之前先用一个空map来初始化icons变量，然后逐个loadIcon；那么问题就来了，由于没有显示的同步，假设某个goroutine(g1)走到了step1，然后flush内存，然后其他的goroutine(g2)调用Icon函数，<code>icons == nil</code>条件不成立，但是此时icons还没有load任何东西，这就导致在g1没有将后续的load执行完并flush内存的这段期间，g2认为icons是已经被初始化的，但是却获得不到任何数据。所以其实数据的最终一致性并没有得到保障，进而可能引发一系列的逻辑bug。</p>
<pre><code>func loadIcons() {
    icons = make(map[string]image.Image)                // step1
    icons[&quot;spades.png&quot;] = loadIcon(&quot;spades.png&quot;)        // step2
    icons[&quot;hearts.png&quot;] = loadIcon(&quot;hearts.png&quot;)        // step3
    icons[&quot;diamonds.png&quot;] = loadIcon(&quot;diamonds.png&quot;)    // step4
    icons[&quot;clubs.png&quot;] = loadIcon(&quot;clubs.png&quot;)          // step5
}
</code></pre><p>最简单且正确的保证所有goroutine能够观察到loadIcons效果的方式，是用一个mutex来同步检查：</p>
<pre><code>var mu sync.Mutex // guards icons
var icons map[string]image.Image

// Concurrency-safe.
func Icon(name string) image.Image {
    mu.Lock()
    defer mu.Unlock()
    if icons == nil {
        loadIcons()
    }
    return icons[name]
}
</code></pre><p>上例的问题在于，该变量将完全无法并发访问，即使他已经被初始化完毕。要解决的话，可以使用读写锁：</p>
<pre><code>var mu sync.RWMutex // guards icons
var icons map[string]image.Image

// Concurrency-safe.
func Icon(name string) image.Image {
    mu.RLock()
    if icons != nil {
        icon := icons[name]
        mu.RUnlock()
        return icon
    }
    mu.RUnlock()

    // acquire an exclusive lock
    mu.Lock()
    if icons == nil { // NOTE: must recheck for nil
        loadIcons()
    }
    icon := icons[name]
    mu.Unlock()
    return icon
}
</code></pre><p>上面的代码有两个临界区。goroutine首先会获取一个读锁，查询map，然后释放锁。如果条目被找到了(一般情况下)，那么会直接返回。如果没有找到，那goroutine会获取一个写锁。不释放共享锁的话，也没有任何办法来将一个共享锁升级为一个互斥锁，所以我们必须重新检查icons变量是否为nil，以防止在执行这一段代码的时候，icons变量已经被其它gorouine初始化过了。</p>
<p>sync.Once可以更方便的完成上述操作。概念上来讲，一次性的初始化需要一个互斥量mutex和一个boolean变量来记录初始化是不是已经完成了；互斥量用来保护boolean变量和客户端数据结构。Do这个唯一的方法需要接收初始化函数作为其参数：</p>
<pre><code>var loadIconsOnce sync.Once
var icons map[string]image.Image

// Concurrency-safe.
func Icon(name string) image.Image {
    loadIconsOnce.Do(loadIcons)
    return icons[name]
}
</code></pre><h2 id="96-golang-race-detector">9.6 Golang Race Detector</h2>
<p>go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用。
竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。
竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证测试并发地覆盖了包。
由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的工作来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的debugging。</p>
<h2 id="98-goroutine-和-线程">9.8 goroutine 和 线程</h2>
<p><strong>goroutine</strong>和<strong>线程</strong>的区别实际上只是一个量的区别，但量变会引起质变。</p>
<h3 id="动态栈">动态栈</h3>
<p>每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。而对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。</p>
<p>相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。</p>
<h3 id="gouroutine调度">gouroutine调度</h3>
<p>OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。</p>
<p>Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工(调度)m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine（按程序独立）。</p>
<p>和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。</p>
<h3 id="gomaxprocs">GOMAXPROCS</h3>
<p>Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。(GOMAXPROCS是前面说的m:n调度中的n)。在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计算在内。</p>
<p>GOMAXPROCS的环境变量和runtime.GOMAXPROCS函数可以修改GOMAXPROCS。</p>
<p>runtime.GOMAXPROCS备注第一句：</p>
<pre><code>// GOMAXPROCS sets the maximum number of CPUs that can be executing
// simultaneously and returns the previous setting.
func GOMAXPROCS(n int) int
</code></pre><p>下面例子可以看到GOMAXPROCS效果：</p>
<pre><code>for {
    go fmt.Print(0)
    fmt.Print(1)
}

$ GOMAXPROCS=1 go run ***.go
111111111111111111110000000000000000000011111...

$ GOMAXPROCS=2 go run ***.go
010101010101010101011001100101011010010100110...
</code></pre><h3 id="goroutine没有id号">goroutine没有ID号</h3>
<p>在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份(id)，并且这个身份信息可以以一个普通值的形式被很容易地获取到，典型的可以是一个integer或者指针值。这种情况下我们做一个抽象化的thread-local storage(线程本地存储，多线程编程中不希望其它线程访问的内容)就很容易，只需要以线程的id作为key的一个map就可以解决问题，每一个线程以其id就能从中获取到值，且和其它线程互不冲突。</p>
<p>goroutine没有可以被程序员获取到的身份(id)的概念。这一点是设计上故意而为之，由于thread-local storage总是会被滥用。比如说，一个web server是用一种支持tls的语言实现的，而非常普遍的是很多函数会去寻找HTTP请求的信息，这代表它们就是去其存储层(这个存储层有可能是tls)查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能并不仅由自己的参数所决定，而是由其所运行在的线程所决定。因此，如果线程本身的身份会改变——比如一些worker线程之类的——那么函数的行为就会变得神秘莫测。</p>
<p>Go鼓励更为简单的模式，这种模式下参数(外部显式参数和内部显式参数。tls 中的内容算是&quot;外部&quot;隐式参数)对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。</p>
<h1 id="10-包和工具">10 包和工具</h1>
<p>Go语言有超过200个标准包（go list std）。标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设计、共享、重用和改进，目前互联网上已经发布了非常多的Go语言开源包，它们可以通过 <a href="http://godoc.org">godoc</a> 检索。
Go还自带了工具箱，里面有很多用来简化工作区和包管理的小工具。</p>
<p>Go语言编译器的编译速度明显快于其它编译语言，这主要得益于三个语言特性。</p>
<ul>
<li>第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li>
<li>第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。</li>
<li>第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件</li>
</ul>
<p>默认包名一般采用导入路径名的最后一段，有三个例外：</p>
<ul>
<li>第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序</li>
<li>第二个例外，包所在的目录中可能有一些文件名是以_test.go为后缀的Go源文件（前面必须有其它的字符，因为以_或.开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖
<ul>
<li>通俗的说，一个文件夹下一般只能有一个包名，但以_test.go 作为结尾的源码文件，可以用 $(被测试的包名)_test 作为包名，放置在相同源码目录下而不产生编译错误</li>
</ul>
</li>
<li>第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如&quot;gopkg.in/yaml.v2&quot;。这种情况下包的名字并不包含版本号后缀，而是yaml</li>
</ul>
<p>导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以将&quot;path&quot;标准包重命名为pathpkg:</p>
<pre><code>import (
    &quot;crypto/rand&quot;
    mrand &quot;math/rand&quot; // alternative name mrand avoids conflict
)
</code></pre><p>如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数。可以用下划线_来重命名导入的包。这就是<strong>包的匿名导入</strong>：</p>
<pre><code>import _ &quot;image/png&quot; // register PNG decoder
</code></pre><p>包的命名：简短，有描述行且无歧义，一般采用单数形式(标准库的一些复数形式是为了避免和预定义的类型或关键字冲突)。</p>
<h3 id="107-golang工具">10.7 Golang工具</h3>
<p>go help或者go help <!-- raw HTML omitted -->可以查看帮助信息。</p>
<p>下载包：go get
构建包：go build
包文档：go doc (PS: 还有一个 godoc)
查询包：go list</p>
<h1 id="11-测试">11 测试</h1>
<p>Go语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的，而且它很容易延伸到基准测试和示例文档。</p>
<p>go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。</p>
<p>在*_test.go文件中，有三种类型的函数：测试函数、基准测试(benchmark)函数、示例函数。</p>
<ul>
<li>测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL</li>
<li>基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间</li>
<li>示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档</li>
</ul>
<p>go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<p>基准测试：<a href="https://docs.hacknode.org/gopl-zh/ch11/ch11-04.html">The Go Programming Language 11.4 基准测试</a></p>
<p>示例函数：<a href="https://docs.hacknode.org/gopl-zh/ch11/ch11-06.html">The Go Programming Language 11.6 示例函数</a></p>
<h1 id="12-反射">12 反射</h1>
<p>Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。</p>
<p>反射是一个复杂的内省技术，不应该随意使用。</p>
<h2 id="122-reflecttype和reflectvalue">12.2 reflect.Type和reflect.Value</h2>
<p><code>reflect.Type</code>表示一个Go类型。<code>Type</code>是<code>interface{}</code>, 有许多方法来区分类型以及检查它们的组成部分, 例如一个结构体的成员或一个函数的参数等。
函数<code>reflect.TypeOf</code>接受任意的<code>interface{}</code>类型, 并以<code>reflect.Type</code>形式返回其动态类型。
<code>reflect.TypeOf</code>总是返回具体的类型：</p>
<pre><code>var w io.Writer = os.Stdout
fmt.Println(reflect.TypeOf(w)) // &quot;*os.File&quot;
</code></pre><p>一个<code>reflect.Value</code>可以装载任意类型的值。函数<code>reflect.ValueOf</code>接受任意的<code>interface{}</code>类型, 并返回一个装载着其动态值的<code>reflect.Value</code>。和<code>reflect.TypeOf</code>类似,<code>reflect.ValueOf</code>返回的结果也是具体的类型, 但是<code>reflect.Value</code>也可以持有一个接口值。</p>
<h2 id="123-通过reflectvalue修改值">12.3 通过reflect.Value修改值</h2>
<p>有些reflect.Value可取地址，有些不可以：</p>
<pre><code>x := 2                   // value   type    variable?
a := reflect.ValueOf(2)  // 2       int     no
b := reflect.ValueOf(x)  // 2       int     no
c := reflect.ValueOf(&amp;x) // &amp;x      *int    no
d := c.Elem()            // 2       int     yes (x)
</code></pre><p><strong>所有通过reflect.ValueOf(x)返回的reflect.Value都是不可取地址的</strong>。
但是对于上例中的d，它是c的解引用方式生成的，指向另一个变量，因此是可取地址的。
<strong>可以通过调用reflect.ValueOf(&amp;x).Elem()，来获取任意变量x对应的可取地址的Value</strong>。
CanAddr方法可以判断reflect.Value是否可取地址：</p>
<pre><code>fmt.Println(a.CanAddr()) // &quot;false&quot;
fmt.Println(b.CanAddr()) // &quot;false&quot;
fmt.Println(c.CanAddr()) // &quot;false&quot;
fmt.Println(d.CanAddr()) // &quot;true&quot;
</code></pre><p>从变量对应的可取地址的reflect.Value来访问变量需要三个步骤:</p>
<ul>
<li>第一步，调用Addr()方法，它返回一个Value，里面保存了指向变量的指针</li>
<li>第二步，在Value上调用Interface()方法，也就是返回一个interface{}，里面包含指向变量的指针</li>
<li>第三步，如果明确知道变量的类型，可以使用类型的断言机制将得到的interface{}类型的接口强制转为普通的类型指针，然后通过这个普通指针来更新变量</li>
</ul>
<pre><code>x := 2
d := reflect.ValueOf(&amp;x).Elem()   // d refers to the variable x
px := d.Addr().Interface().(*int) // px := &amp;x
*px = 3                           // x = 3
fmt.Println(x)                    // &quot;3&quot;

----------------------------------------------------------------

// 或者使用reflect.Value.Set方法
d.Set(reflect.ValueOf(4))   // 注意！这里类型不匹配会panic；d不可取址当然也会panic
fmt.Println(x) // &quot;4&quot;
</code></pre><p>reflect.Value.Set方法可以完成可取址reflect.Value的赋值操作，但是必须类型匹配；同时，Set方法也有很多基于数据类型的方法：SetInt、SetUint、SetString、SetFloat等。只要reflect.Value对应的可取址变量的底层类型与Set类型可赋值即可(可能会发生截断影响精读)。但是，如果reflect.Value本身对应一个interface{},不能使用具体类型的Set方法例如SetInt、SetString等，而应该使用Set:</p>
<pre><code>x := 1
rx := reflect.ValueOf(&amp;x).Elem()
rx.SetInt(2)                     // OK, x = 2
rx.Set(reflect.ValueOf(3))       // OK, x = 3
rx.SetString(&quot;hello&quot;)            // panic: string is not assignable to int
rx.Set(reflect.ValueOf(&quot;hello&quot;)) // panic: string is not assignable to int

var y interface{}
ry := reflect.ValueOf(&amp;y).Elem()
ry.SetInt(2)                     // panic: SetInt called on interface Value
ry.Set(reflect.ValueOf(3))       // OK, y = int(3)
ry.SetString(&quot;hello&quot;)            // panic: SetString called on interface Value
ry.Set(reflect.ValueOf(&quot;hello&quot;)) // OK, y = &quot;hello&quot;
</code></pre><p>可以越过Go语言的导出规则的限制读取结构体中未导出的成员，比如在类Unix系统上os.File结构体中的fd int成员。然而，利用反射机制并不能修改这些未导出的成员：</p>
<pre><code>stdout := reflect.ValueOf(os.Stdout).Elem() // *os.Stdout, an os.File var
fmt.Println(stdout.Type())                  // &quot;os.File&quot;
fd := stdout.FieldByName(&quot;fd&quot;)
fmt.Println(fd.Int()) // &quot;1&quot;
fd.SetInt(2)          // panic: unexported field
</code></pre><p>一个可取地址的reflect.Value会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。因此，CanAddr方法并不能正确反映一个变量是否是可以被修改的。另一个相关的方法CanSet是用于检查对应的reflect.Value是否是可取地址并可被修改的：</p>
<pre><code>fmt.Println(fd.CanAddr(), fd.CanSet()) // &quot;true false&quot;
</code></pre><h2 id="127-获取结构体字段标签">12.7 获取结构体字段标签</h2>
<pre><code>// search implements the /search URL endpoint.
func search(resp http.ResponseWriter, req *http.Request) {
    var data struct {
        Labels     []string `http:&quot;l&quot;`
        MaxResults int      `http:&quot;max&quot;`
        Exact      bool     `http:&quot;x&quot;`
    }
    data.MaxResults = 10 // set default
    if err := params.Unpack(req, &amp;data); err != nil {
        http.Error(resp, err.Error(), http.StatusBadRequest) // 400
        return
    }

    // ...rest of handler...
    fmt.Fprintf(resp, &quot;Search: %+v\n&quot;, data)
}

--------------------------------------------------------------------

// Unpack populates the fields of the struct pointed to by ptr
// from the HTTP request parameters in req.
func Unpack(req *http.Request, ptr interface{}) error {
    if err := req.ParseForm(); err != nil {
        return err
    }

    // Build map of fields keyed by effective name.
    fields := make(map[string]reflect.Value)
    v := reflect.ValueOf(ptr).Elem() // the struct variable
    for i := 0; i &lt; v.NumField(); i++ {
        fieldInfo := v.Type().Field(i) // a reflect.StructField
        tag := fieldInfo.Tag           // a reflect.StructTag
        name := tag.Get(&quot;http&quot;)
        if name == &quot;&quot; {
            name = strings.ToLower(fieldInfo.Name)
        }
        fields[name] = v.Field(i)
    }

    // Update struct field for each parameter in the request.
    for name, values := range req.Form {
        f := fields[name]
        if !f.IsValid() {
            continue // ignore unrecognized HTTP parameters
        }
        for _, value := range values {
            if f.Kind() == reflect.Slice {
                elem := reflect.New(f.Type().Elem()).Elem()
                if err := populate(elem, value); err != nil {
                    return fmt.Errorf(&quot;%s: %v&quot;, name, err)
                }
                f.Set(reflect.Append(f, elem))
            } else {
                if err := populate(f, value); err != nil {
                    return fmt.Errorf(&quot;%s: %v&quot;, name, err)
                }
            }
        }
    }
    return nil
}

--------------------------------------------------------------------

func populate(v reflect.Value, value string) error {
    switch v.Kind() {
    case reflect.String:
        v.SetString(value)

    case reflect.Int:
        i, err := strconv.ParseInt(value, 10, 64)
        if err != nil {
            return err
        }
        v.SetInt(i)

    case reflect.Bool:
        b, err := strconv.ParseBool(value)
        if err != nil {
            return err
        }
        v.SetBool(b)

    default:
        return fmt.Errorf(&quot;unsupported kind %s&quot;, v.Type())
    }
    return nil
}

--------------------------------------------------------------------

output:

$ ./search &amp;
$ ./fetch 'http://localhost:12345/search'
Search: {Labels:[] MaxResults:10 Exact:false}
$ ./fetch 'http://localhost:12345/search?l=golang&amp;l=programming'
Search: {Labels:[golang programming] MaxResults:10 Exact:false}
$ ./fetch 'http://localhost:12345/search?l=golang&amp;l=programming&amp;max=100'
Search: {Labels:[golang programming] MaxResults:100 Exact:false}
$ ./fetch 'http://localhost:12345/search?x=true&amp;l=golang&amp;l=programming'
Search: {Labels:[golang programming] MaxResults:10 Exact:true}
$ ./fetch 'http://localhost:12345/search?q=hello&amp;x=123'
x: strconv.ParseBool: parsing &quot;123&quot;: invalid syntax
$ ./fetch 'http://localhost:12345/search?q=hello&amp;max=lots'
max: strconv.ParseInt: parsing &quot;lots&quot;: invalid syntax
</code></pre><h2 id="128-显示一个类型的方法集">12.8 显示一个类型的方法集</h2>
<pre><code>// Print prints the method set of the value x.
func Print(x interface{}) {
    v := reflect.ValueOf(x)
    t := v.Type()
    fmt.Printf(&quot;type %s\n&quot;, t)

    for i := 0; i &lt; v.NumMethod(); i++ {
        methType := v.Method(i).Type()
        fmt.Printf(&quot;func (%s) %s%s\n&quot;, t, t.Method(i).Name,
            strings.TrimPrefix(methType.String(), &quot;func&quot;))
    }
}

-----------------------------------------------------------

methods.Print(time.Hour)
// Output:
// type time.Duration
// func (time.Duration) Hours() float64
// func (time.Duration) Minutes() float64
// func (time.Duration) Nanoseconds() int64
// func (time.Duration) Seconds() float64
// func (time.Duration) String() string

methods.Print(new(strings.Replacer))
// Output:
// type *strings.Replacer
// func (*strings.Replacer) Replace(string) string
// func (*strings.Replacer) WriteString(io.Writer, string) (int, error)
</code></pre><h2 id="129-关于reflect的几点忠告">12.9 关于reflect的几点忠告</h2>
<p>反射是一个强大并富有表达力的工具，但是它应该被小心地使用：</p>
<ul>
<li>第一个原因是，基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出panic异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间
<ul>
<li>避免这种因反射而导致的脆弱性的问题的最好方法，是将所有的反射相关的使用控制在包的内部，如果可能的话避免在包的API中直接暴露reflect.Value类型，这样可以限制一些非法输入。如果无法做到这一点，在每个有风险的操作前指向额外的类型检查。以标准库中的代码为例，当fmt.Printf收到一个非法的操作数时，它并不会抛出panic异常，而是打印相关的错误信息。程序虽然还有BUG，但是会更加容易诊断：</li>
</ul>
<pre><code>fmt.Printf(&quot;%d %s\n&quot;, &quot;hello&quot;, 42) // &quot;%!d(string=hello) %!s(int=42)&quot;
</code></pre></li>
<li>第二个原因是，即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受interface{}或reflect.Value类型参数的函数维护说明文档</li>
<li>第三个原因，基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以当反射能使程序更加清晰的时候可以考虑使用。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射</li>
</ul>
<p>关于reflect导致性能下滑有鸟窝的blog记载： <a href="https://colobu.com/2019/01/29/go-reflect-performance/">Go Reflect 性能</a></p>
<h1 id="13-底层编程">13 底层编程</h1>
<h2 id="131-unsafe-sizeof-alignof-offsetof">13.1 unsafe: Sizeof, Alignof, Offsetof</h2>
<p>unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。Sizeof函数返回的大小只包括数据结构中固定的部分，例如字符串对应结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小在32位平台上是4个字节，在64位平台上是8个字节。</p>
<p>计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。
由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>1个字节</td>
</tr>
<tr>
<td>intN, uintN, floatN, complexN</td>
<td>N/8个字节(例如float64是8个字节)</td>
</tr>
<tr>
<td>int, uint, uintptr</td>
<td>1个机器字</td>
</tr>
<tr>
<td>*T</td>
<td>1个机器字</td>
</tr>
<tr>
<td>string</td>
<td>2个机器字(data,len)</td>
</tr>
<tr>
<td>[]T</td>
<td>3个机器字(data,len,cap)</td>
</tr>
<tr>
<td>map</td>
<td>1个机器字</td>
</tr>
<tr>
<td>func</td>
<td>1个机器字</td>
</tr>
<tr>
<td>chan</td>
<td>1个机器字</td>
</tr>
<tr>
<td>interface</td>
<td>2个机器字(type,value)</td>
</tr>
</tbody>
</table>
<p>下面的三个结构体虽然有着相同的字段，但是第一种写法比另外的两个需要多50%的内存:</p>
<pre><code>                               // 64-bit  32-bit
struct{ bool; float64; int16 } // 3 words 4words
struct{ float64; int16; bool } // 2 words 3words
struct{ bool; int16; float64 } // 2 words 3words
</code></pre><p>unsafe.Alignof 函数返回对应参数的类型需要对齐的倍数。
unsafe.Offsetof 函数的参数必须是一个字段 x.f, 然后返回 f 字段相对于 x 起始地址的偏移量, 包括可能的空洞。</p>
<p>举个例子：</p>
<pre><code>var x struct {
    a bool
    b int16
    c []int
}
</code></pre><p>图( 灰色区域是空洞)：
<img src="/images/The-Go-Programming-Language/unsafe.png" alt="unsafe"></p>
<p>32位系统：</p>
<pre><code>Sizeof(x)   = 16  Alignof(x)   = 4
Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0
Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2
Sizeof(x.c) = 12  Alignof(x.c) = 4 Offsetof(x.c) = 4
</code></pre><p>64位系统：</p>
<pre><code>Sizeof(x)   = 32  Alignof(x)   = 8
Sizeof(x.a) = 1   Alignof(x.a) = 1 Offsetof(x.a) = 0
Sizeof(x.b) = 2   Alignof(x.b) = 2 Offsetof(x.b) = 2
Sizeof(x.c) = 24  Alignof(x.c) = 8 Offsetof(x.c) = 8
</code></pre><p>虽然这几个函数在不安全的unsafe包，但是这几个函数调用并不是真的不安全，特别在需要优化内存空间时它们返回的结果对于理解原生的内存布局很有帮助。</p>
<h2 id="132-unsafepointer">13.2 unsafe.Pointer</h2>
<p>大多数指针类型会写成*T，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义的一种指针类型（类似C语言中的void*类型的指针），它可以包含任意类型变量的地址。当然，我们不可以直接通过*p来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。</p>
<p>一个普通的<em>T类型指针可以被转化为unsafe.Pointer类型指针，并且一个unsafe.Pointer类型指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的</em>T类型相同。通过将<em>float64类型指针转化为</em>uint64类型指针，我们可以查看一个浮点数变量的位模式:</p>
<pre><code>package math

func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&amp;f)) }

fmt.Printf(&quot;%#016x\n&quot;, Float64bits(1.0)) // &quot;0x3ff0000000000000&quot;
</code></pre><h2 id="134-通过cgo调用c代码">13.4 通过cgo调用C代码</h2>
<p>Go语言自带的cgo可以支援C语言函数调用的工具。
这类工具一般被称为 foreign-function interfaces （ffi）。
ffi不仅包括cgo，<a href="http://swig.org">SWIG</a>是另一个类似的且被广泛使用的工具，SWIG提供了很多复杂特性以支持C++。</p>
<p>如果是比较小的C语言库，完全可以用纯Go语言重新实现一遍。
如果对性能没有特殊要求的话，还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行（用os/exec包调用子进程的方法会导致程序运行时依赖那个应用程序）。
<strong>只有当需要使用复杂而且性能更高的底层C接口时，才是使用cgo的场景</strong>。</p>
<p><code>import C</code>必须单独一行。</p>
<p><code>import &quot;C&quot;</code>的语句是比较特别的，其实并没有一个叫C的包，但是这行语句会让Go编译程序在编译之前先运行cgo工具。</p>
<p><code>import &quot;C&quot;</code>语句前紧挨着的注释是对应cgo的特殊语法，对应必要的构建参数选项和C语言代码。在预处理过程中，cgo工具生成一个临时包用于包含所有在Go语言中访问的C语言的函数或类型。</p>
<p>在cgo注释中还可以包含#cgo指令，用于给C语言工具链指定特殊的参数。</p>
<p>举个简单例子：</p>
<pre><code>// 只有go文件

package main

/*
#include &lt;stdio.h&gt;

void print(const char* s)
{
    puts(s);
}
*/
import &quot;C&quot;

func main() {
	C.print(C.CString(&quot;test&quot;))
}

------------------------------------

// go文件 + c文件

// c文件
#include &lt;stdio.h&gt;

void print(const char* s){
    puts(s);
}

// go文件
package main

//void print(const char* s);
import &quot;C&quot;

func main() {
	C.print(C.CString(&quot;test&quot;))
}

// 注意！！！go run .或go build测试效果
</code></pre><p>关于cgo更多的细节，可以看<a href="https://chai2010.cn/advanced-go-programming-book/ch2-cgo/readme.html">Go语言高级编程第2章</a>。</p>
<h2 id="135-忠告">13.5 忠告</h2>
<p>unsafe包让程序员可以透过这个绝缘的抽象层直接使用一些必要的功能，代价就是牺牲了可移植性和程序安全，因此使用unsafe包是一个危险的行为。</p>

                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">Last modified on 2021-06-25</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="https://duck-dd.github.io/posts/go-tips/">
			Next<br>Golang Tips For Me (continuously updated)
                </a>
                
                
                
                <a class="older-posts" href="https://duck-dd.github.io/posts/dns-bind/">
			Previous<br>DNS,挺好,啥是DNS?
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                


<div id="gitalk-container"></div>







        
            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer"><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Songti SC'; color: #000000; -webkit-text-stroke: #000000}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none; color: #0000e3; -webkit-text-stroke: 0px #0000e3}
    span.s3 {font: 12.0px Times; font-kerning: none}
  </style>
</head>
<body>
<p class="p1"><span class="s1">Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary"><span class="s2">Diary</span></a> by <a href="https://amazingrise.net/"><span class="s2">Rise</span></a></span><span class="s2">.</span><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1">学艺不精, 委屈您的眼睛了</span><span class="s3"><br>
</span></p>
<p class="p1"><span class="s1">©  ztq. </span></p>
</body>
</html>
</div>
            </div>
    <script>
let app;

app = new Vue({
    el: '#app',
    data: {
        scrollY: 0,
        navOpacity: 0,
        isDrawerOpen: false,
        mounted: false,
        isDarkMode: false
    },
    methods: {
            sgn(t, x) {
                let k = 1. / (1. - 2 * t);
                if (x <= t) return 0;
                else if (x >= 1 - t) return 1;
                else {
                    return k * (x - t);
                }
            },
            handleScroll() {
                this.scrollY = window.scrollY;
                this.navOpacity = this.sgn(.0, Math.min(1, Math.max(0, window.scrollY / (this.pageHeadHeight() - this.navBarHeight() * 0.8))));
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;

                if (this.navOpacity >= 1) {
                    navBackground.style.opacity = 1;
                    navTitle.style.opacity = 1;
                } else {
                    navBackground.style.opacity = 0;
                    navTitle.style.opacity = 0;
                }
            },
            handleResize() {
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;
                extraContainer.style.left = (streamContainer.offsetWidth - extraContainer.offsetWidth) + 'px';
            },
            navBarHeight() {
                return this.$refs.navBar.offsetHeight;
            },
            pageHeadHeight() {
                return this.$refs.pageHead.offsetHeight;
            },
            toggleDrawer() {
                this.isDrawerOpen = !this.isDrawerOpen;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            closeDrawer() {
                this.isDrawerOpen = false;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            toggleDarkMode() {
                this.isDarkMode = !this.isDarkMode;
                if (this.isDarkMode==true){
                    document.cookie = "night=1;path=/";
                    document.body.classList.add("night");
                } else {
                    document.cookie = "night=0;path=/";
                    document.body.classList.remove("night");
                }
            }
    },
    created() {
        window.addEventListener('scroll', this.handleScroll);
        window.addEventListener('resize', this.handleResize);
        window._nonDesktop = function () {
            let check = false;
            (function (a) {
                if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
            })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
        };
        
        var night = document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1");
        if (night==""){
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                
            }
        }else{
            
            if (night=="1") {
                this.toggleDarkMode();
            }
        }
    },
    mounted() {
        this.handleScroll();
        this.handleResize();
        this.mounted = true;

        
        
    },
    destroyed() {
        window.removeEventListener('scroll', this.handleScroll);
        window.removeEventListener('resize', this.handleResize);
    }
});
</script>

<script src="/js/journal.js"></script>

    </body>
</html>
