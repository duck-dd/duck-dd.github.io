<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>2025 on Duck</title>
    <link>https://duck-dd.github.io/tags/2025/</link>
    <description>Recent content in 2025 on Duck</description>
    <image>
      <title>Duck</title>
      <url>https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.147.8</generator>
    <language>en</language>
    <lastBuildDate>Tue, 19 Aug 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://duck-dd.github.io/tags/2025/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>越南</title>
      <link>https://duck-dd.github.io/posts/%E8%B6%8A%E5%8D%97/</link>
      <pubDate>Tue, 19 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/%E8%B6%8A%E5%8D%97/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E8%B6%8A%E5%8D%97/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;越南地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E8%B6%8A%E5%8D%97/map_of_vietnam.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 越南地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;今天简单了解一下越南。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：越南 越南社会主义共和国 Vietnam&lt;/li&gt;
&lt;li&gt;语言：越南语&lt;/li&gt;
&lt;li&gt;首都：河内(Ha Noi)&lt;/li&gt;
&lt;li&gt;国土面积：&lt;code&gt;33万&lt;/code&gt;平方公里&lt;/li&gt;
&lt;li&gt;位置：中南半岛东部&lt;/li&gt;
&lt;li&gt;气候：热带季风气候；高温多雨，北方分春、夏、秋、冬四季，南方雨旱两季分明&lt;/li&gt;
&lt;li&gt;邻(近)国：北与中国接壤，西与老挝、柬埔寨交界，东和南 临南海&lt;/li&gt;
&lt;li&gt;人口：&lt;code&gt;1亿&lt;/code&gt;多一点&lt;/li&gt;
&lt;li&gt;政治体制：一党制，越南共产党是越南唯一的政党&lt;/li&gt;
&lt;li&gt;经济制度：社会主义定向的市场经济制度&lt;/li&gt;
&lt;li&gt;社会制度：社会主义制度&lt;/li&gt;
&lt;li&gt;货币：越南盾，简称越盾，货币代码VND，货币符号 &amp;ldquo;₫&amp;rdquo;&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：&lt;code&gt;11.511万亿&lt;/code&gt;越盾，约合&lt;code&gt;4763亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立法：国会是越南的国家最高权力机关，也是全国唯一的立法机构&lt;/li&gt;
&lt;li&gt;文化：越南文化融合了本土、中国影响、东南亚民族特色、殖民影响等因素；传统服饰：奥黛&lt;/li&gt;
&lt;li&gt;宗教信仰：佛教、天主教、和好教、高台教&lt;/li&gt;
&lt;li&gt;美食：以 “新鲜、清淡、均衡” 为核心，充满东南亚风情与中国饮食痕迹，使用筷子；“鲜 香 酸 辣”；河粉、春卷&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;省/直辖市 &amp;mdash;&amp;gt; 县/市社/郡 &amp;mdash;&amp;gt; 社(农村)/市镇(介于农村和城市之间)/坊(城市)&lt;/li&gt;
&lt;li&gt;全国划分为28个省和6个直辖市(河内市、胡志明市、海防市、岘港市、芹苴市和顺化市)&lt;/li&gt;
&lt;li&gt;主要城市：
&lt;ul&gt;
&lt;li&gt;河内市(Hà Nội, HN, HAN)：首都，越南政治、文化中心&lt;/li&gt;
&lt;li&gt;胡志明市(Thành phố Hồ Chí Minh, HCM, SGN)：旧称西贡，是越南的经济中心、全国最大的港口和交通枢纽，位于湄公河三角洲的东北侧、南临南中国海&lt;/li&gt;
&lt;li&gt;海防(Hai Phong, HP, HPH)：越南北部最大港口城市，位于红河三角洲东北端，京泰河下游，东临北部湾&lt;/li&gt;
&lt;li&gt;岘港(Da Nang, DN, DAD)：位于越南中部，濒临南海，是全国重要的工业城市和海港&lt;/li&gt;
&lt;li&gt;芹苴(Can Tho, CT, VCA)：在后江省南面，下辖4郡4县，是湄公河三角洲上最大的城市，是南部湄公河三角洲农产品集散地和轻工业基地&lt;/li&gt;
&lt;li&gt;顺化：位于越南中部，是越南古都&lt;/li&gt;
&lt;li&gt;下龙(这个不是直辖市)：广宁省省会，位于北部湾的西岸，濒临下龙湾，是越南著名的旅游城市和重要海港，也是越南乃至东南亚的煤都；其著名景点下龙湾有着“海上桂林”的美誉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;红河三角洲地区早在新石器时代就有人类活动，公元前3世纪出现“瓯雒国”（传说由骆越部落建立），是越南最早的政权雏形&lt;/li&gt;
&lt;li&gt;公元前214年，秦始皇征服岭南，越南北部纳入中国版图，此后历经两汉、三国、隋唐等朝代，设 “交趾”“安南都护府” 等行政机构&lt;/li&gt;
&lt;li&gt;公元968年成为独立的封建国家，丁部领建立“丁朝”，定都华闾（今宁平省），正式脱离中国独立，称“大瞿越”，随后历经前黎朝、李朝、陈朝、胡朝、后黎朝等朝代&lt;/li&gt;
&lt;li&gt;1858年，法国以传教士问题为借口，逐步占领越南&lt;/li&gt;
&lt;li&gt;1887年，法国将越南与柬埔寨、老挝合并为 “法属印度支那联邦”，实行殖民统治，掠夺资源并推行西方化改革&lt;/li&gt;
&lt;li&gt;1930年，越南民族主义觉醒，胡志明等革命者成立“越南共产党”&lt;/li&gt;
&lt;li&gt;1940年，日本趁机占领越南，取代法国控制权，越南人民同时抗击法、日侵略&lt;/li&gt;
&lt;li&gt;1945年，“八月革命”后，胡志明宣布成立“越南民主共和国”（北越）；但法国试图重建殖民统治，引发“抗法战争”（1946—1954年）。1954年“奠边府战役”北越获胜，《日内瓦协定》签订，越南以北纬17度线分为北越（社会主义）和南越（资本主义）&lt;/li&gt;
&lt;li&gt;1955—1975年，南越在美国支持下成立政权，南北越矛盾激化。20世纪60年代，美国为遏制共产主义，逐步升级对越南的军事干预，发动“越南战争”（1961—1973年），美军最多投入50万兵力，战争造成巨大伤亡和破坏&lt;/li&gt;
&lt;li&gt;1973年，美军撤军&lt;/li&gt;
&lt;li&gt;1975年，北越军队攻占西贡（今胡志明市），南越政权覆灭&lt;/li&gt;
&lt;li&gt;1976年，越南正式统一，定国名为 “越南社会主义共和国”，定都河内&lt;/li&gt;
&lt;li&gt;1986年，越共六大推行 “革新开放” 政策，引入市场经济元素，吸引外资，发展出口加工产业，经济快速增长&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;额外说明：中国对越自卫反击战(苏联与越南签订军事同盟条约，试图通过越南牵制中国，形成对华战略包围圈)
&lt;ul&gt;
&lt;li&gt;作战阶段：1979年&lt;/li&gt;
&lt;li&gt;边境轮战阶段：1980-1989&lt;/li&gt;
&lt;li&gt;停战：1990越南主动寻求停战&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>印尼</title>
      <link>https://duck-dd.github.io/posts/%E5%8D%B0%E5%B0%BC/</link>
      <pubDate>Fri, 15 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/%E5%8D%B0%E5%B0%BC/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;世界地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%8D%B0%E5%B0%BC/maps_of_the_world.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 世界地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;&lt;img alt=&#34;印尼地图(from www.worldmap1.com)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/%E5%8D%B0%E5%B0%BC/republic_of_indonesia_map.jpg&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 印尼地图(from www.worldmap1.com)&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;center&gt;&lt;/center&gt;
&lt;p&gt;最近深度参与一些海外业务，今天了解一下印尼。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称：印度尼西亚 印尼 Indonesia&lt;/li&gt;
&lt;li&gt;语言：印度尼西亚语&lt;/li&gt;
&lt;li&gt;首都：雅加达(Jakarta，JKT) 逐步迁移至 努山塔拉(Ibu Kota Nusantara，缩写IKN)&lt;/li&gt;
&lt;li&gt;国土面积：&lt;code&gt;191.4万&lt;/code&gt;平方公里(陆) &lt;code&gt;316.6万&lt;/code&gt;平方公里(海)&lt;/li&gt;
&lt;li&gt;位置：亚洲东南部，太平洋印度洋之间&lt;/li&gt;
&lt;li&gt;气候：赤道海洋性气候；炎热，潮湿多雨；旱季6-9月，雨季12-3月&lt;/li&gt;
&lt;li&gt;邻(近)国：巴布亚新几内亚 东帝汶 马来西亚 泰国 新加坡 菲律宾 澳大利亚&lt;/li&gt;
&lt;li&gt;人口：约&lt;code&gt;3亿&lt;/code&gt; 世界第四&lt;/li&gt;
&lt;li&gt;政治体制：总统制共和制&lt;/li&gt;
&lt;li&gt;经济制度：市场经济体制&lt;/li&gt;
&lt;li&gt;社会制度：资本主义制度&lt;/li&gt;
&lt;li&gt;货币：印度尼西亚盾，简称印尼盾，货币代码&lt;code&gt;IDR&lt;/code&gt;，货币符号&lt;code&gt;RP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GDP：
&lt;ul&gt;
&lt;li&gt;2024：名义GDP为&lt;code&gt;22138.96万亿&lt;/code&gt;印尼盾，折合&lt;code&gt;13967.87亿&lt;/code&gt;美元&lt;/li&gt;
&lt;li&gt;对比中国，2024 中国大陆名义GDP总量折合&lt;code&gt;189433.42亿&lt;/code&gt;美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立法：每个省有自己的立法机关&lt;/li&gt;
&lt;li&gt;文化：传统服饰“巴迪克”；舞蹈(巴厘舞，爪哇舞)；雕塑&lt;/li&gt;
&lt;li&gt;宗教信仰：伊斯兰教(87%) 基督教(6%) 天主教(3.6%)&lt;/li&gt;
&lt;li&gt;美食：沙嗲、印尼炒饭、gado-gado（什锦蔬菜沙拉）等；口味融合了甜、辣、酸等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国家内部 行政区域/地理区域 划分&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;省 &amp;mdash;&amp;gt; 县/市 &amp;mdash;&amp;gt; 区 &amp;mdash;&amp;gt; 村/社区&lt;/li&gt;
&lt;li&gt;38个省&lt;/li&gt;
&lt;li&gt;主要城市：
&lt;ul&gt;
&lt;li&gt;雅加达(Jakarta, JKT)：印尼最大的城市，位于爪哇岛西北部沿海&lt;/li&gt;
&lt;li&gt;泗水(Surabaya, SUB,SUR)：印尼第二大城市，东爪哇省的省会，位于爪哇岛东北沿海的泗水海峡西南侧&lt;/li&gt;
&lt;li&gt;万隆（Bandung, BDO）：西爪哇省的省会，位于爪哇岛西部的万隆盆地中&lt;/li&gt;
&lt;li&gt;棉兰（Medan, MES）：苏北省省会，位于苏门答腊岛北部，是苏门答腊岛最大城市&lt;/li&gt;
&lt;li&gt;三宝垄（Semarang, SRG,CGK）：中爪哇省的省会，位于爪哇岛中部北岸，是爪哇岛中部地区重要的交通枢纽及商品集散地&lt;/li&gt;
&lt;li&gt;望加锡（Makassar, MAK,UPG）：南苏拉威西省的省会，位于苏拉威西岛南端，是苏拉威西岛最大的城市&lt;/li&gt;
&lt;li&gt;登巴萨（Denpasar, DPS）：巴厘省的省会，位于巴厘岛南部，是巴厘岛的政治、经济和文化中心&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史进程简述&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;公元3-7世纪开始有部落记载&lt;/li&gt;
&lt;li&gt;13世纪末14世纪初，满者伯夷帝国在东爪哇建立&lt;/li&gt;
&lt;li&gt;1602年荷兰成立东印度公司，成为荷兰殖民地&lt;/li&gt;
&lt;li&gt;1942年日本入侵，印尼进入日本统治时期&lt;/li&gt;
&lt;li&gt;1945年8月15日，日本投降，苏加诺宣布印度尼西亚独立&lt;/li&gt;
&lt;li&gt;1949年12月，荷兰正式承认印尼独立&lt;/li&gt;
&lt;li&gt;1970年代后，从传统的计划经济向市场经济转变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>目标管理法</title>
      <link>https://duck-dd.github.io/posts/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%E6%B3%95/</link>
      <pubDate>Wed, 13 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%E6%B3%95/</guid>
      <description>&lt;p&gt;当我们写KPI时，我们在写什么？当我们写OKR时，我们在写什么？&lt;/p&gt;
&lt;p&gt;这个问题困扰了许久，从个人的角度，我一直把这些东西当成枷锁，今晚突然寻思，我为什么不能认真审视这个东西，既然总是要花精力来处理，那不如把这个工具用起来。
人都是渴望自由的，或者至少这么说，放纵总是使绝大多数人快乐的；所以前面我们说目标管理是一种枷锁，但是枷锁未必是坏的东西，它也可能是一种推你向上的动力。
在第一次工作中接触OKR时，我当天就给自己的生活也定了好几个OKR，虽然一个也没实现，但是却还是给了我一些挣扎的动力来往前走了几步。&lt;strong&gt;求其上者得其中，求其下者无所得&lt;/strong&gt;，希望无论是工作还是生活，我们能够永远保持对&lt;code&gt;O&lt;/code&gt;的无上憧憬。&lt;/p&gt;
&lt;h2 id=&#34;我理解的-okr&#34;&gt;我理解的 O+KR&lt;/h2&gt;
&lt;p&gt;对于&lt;code&gt;O&lt;/code&gt;，我认为就一个原则，把最终状态描述清楚，这个状态一般比较遥远(美好)但却不是遥不可及(务实)，精髓在于对于 &lt;strong&gt;遥远&lt;/strong&gt; 的把控。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;KR&lt;/code&gt;，人们常说的最关键的特性就是，&lt;strong&gt;可量化&lt;/strong&gt;。一组&lt;code&gt;KR&lt;/code&gt;是达成一个O的具体行动指引list，每一个&lt;code&gt;KR&lt;/code&gt;的制定需要提前考虑好他的量化评估指标，每一个&lt;code&gt;KR&lt;/code&gt;是可评估的这样才能够保证&lt;code&gt;O&lt;/code&gt;是可评估的，那么这一组&lt;code&gt;OKR&lt;/code&gt;才是有意义的。&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O1: 我要做一个帅哥(这个O很美好，能够充分激发主观能动性(牛马工厂管这叫owner意识))
&lt;ul&gt;
&lt;li&gt;KR1: 八块腹肌(这个KR制定的很好，量化方式很简单)&lt;/li&gt;
&lt;li&gt;KR2: 皮肤状态变好(这个KR定的不好，“状态变好”很难量化，都不如改成12点前睡觉/一年用光一瓶洗面奶/每个月用完10片面膜)&lt;/li&gt;
&lt;li&gt;KR3: 搞个酷酷的发型(这个KR制定的也不太好，有一点过于具体了，很容易就做完了，这种应该是某一个KR里面的一个子项)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;smart目标法&#34;&gt;SMART目标法&lt;/h2&gt;
&lt;p&gt;下面记录巩固一下前人总结的制定目标的SMART法则(from 豆包)。&lt;/p&gt;
&lt;h3 id=&#34;sspecific明确具体&#34;&gt;S（Specific）：明确具体&lt;/h3&gt;
&lt;p&gt;目标必须清晰、具体，避免模糊笼统，明确 “做什么、谁来做、怎么做”。
反面示例：“提高业绩”（模糊，未明确提高多少、针对哪个业务）。
正面示例：“销售团队在第三季度将产品 A 的销售额提升 20%”（明确主体、对象、时间、指标）。&lt;/p&gt;
&lt;h3 id=&#34;mmeasurable可衡量&#34;&gt;M（Measurable）：可衡量&lt;/h3&gt;
&lt;p&gt;目标需有量化标准，便于跟踪进度和判断是否完成，避免 “完成了但说不清完成度” 的情况。
反面示例：“改善客户满意度”（无法量化 “改善” 的程度）。
正面示例：“通过季度调研，将客户满意度评分从 80 分提升至 90 分以上”（用具体分数衡量）。&lt;/p&gt;
&lt;h3 id=&#34;aachievable可实现&#34;&gt;A（Achievable）：可实现&lt;/h3&gt;
&lt;p&gt;目标需具有挑战性，但在现有资源（时间、能力、预算等）下可达成，避免因目标过高而失去动力，或过低而缺乏意义。
反面示例：“零基础 1 个月内成为 AI 专家”（资源和时间不匹配，难以实现）。
正面示例：“3 个月内通过系统学习，掌握 Python 基础编程并独立完成一个数据分析项目”（结合现有基础和学习路径，可实现）。&lt;/p&gt;
&lt;h3 id=&#34;rrelevant相关性&#34;&gt;R（Relevant）：相关性&lt;/h3&gt;
&lt;p&gt;目标需与个人 / 团队的核心目标、长期愿景相关联，确保资源投入有价值，避免偏离核心方向。
反面示例：“市场部花大量时间学习财务软件”（与市场部核心职责关联度低）。
正面示例：“市场部学习新媒体运营工具，提升短视频内容曝光量”（直接服务于 “扩大品牌影响力” 的核心目标）。&lt;/p&gt;
&lt;h3 id=&#34;ttime-bound有时限&#34;&gt;T（Time-bound）：有时限&lt;/h3&gt;
&lt;p&gt;目标必须设定明确的完成时间，避免无限期拖延，同时便于规划阶段任务。
反面示例：“完成产品迭代”（无时间限制，易导致进度松散）。
正面示例：“在 2024 年 12 月 31 日前完成 V2.0 版本的功能开发并上线”（明确截止时间，可拆分阶段任务）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MCMF from scratch</title>
      <link>https://duck-dd.github.io/posts/mcmf/</link>
      <pubDate>Tue, 24 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/mcmf/</guid>
      <description>&lt;p&gt;需要深度用到MCMF了，但是摸了摸自己的脑门，脑子里没有公式和演算，只剩几个概念了。
记录一下我从使用的角度理解MCMF问题(东拼西凑)的过程；某些定理的推导，或者复杂度的计算原理，不会深扒；顺便说个感悟，在feed如此丰富的今天，我们还是应该时刻锻炼传统手艺，保留信息检索、过滤、沉淀的能力，否则可能会越走越远(挺简单个问题一开始看偏了太难理解了)。&lt;/p&gt;
&lt;h1 id=&#34;mcmf概念&#34;&gt;MCMF概念&lt;/h1&gt;
&lt;p&gt;Minimum Cost Maximum Flow(最小费用最大流)，满足流量约束前提下，找到源点到汇点的最大流，并使总运输费用最小，数学模型如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;有向图 G=(V,E)，每条边 e=(u,v) 包含容量 c(e) 和单位流量费用 w(e)；&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;求源点 s 到汇点 t 的最大流，且总费用 ∑w(e)⋅f(e) 最小，其中 f(e) 为边 e 上的流量&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在解析MCMF之前，我们先一起了解一下他的前身，最大流问题和最小费用流问题。&lt;/p&gt;
&lt;h1 id=&#34;最大流问题&#34;&gt;最大流问题&lt;/h1&gt;
&lt;p&gt;最大流问题是：在一个有向网络中，找到从源点（流量的起点）到汇点（流量的终点）的最大可行流量，同时满足每条边的容量限制；该问题是上世纪五十年代提出的，提出后Lester Ford和Delbert Fulkerson很快给出了解法，也是最大流后续一切发展的理论基础：&lt;code&gt;Ford-Fulkerson&lt;/code&gt;算法。&lt;/p&gt;
&lt;h2 id=&#34;第一印象&#34;&gt;第一印象&lt;/h2&gt;
&lt;p&gt;简单描述，有向有权图，起点&lt;code&gt;s&lt;/code&gt;，终点&lt;code&gt;t&lt;/code&gt;，我们要寻找&lt;code&gt;s-&amp;gt;t&lt;/code&gt;的最大的流量。
那么朴素的第一印象来看，暴力呗，BFS把所有&lt;code&gt;s-&amp;gt;t&lt;/code&gt;路径集合&lt;code&gt;P&lt;/code&gt;全部记录下来，然后逐条路径遍历&lt;code&gt;P&lt;/code&gt;，每一条路径都跑满(路径上最小容量边)，同时更新涉及的边的容量值(这里可能还需要维护一个&lt;code&gt;边-&amp;gt;剩余容量&lt;/code&gt;)，结束后得到一个总的流量值。
提出这个方案后，我们第一时间就会有做简单优化的想法，最朴素的想法就是，对于&lt;code&gt;s&lt;/code&gt;的所有出边都满，或者&lt;code&gt;t&lt;/code&gt;的所有入边都满的情况下，是可以快速退出的；有了快速退出这个想法后，继续思考，&lt;code&gt;P&lt;/code&gt;的遍历顺序是对退出速度有影响的，初始状态下所有边没有消耗，&lt;code&gt;P&lt;/code&gt;中的所有路径按大小排序，从大到小的顺序排序，大点干早点散(每次选择一条路径并记录开销后，也可以对&lt;code&gt;P&lt;/code&gt;剩余的路径重排序，只不过开销比较大)，这样感觉上可以更快结束。
好了，聪明的你，在10s以内经历了上述的思考过程，但你眉头一皱，发现问题并不如此简单，简单的想法并不能确保能找到最大流，例如如下的情况：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;图1 blocking-flow(黑色数字=容量,红色数字=流量)&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/mcmf/mcmf-1.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图1 blocking-flow(黑色数字=容量,红色数字=流量)&lt;/center&gt;
&lt;p&gt;如图1左(黑色数字=容量,红色数字=流量)，流量=4后，无法再找到路径可通过流量了，但是如图1右，最大流其实是5；这里引入一个概念，&lt;code&gt;阻塞流&lt;/code&gt;，即将所有的路径都阻塞了，无法再新增流量；显而易见，最大流是阻塞流，但阻塞流未必是最大流。
结合这个具体的例子，我们反过来思考为什么我们上面一起想出来的朴素的方法无法确保能够找到最大流呢？我们就结合这一个具体的简单的例子来分析，把整个图1左的中间部分完全忽略，我们只关注起点&lt;code&gt;s&lt;/code&gt;以及他的出边，终点&lt;code&gt;t&lt;/code&gt;以及他的入边，我们碰到了这样一个情况，我们选定了&lt;code&gt;s&lt;/code&gt;的左出边以及&lt;code&gt;t&lt;/code&gt;的右入边并且把它们两个给跑满了，而&lt;code&gt;s&lt;/code&gt;的右出边和&lt;code&gt;t&lt;/code&gt;的左入边他们两个虽然还有容量但是却无法互连(即我们忽略的图的中间的部分没办法把它们连接起来)，而图1右中，&lt;code&gt;t&lt;/code&gt;的右入边跑满的流量不仅仅来自于&lt;code&gt;s&lt;/code&gt;的左出边，还有&lt;code&gt;s&lt;/code&gt;的右出边；ok, you got it! 简单总结，我们的朴素的暴力解法存在的问题是，会存在不合理的路径规划，他会把若干个瓶颈边放到一条路径里，导致多个瓶颈被同时耗尽。当然了，这是我们最通俗的理解，未必描述的是准确的。&lt;/p&gt;
&lt;p&gt;那么如何修正能够确保准确的找到最大流呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;再继续暴力的把&lt;code&gt;P&lt;/code&gt;的所有排序都跑一遍，复杂度不太现实(感兴趣可以算算复杂度)&lt;/li&gt;
&lt;li&gt;前面提到问题在于某一些路径的选取不合理，它可能同时触发了多个瓶颈(它本可以少触发一些瓶颈)
&lt;ul&gt;
&lt;li&gt;我们避免使用到不合理的路径？那对路径打分？结合实时的 &lt;code&gt;residual graph(残量图，余量图，残量网络 等)&lt;/code&gt;，对剩余的路径打分，路径消耗掉的边(消耗掉边就是指一条边跑满)越少分越高？也不合理，每一条边价值并不是相等的，例如跨海大桥，这一条边甚至就是整个图的瓶颈；那我们从点入手？每个点都有流入边和流出边，流入和流出在每个点是相等的(&lt;code&gt;s&lt;/code&gt; &lt;code&gt;t&lt;/code&gt;除外)，我们尽量让每个点的流入流出比接近于他的容量的入出比，并对路径的所有点做加权后作为评分？说实话我不知道这个想法合理不合理，但是只要是想要依赖&lt;code&gt;residual graph&lt;/code&gt;来建立评分机制，那么随着迭代次数提升，每次都要更新评分，复杂度应该都是不可接受的&lt;/li&gt;
&lt;li&gt;那么换个思路，我们不在避免使用到不合理路径上下功夫，我们能不能做到随时撤销之前的不合理路径？这样我们就可以大胆的随便搞，一边搞一边修正直至结束；恭喜你，你跟Lester Ford和Delbert Fulkerson可能想到一块去了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ford-fulkerson&#34;&gt;Ford-Fulkerson&lt;/h2&gt;
&lt;p&gt;一句话描述&lt;code&gt;Ford-Fulkerson&lt;/code&gt;算法，就是在建立&lt;code&gt;residual graph&lt;/code&gt;时，除了更新每条边的残余容量，还会对已经产生的流量建立反向边，下一轮迭代时，反向边也可以使用。
从物理意义上，反向边一开始是没有的，对正向边开销后才会有反向边(容量等于正向边的开销值)，这没有问题；反向边产生开销时，实际效果类似于水流对冲，本来正向走3个水流，反向再走一个水流，其实最终的效果就等于这条水管(边)正向走了2个水流，解释的通，看来可以理解。
但是回到上面我们自己的思考，我们(或者可能只是我)愚蠢的脑袋里想的是要对之前的路径做撤销，当我们在某一轮迭代中使用到了一条反向边时，我们相当于对曾经使用到这条边的某一条路径撤销了一个流量，是这样吗？(如果是这样那就不应该仅是这一条反向边要做开销了，而是应该找到一条路径)
不是的，还是用图1左举例，他的&lt;code&gt;residual graph&lt;/code&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;图2 图1左的residual graph&#34; loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/mcmf/mcmf-2.png&#34;&gt;&lt;/p&gt;
&lt;center&gt;图2 图1左部的residual-graph&lt;/center&gt;
&lt;p&gt;图2中，我们可以继续找到这样一条路径&lt;code&gt;s-&amp;gt;v2-&amp;gt;v4-&amp;gt;v1-&amp;gt;v3-&amp;gt;t 流量=1&lt;/code&gt;，其中&lt;code&gt;v4-&amp;gt;v1 流量=1&lt;/code&gt;这一段是我们选中的反向边(我们只对这一条边做了&amp;quot;撤销&amp;quot;)，可以看到，经过这一次修正后，我们实际的路径选择就跟图1右的最大流一致了，眼前的事实证明&lt;code&gt;Ford-Fulkerson&lt;/code&gt;算法是正确的。
那我们尝试解答一下我们刚才产生的那个疑惑，当我们使用了一条反向边的时候，我们究竟在做什么?我是这样理解这个问题的，在&lt;code&gt;residual graph&lt;/code&gt;中，如果我们在一条路径中使用到了一条反向边，那么说明一个问题，在最初的原图中，分别存在&lt;code&gt;s&lt;/code&gt;&amp;mdash;&amp;gt;&lt;code&gt;t&lt;/code&gt;的这样两条路径，分别包含了这条边的两个端点，我们可以把这个图抽象成一个&lt;code&gt;H&lt;/code&gt;型，这条边就是中间的横杠，当我们开销这条边的反向边时，实际是在调整&lt;code&gt;H&lt;/code&gt;型的两条竖线之间的流量分配方式(即合理规划使用&lt;code&gt;H&lt;/code&gt;的左上 左下 右上 右下四部分)，以使得整个&lt;code&gt;H&lt;/code&gt;通过的流量最大。&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Shortest Path</title>
      <link>https://duck-dd.github.io/posts/shortest-path/</link>
      <pubDate>Mon, 23 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/shortest-path/</guid>
      <description>&lt;h1 id=&#34;最短路径问题&#34;&gt;最短路径问题&lt;/h1&gt;
&lt;p&gt;寻找有向图中两个顶点之间的路径，使得 &lt;code&gt;路径最短&lt;/code&gt; 或 &lt;code&gt;路径上各边的权重之和最小&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-无权图最短路径&#34;&gt;1 无权图最短路径&lt;/h2&gt;
&lt;p&gt;所有边权重相同，最短路径退化为寻找两点间边数最少的路径，&lt;code&gt;BFS&lt;/code&gt;搞定。&lt;/p&gt;
&lt;h2 id=&#34;2-单源最短路径sssp-single-source-shortest-paths&#34;&gt;2 单源最短路径(SSSP, Single-Source Shortest Paths)&lt;/h2&gt;
&lt;h3 id=&#34;21-dijkstra堆优化&#34;&gt;2.1 Dijkstra(堆优化)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;限制：边权非负&lt;/li&gt;
&lt;li&gt;思路：基于已经确定的最短路径，逐步贪心获得源点到所有节点的最短路径&lt;/li&gt;
&lt;li&gt;步骤
&lt;ul&gt;
&lt;li&gt;初始化：
&lt;ul&gt;
&lt;li&gt;源点&lt;code&gt;s&lt;/code&gt;的距离为0，源点&lt;code&gt;s&lt;/code&gt;一步可达的节点距离记为单边的权重，其他节点距离为无穷大(∞)&lt;/li&gt;
&lt;li&gt;所有节点标记为未访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环处理：
&lt;ul&gt;
&lt;li&gt;从未访问节点中选择距离最小的节点&lt;code&gt;u&lt;/code&gt;，标记为已访问&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;u&lt;/code&gt;的每个邻接节点&lt;code&gt;v&lt;/code&gt;，进行 &lt;strong&gt;松弛操作&lt;/strong&gt;:
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if distance[v] &amp;gt; distance[u] + weight(u, v):
    distance[v] = distance[u] + weight(u, v)
    predecessor[v] = u  # 记录路径
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;终止条件：所有节点均被访问，或未访问节点的最小距离为 ∞（表示源点无法到达剩余节点）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化：使用优先队列(最小堆)维护未访问节点，每次提取最小距离节点的时间为&lt;code&gt;O(logV)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;记录路径：通过记录&lt;code&gt;前驱节点&lt;/code&gt;可以完整还原最短路径，若存在多条最短路径(距离相同但路径不同)，会记录其中一条(具体取决于节点的访问顺序，例如堆优化中相同距离节点的出堆顺序)&lt;/li&gt;
&lt;li&gt;算法正确性理解：未访问节点中排序最靠前的(距离最小的)节点，是基于所有已访问节点推算出来的最近的点，如果再绕行其他节点，那么一定比当前距离更远；相反，如果不是未访问节点里距离最小的点，可能通过其他未访问节点绕行更优，所以每次迭代可以标记这一个点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-bellman-ford&#34;&gt;2.2 Bellman-Ford&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;限制：边权可以为负，但不能有从源点可达的负权环(否则最短路径无意义，长度可无限小)&lt;/li&gt;
&lt;li&gt;思路：通过 &lt;strong&gt;松弛操作&lt;/strong&gt; 逐步逼近从源点到所有其他顶点的最短路径；松弛操作指的是：对于每条边&lt;code&gt;(u, v)&lt;/code&gt;，若从源点到&lt;code&gt;u&lt;/code&gt;的距离 &lt;code&gt;dist[u]&lt;/code&gt;加上边权&lt;code&gt;w(u, v)&lt;/code&gt;小于当前到&lt;code&gt;v&lt;/code&gt;的距离&lt;code&gt;dist[v]&lt;/code&gt;，则更新&lt;code&gt;dist[v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;步骤
&lt;ul&gt;
&lt;li&gt;初始化：源点距离&lt;code&gt;dist[source] = 0&lt;/code&gt;，其他顶点距离&lt;code&gt;dist[v] = ∞&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;弛操作：对图中所有边进行&lt;code&gt;n-1&lt;/code&gt;轮松弛（&lt;code&gt;n&lt;/code&gt;为顶点数）；因为最短路径最多包含&lt;code&gt;n-1&lt;/code&gt;条边(否则存在环，若为正权环可忽略，负权环则无法求解)&lt;/li&gt;
&lt;li&gt;检测负权环：第&lt;code&gt;n&lt;/code&gt;次松弛时，若仍能更新距离，则说明存在从源点可达的负权环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化：下面的SPFA&lt;/li&gt;
&lt;li&gt;算法正确性理解：&lt;code&gt;n&lt;/code&gt;个节点，那么起点到终点路径最长就是 &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;...-&amp;gt;n&lt;/code&gt; 最多有&lt;code&gt;n-1&lt;/code&gt;跳(边)，否则的话就是有环了(如果是正环，绕行是更差的解，如果是负环，最短路径无解)，算法迭代&lt;code&gt;x&lt;/code&gt;轮，那么&lt;code&gt;x&lt;/code&gt;跳能到达的节点的最短路径都会被优化完成，所以经过&lt;code&gt;n-1&lt;/code&gt;轮迭代，最长的路径也能被优化完成了；如何理解这句话呢，假设一个点距离起点有1条边和3条边两条路径，那么经过三轮迭代，这两条路径之间一定会做PK，择优就会完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-spfa-shortest-path-faster-algorithm&#34;&gt;2.3 SPFA, Shortest Path Faster Algorithm&lt;/h3&gt;
&lt;p&gt;SPFA其实只是Bellman-Ford的筛选优化，本质相同&lt;/p&gt;</description>
    </item>
    <item>
      <title>go tips(持续更新)</title>
      <link>https://duck-dd.github.io/posts/go-tips/</link>
      <pubDate>Sun, 22 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/go-tips/</guid>
      <description>&lt;p&gt;有很多从其他大佬的总结中抄来的，不注明出处了&lt;/p&gt;
&lt;p&gt;会记录一些:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有意义的小操作(可能有些比较tricky)&lt;/li&gt;
&lt;li&gt;容易理解偏差的点&lt;/li&gt;
&lt;li&gt;日常开发低频使用的知识点&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;golang代码执行顺序&#34;&gt;golang代码执行顺序&lt;/h2&gt;
&lt;p&gt;没有并发，一个顺序逻辑，CPU真正执行指令不一定与编码顺序完全一致，Go的编译器会做优化，前提是会解决依赖逻辑，看起来是“顺序执行”这一假设。&lt;/p&gt;
&lt;p&gt;了解更多可查看Golang内存模型规范。&lt;/p&gt;
&lt;h2 id=&#34;golang内存对齐&#34;&gt;golang内存对齐&lt;/h2&gt;
&lt;p&gt;内存对齐：数据在内存中的存储位置必须是特定字节数的倍数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU访问内存时，通常按固定大小的块（如4字节或8字节）读取，不对齐的数据可能导致需要两次访问&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;golang内存对齐：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础类型：通常是其自身大小（如int32为4字节，int64为8字节）&lt;/li&gt;
&lt;li&gt;结构体
&lt;ul&gt;
&lt;li&gt;每个字段按各自的对齐系数作对齐&lt;/li&gt;
&lt;li&gt;结构体自身的对齐系数为所有字段中最大的对齐系数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数组：与元素类型的对齐系数相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type demo1 struct {
	a int8
	b int16
	c int32
}

type demo2 struct {
	a int8
	c int32
	b int16
}

type demo3 struct {
	a int8
	c int32
	b int16
	d int16
}

func main() {
    fmt.Println(unsafe.Sizeof(demo1{})) // 8
	fmt.Println(unsafe.Sizeof(demo2{})) // 12
	fmt.Println(unsafe.Sizeof(demo3{})) // 12
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;demo1:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节&lt;/li&gt;
&lt;li&gt;b 是第二个字段，对齐倍数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节&lt;/li&gt;
&lt;li&gt;c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;demo2:&lt;/p&gt;</description>
    </item>
    <item>
      <title>相似度</title>
      <link>https://duck-dd.github.io/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6/</link>
      <pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6/</guid>
      <description>&lt;p&gt;&lt;code&gt;相似度算法&lt;/code&gt;用于衡量多个对象（如文本、数值向量、图像、序列等）之间相似程度的数学方法。&lt;/p&gt;
&lt;p&gt;在计算机领域，通常将 “相似性” 转化为可计算的数值（例如 0~1 表示，1代表完全相似，0代表完全不相似）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;相似度算法&lt;/code&gt;的应用十分广泛，例如推荐系统（如商品/内容推荐）、数据挖掘（如聚类、分类）、NLP（如文本查重、语义匹配）、图像识别等。&lt;/p&gt;
&lt;h1 id=&#34;文本相似度&#34;&gt;文本相似度&lt;/h1&gt;
&lt;h2 id=&#34;基于字符词频&#34;&gt;基于字符/词频&lt;/h2&gt;
&lt;p&gt;不依赖语义理解，仅从文本的字符或词语出现频率出发计算相似性，适合简单的短文本内容的场景。&lt;/p&gt;
&lt;h3 id=&#34;jaccard-系数杰卡德相似度&#34;&gt;Jaccard 系数（杰卡德相似度）&lt;/h3&gt;
&lt;p&gt;思路：将文本视为 “词语集合”（忽略词频和顺序），&lt;code&gt;相似性 = 两个集合的交集大小 / 两个集合的并集大小&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子，sim(“小明球技很棒” &amp;amp; “小明球技真好”) = len(&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo;)/len(&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; &amp;ldquo;真好&amp;rdquo;) = 0.5&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词频没有统计&lt;/li&gt;
&lt;li&gt;语义不做理解，&amp;ldquo;真好&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; 其实语义接近&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;余弦相似度cosine-similarity&#34;&gt;余弦相似度（Cosine Similarity）&lt;/h3&gt;
&lt;p&gt;思路：将文本转换为词频向量，&lt;code&gt;相似性 = 两个向量夹角余弦值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子，(“小明球技很棒啊，小明不错” &amp;amp; “小明球技真好”)，构建&lt;code&gt;词袋&lt;/code&gt;=[&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; &amp;ldquo;真好&amp;rdquo; &amp;ldquo;不错&amp;rdquo;]，对于词袋，计算向量值，“小明球技很棒”的词频向量A = [2,1,1,0,1]，“小明球技真好”的词频向量B = [1,1,0,1,0]，则 &lt;code&gt;相似性 = cos(A,B) = (A*B)/(||A||*||B||) = (2+1+0+0+0)/(√7*√3) = 3/√21 = 0.66&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;考虑了词频，长文本理解更准确&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义还是没有理解&lt;/li&gt;
&lt;li&gt;高频无意义词，如“的” “地”等影响较大，需过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 常用的相似性判定方法主要通过 向量夹角余弦值(&lt;code&gt;向量点积/向量模乘积&lt;/code&gt;)
&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;
&lt;semantics&gt;
&lt;mrow&gt;
&lt;mi&gt;cos&lt;/mi&gt;
&lt;mi&gt;θ&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mfrac&gt;
&lt;mrow&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msub&gt;
&lt;mi&gt;A&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;msub&gt;
&lt;mi&gt;B&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;/mrow&gt;
&lt;mrow&gt;
&lt;msqrt&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;msub&gt;
&lt;mi&gt;A&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/msqrt&gt;
&lt;mo&gt;×&lt;/mo&gt;
&lt;msqrt&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;msub&gt;
&lt;mi&gt;B&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/msqrt&gt;
&lt;/mrow&gt;
&lt;/mfrac&gt;
&lt;/mrow&gt;
&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\cos\theta = \frac{\sum_{i=1}^n A_iB_i}{\sqrt{\sum_{i=1}^n A_i^2} \times \sqrt{\sum_{i=1}^n B_i^2}}&lt;/annotation&gt;
&lt;/semantics&gt;
&lt;/math&gt;
or 向量间欧式距离
&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;
&lt;semantics&gt;
&lt;mrow&gt;
&lt;mi&gt;d&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;msqrt&gt;
&lt;mrow&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;mrow&gt;
&lt;mi&gt;(&lt;/mi&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mrow&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/mrow&gt;
&lt;/msub&gt;
&lt;mo&gt;-&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mrow&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/mrow&gt;
&lt;/msub&gt;
&lt;mi&gt;)&lt;/mi&gt;
&lt;/mrow&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/mrow&gt;
&lt;/msqrt&gt;
&lt;/mrow&gt;
&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d = \sqrt{\sum_{i=1}^n (x_{2i} - x_{1i})^2}&lt;/annotation&gt;
&lt;/semantics&gt;
&lt;/math&gt;
计算获得&lt;/p&gt;</description>
    </item>
    <item>
      <title>认清自己 2025-05-28日记</title>
      <link>https://duck-dd.github.io/posts/%E8%AE%A4%E6%B8%85%E8%87%AA%E5%B7%B1-2025-05-26%E6%97%A5%E8%AE%B0/</link>
      <pubDate>Wed, 28 May 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/%E8%AE%A4%E6%B8%85%E8%87%AA%E5%B7%B1-2025-05-26%E6%97%A5%E8%AE%B0/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;渭城朝雨浥轻尘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客舍青青柳色新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;劝君更尽一杯酒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;西出阳关无故人&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;回首向来萧瑟处，归去，也无风雨也无晴&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;“孩子若是平凡之辈，那就承欢膝下；若是出类拔萃，那就让其展翅高飞。接受孩子的平庸，就像孩子从来没有要求父母一定要多么优秀一样。” &amp;mdash;&amp;mdash; 梁晓声《人世间》&lt;/p&gt;
&lt;p&gt;平凡的周秉义，也是精彩绝伦的一生。&lt;/p&gt;
&lt;p&gt;这句话也会被总结为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受父母的平凡&lt;/li&gt;
&lt;li&gt;接受自己的平凡&lt;/li&gt;
&lt;li&gt;接受子女的平凡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个阶段不在今天的讨论范围。今天主要说第二个阶段，因为今天的我认为，时至今日，我终于走完了这个阶段。&lt;/p&gt;
&lt;p&gt;从小在小山村长大，得益于父母给的脑子，在学习上有一定的竞争力。对小学时期，印象深刻的有两件事。&lt;/p&gt;
&lt;p&gt;第一件事，就是每到期末，村里面所有的孩子会成为一车面包人，前往“中心校”，参加期末考试；每次去的路上，几十分钟的路程，那是我最紧张的时候，因为进入考场后反而会平静，用现在的词，叫“心流”；紧张的时候小小的脑袋在想什么呢，我就在想，“今天就是最终的战役了，放手一搏吧”，反正就大概这个意思吧，延续这个思维，后面人生很多场关于学习的考试，考前都是这种心态。&lt;/p&gt;
&lt;p&gt;第二件事，是在大概四五年级的时候，乡里面举办了一场“竞赛”，每个村小学出一个队，齐聚“中心校”，比赛的过程大概就是全程举牌抢答，答对加分，答错扣分，题目范围也不仅限于小学课本，涉及了一些课外知识；没错，作为团队主力，我们村拿到了最高分(我得到了一些文具，好像还有一个枕套)；小小的我，在教育资源极度匮乏的村里，第一次深刻感受“激烈的”比赛；这是我对学习的第一次“觉醒”，虚荣心得到了满足，学到的知识也有了用武之地。&lt;/p&gt;
&lt;p&gt;后面就是按部就班的到城里上中学，靠着虚荣心，靠着别人的称赞，靠着自己的一点拼劲，一路学习成绩都还不错。中考和高考的成绩其实都不咋地，但是也没有差到不能接受；当看到自己的高考排名，第一次产生了自我怀疑，自己其实根本没有自己想象的那么厉害呀！&lt;/p&gt;
&lt;p&gt;成长的背景简单总结如上，这一路“虚荣心”提供了极大的动力，也给自己营造了自己还不错的假象。这种自我暗示一旦形成，我感觉是很难从内自我打破的。第一份工作自己没太多思考，更多是被推着走，最大的收获在于很多思考方式的转变和能力的成长，所以当这一段旅程结束时，心态是感恩 感谢 积极向上的；当我带着自我预期走进第二段经历的时候，觉得自己可以做出一番成绩；今天来看，平台有，自由度有，只是自己没有做好；这里的自我剖析过程，简直“罄竹难书”了；一句话概括，&lt;strong&gt;&amp;ldquo;求其下者无所得&amp;rdquo;&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;所以当今天再次走向下一段旅程，心情是平淡的，怀抱美好憧憬，但是能够一定程度上提前认识到旅途的艰辛和失败的苦涩；这么多年，社会终于教会了我，接受自己的平凡。&lt;/p&gt;
&lt;p&gt;此刻心里只有一个愿望，到底什么时候能找到创业的方向啊。&lt;/p&gt;
&lt;p&gt;安顺的山清晰透明，黄果树的汛期滔滔不绝；瀑布上的每一滴水都惊涛骇浪，但那么大的水量，跌落后都回归进了平静的河流。&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang singleflight</title>
      <link>https://duck-dd.github.io/posts/golang-singleflight/</link>
      <pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/golang-singleflight/</guid>
      <description>&lt;p&gt;高并发场景下，有时我们很多并发goroutine内有逻辑重合，可能拉了数据库同一张表的数据，可能拉了同一个远程图片，这些数据通常是偏静态的，那么没有必要在每个goroutine内部都做这个操作，可能会拉高上游服务的负载，可能会影响本地的执行效率，可能会浪费本地的网卡资源等。&lt;/p&gt;
&lt;p&gt;通常我们会依赖缓存来解决这个问题，这也确实是行之有效的；但是golang并发场景也给了我们更简便的实现方法：&lt;code&gt;golang.org/x/sync/singleflight&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如下面的例子，&lt;code&gt;doSth&lt;/code&gt;有2s的Sleep模拟执行过程；我们分了两组for+routine，中间有1s的Sleep，确保第一个发起&lt;code&gt;doSth&lt;/code&gt;的&lt;code&gt;index&lt;/code&gt;是可控的，然后我们看到输出实际&lt;code&gt;doSth&lt;/code&gt;只执行了一次，所有routine共享了同一份结果。
PS：所有的&lt;code&gt;shared&lt;/code&gt;返回值都是&lt;code&gt;true&lt;/code&gt;，可能并不是大脑第一印象的第一个实际执行者是&lt;code&gt;false&lt;/code&gt;，其他人是&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;sync&amp;#34;
	&amp;#34;sync/atomic&amp;#34;
	&amp;#34;time&amp;#34;
	&amp;#34;golang.org/x/sync/singleflight&amp;#34;
)

func doSth(index int) (any, error) {
	time.Sleep(2 * time.Second)
	return fmt.Sprintf(&amp;#34;result_%d&amp;#34;, index), nil
}

func main() {
	var g singleflight.Group
	var wg sync.WaitGroup
	var doCount int32 

	for i := 100; i &amp;lt; 101; i++ {
		wg.Add(1)
		index := i
		go func() {
			defer wg.Done()
			ret, err, shared := g.Do(&amp;#34;key&amp;#34;, func() (interface{}, error) {
				atomic.AddInt32(&amp;amp;doCount, 1)
				v,e := doSth(index)
				fmt.Printf(&amp;#34;index:%d, v: %v, err: %v\n&amp;#34;, index, v, e)
				return v,e
			})
			fmt.Printf(&amp;#34;index:%d, ret:%v, shared:%v, err:%v\n&amp;#34;, index, ret, shared, err)
		}()
	}
	
	
	time.Sleep(time.Second)
	
	for i := 0; i &amp;lt; 5; i++ {
		wg.Add(1)
		index := i
		go func() {
			defer wg.Done()
			ret, err, shared := g.Do(&amp;#34;key&amp;#34;, func() (interface{}, error) {
				atomic.AddInt32(&amp;amp;doCount, 1)
				v,e := doSth(index)
				fmt.Printf(&amp;#34;index:%d, v: %v, err: %v\n&amp;#34;, index, v, e)
				return v,e
			})
			fmt.Printf(&amp;#34;index:%d, ret:%v, shared:%v, err:%v\n&amp;#34;, index, ret, shared, err)
		}()
	}
	
	wg.Wait()
	
	fmt.Printf(&amp;#34;实际执行次数: %d\n&amp;#34;, doCount)
}

------
output:

index:100, v: result_100, err: &amp;lt;nil&amp;gt;
index:100, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:0, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:4, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:2, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:3, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
index:1, ret:result_100, shared:true, err:&amp;lt;nil&amp;gt;
实际执行次数: 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;真正发起共享的函数&lt;code&gt;Do&lt;/code&gt;入参是有&lt;code&gt;key&lt;/code&gt;的，我们把&lt;code&gt;key&lt;/code&gt;做个替换，会发现不同&lt;code&gt;key&lt;/code&gt;之间不共享，如下：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
