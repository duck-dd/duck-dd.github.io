<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CS-Other on Duck</title>
    <link>https://duck-dd.github.io/tags/cs-other/</link>
    <description>Recent content in CS-Other on Duck</description>
    <image>
      <title>Duck</title>
      <url>https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://duck-dd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.147.8</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Jun 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://duck-dd.github.io/tags/cs-other/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>相似度</title>
      <link>https://duck-dd.github.io/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6/</link>
      <pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6/</guid>
      <description>&lt;p&gt;&lt;code&gt;相似度算法&lt;/code&gt;用于衡量多个对象（如文本、数值向量、图像、序列等）之间相似程度的数学方法。&lt;/p&gt;
&lt;p&gt;在计算机领域，通常将 “相似性” 转化为可计算的数值（例如 0~1 表示，1代表完全相似，0代表完全不相似）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;相似度算法&lt;/code&gt;的应用十分广泛，例如推荐系统（如商品/内容推荐）、数据挖掘（如聚类、分类）、NLP（如文本查重、语义匹配）、图像识别等。&lt;/p&gt;
&lt;h1 id=&#34;文本相似度&#34;&gt;文本相似度&lt;/h1&gt;
&lt;h2 id=&#34;基于字符词频&#34;&gt;基于字符/词频&lt;/h2&gt;
&lt;p&gt;不依赖语义理解，仅从文本的字符或词语出现频率出发计算相似性，适合简单的短文本内容的场景。&lt;/p&gt;
&lt;h3 id=&#34;jaccard-系数杰卡德相似度&#34;&gt;Jaccard 系数（杰卡德相似度）&lt;/h3&gt;
&lt;p&gt;思路：将文本视为 “词语集合”（忽略词频和顺序），&lt;code&gt;相似性 = 两个集合的交集大小 / 两个集合的并集大小&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子，sim(“小明球技很棒” &amp;amp; “小明球技真好”) = len(&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo;)/len(&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; &amp;ldquo;真好&amp;rdquo;) = 0.5&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词频没有统计&lt;/li&gt;
&lt;li&gt;语义不做理解，&amp;ldquo;真好&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; 其实语义接近&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;余弦相似度cosine-similarity&#34;&gt;余弦相似度（Cosine Similarity）&lt;/h3&gt;
&lt;p&gt;思路：将文本转换为词频向量，&lt;code&gt;相似性 = 两个向量夹角余弦值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举个例子，(“小明球技很棒啊，小明不错” &amp;amp; “小明球技真好”)，构建&lt;code&gt;词袋&lt;/code&gt;=[&amp;ldquo;小明&amp;rdquo; &amp;ldquo;球技&amp;rdquo; &amp;ldquo;很棒&amp;rdquo; &amp;ldquo;真好&amp;rdquo; &amp;ldquo;不错&amp;rdquo;]，对于词袋，计算向量值，“小明球技很棒”的词频向量A = [2,1,1,0,1]，“小明球技真好”的词频向量B = [1,1,0,1,0]，则 &lt;code&gt;相似性 = cos(A,B) = (A*B)/(||A||*||B||) = (2+1+0+0+0)/(√7*√3) = 3/√21 = 0.66&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;考虑了词频，长文本理解更准确&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义还是没有理解&lt;/li&gt;
&lt;li&gt;高频无意义词，如“的” “地”等影响较大，需过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt; 常用的相似性判定方法主要通过 向量夹角余弦值(&lt;code&gt;向量点积/向量模乘积&lt;/code&gt;)
&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;
&lt;semantics&gt;
&lt;mrow&gt;
&lt;mi&gt;cos&lt;/mi&gt;
&lt;mi&gt;θ&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mfrac&gt;
&lt;mrow&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msub&gt;
&lt;mi&gt;A&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;msub&gt;
&lt;mi&gt;B&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;/mrow&gt;
&lt;mrow&gt;
&lt;msqrt&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;msub&gt;
&lt;mi&gt;A&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/msqrt&gt;
&lt;mo&gt;×&lt;/mo&gt;
&lt;msqrt&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;msub&gt;
&lt;mi&gt;B&lt;/mi&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/msub&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/msqrt&gt;
&lt;/mrow&gt;
&lt;/mfrac&gt;
&lt;/mrow&gt;
&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\cos\theta = \frac{\sum_{i=1}^n A_iB_i}{\sqrt{\sum_{i=1}^n A_i^2} \times \sqrt{\sum_{i=1}^n B_i^2}}&lt;/annotation&gt;
&lt;/semantics&gt;
&lt;/math&gt;
or 向量间欧式距离
&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;
&lt;semantics&gt;
&lt;mrow&gt;
&lt;mi&gt;d&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;msqrt&gt;
&lt;mrow&gt;
&lt;munderover&gt;
&lt;mo&gt;∑&lt;/mo&gt;
&lt;mrow&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;/mrow&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;/munderover&gt;
&lt;msup&gt;
&lt;mrow&gt;
&lt;mi&gt;(&lt;/mi&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mrow&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/mrow&gt;
&lt;/msub&gt;
&lt;mo&gt;-&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mrow&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;mi&gt;i&lt;/mi&gt;
&lt;/mrow&gt;
&lt;/msub&gt;
&lt;mi&gt;)&lt;/mi&gt;
&lt;/mrow&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/msup&gt;
&lt;/mrow&gt;
&lt;/msqrt&gt;
&lt;/mrow&gt;
&lt;annotation encoding=&#34;application/x-tex&#34;&gt;d = \sqrt{\sum_{i=1}^n (x_{2i} - x_{1i})^2}&lt;/annotation&gt;
&lt;/semantics&gt;
&lt;/math&gt;
计算获得&lt;/p&gt;</description>
    </item>
    <item>
      <title>软件架构设计原则</title>
      <link>https://duck-dd.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;p&gt;每次接手一些老旧系统，总是很头疼，最近想，会不会别人接手了我的系统以后也是一样的感受，想到可能有人每天都在吐槽(骂)我头皮发麻啊&amp;hellip;&lt;/p&gt;
&lt;p&gt;知易行难，其实怎么做好一个后端服务大家都是门清的，只是受限于 &lt;code&gt;排期&lt;/code&gt; &lt;code&gt;业务价值&lt;/code&gt; &lt;code&gt;协作&lt;/code&gt; 等太多因素，往往事与愿违。只能说但行好事莫问前程吧，下面再把这些原则列一下，时刻提醒自己吧；以下原则从个人角度分先后，不是说有重要性区别，而是有些原则很高频，或者很容易被忽略，需要时刻牢记。&lt;/p&gt;
&lt;h1 id=&#34;一-职责逻辑-清晰&#34;&gt;一 职责/逻辑 清晰&lt;/h1&gt;
&lt;h2 id=&#34;单一职责原则single-responsibility-principle-srp&#34;&gt;单一职责原则（Single Responsibility Principle, SRP）&lt;/h2&gt;
&lt;p&gt;每个&lt;code&gt;单元&lt;/code&gt;只负责&lt;em&gt;一件事&lt;/em&gt;。
从总体架构上讲，这个单元是一个子系统，例如订单系统，日志系统；从系统架构上讲，这个单元是一个模块，例如文章管理模块，评论管理模块等；从代码模块内部讲，这个单元是一个组件，一个类，一个struct等。再往下看，一个类还有N多个方法&amp;hellip;
就像分子，原子，质子/电子，夸克&amp;hellip;从宏观到微观的过程，就是我们把一套复杂的系统一点一点拆解开的过程，而每次向下拆解一层的时候，这一层的个体，尽量做到每个都负责一件事&lt;/p&gt;
&lt;h2 id=&#34;迪米特法则law-of-demeter-lod&#34;&gt;迪米特法则（Law of Demeter, LoD）&lt;/h2&gt;
&lt;p&gt;一个模块应尽可能少地了解其他模块的内部细节。
反过来看，一个模块向外不暴露细节，别人就没法了解细节了；所以还是在讲控制耦合。&lt;/p&gt;
&lt;h2 id=&#34;高内聚低耦合high-cohesion-low-coupling&#34;&gt;高内聚，低耦合（High Cohesion, Low Coupling）&lt;/h2&gt;
&lt;p&gt;模块内部的功能紧密相关(高内聚)，模块间通过明确接口交互，依赖关系简单(低耦合)。
明牌了，直接再提醒你一下，控制耦合控制耦合控制耦合&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;接口隔离原则interface-segregation-principle-isp&#34;&gt;接口隔离原则（Interface Segregation Principle, ISP）&lt;/h2&gt;
&lt;p&gt;客户端不应被迫依赖它不需要的接口，应将大接口拆分为多个专用小接口。
这里不是对使用者的要求，而是对接口提供(设计)者提出要求，在设计对外暴露接口时，要尽可能小，单一，独立，这样使用起来更灵活。
对外是这样的，但是内部接口，说实话我做不到尽可能小。&lt;/p&gt;
&lt;h1 id=&#34;二-破坏性侵入性控制&#34;&gt;二 破坏性(侵入性)控制&lt;/h1&gt;
&lt;h2 id=&#34;开闭原则open-closed-principle-ocp&#34;&gt;开闭原则（Open-Closed Principle, OCP）&lt;/h2&gt;
&lt;p&gt;对扩展开放，对修改关闭。
从我的理解，这条原则更多还是在指导代码层面的设计；世界是动态发展的，没有一成不变的东西，那么对于代码，可扩展是必然的需求，那为什么对修改关闭呢？可能更多还是对原系统的侵入吧，你不知道你的使用方对你做出了怎么样的假设，总之目前为止世界和平，但当你修改了你的行为，假设被打破，世界就崩塌了&lt;/p&gt;
&lt;h2 id=&#34;里氏替换原则liskov-substitution-principle-lsp&#34;&gt;里氏替换原则（Liskov Substitution Principle, LSP）&lt;/h2&gt;
&lt;p&gt;子类必须能无缝替换父类，且不破坏原有系统的正确性。即父类出现的地方，子类可替代，且行为一致。&lt;/p&gt;
&lt;h1 id=&#34;三-依赖管理&#34;&gt;三 依赖管理&lt;/h1&gt;
&lt;h2 id=&#34;分层架构原则layered-architecture-principle&#34;&gt;分层架构原则（Layered Architecture Principle）&lt;/h2&gt;
&lt;p&gt;将系统按职责划分为清晰的层次，层间单向依赖，禁止跨层调用。&lt;/p&gt;
&lt;h2 id=&#34;依赖倒置原则dependency-inversion-principle-dip&#34;&gt;依赖倒置原则（Dependency Inversion Principle, DIP）&lt;/h2&gt;
&lt;p&gt;高层模块不应依赖低层模块，两者都应依赖抽象；抽象不应依赖细节，细节应依赖抽象。&lt;/p&gt;
&lt;h1 id=&#34;四-可扩展性&#34;&gt;四 可扩展性&lt;/h1&gt;
&lt;h2 id=&#34;演进式架构原则evolutionary-architecture&#34;&gt;演进式架构原则（Evolutionary Architecture）&lt;/h2&gt;
&lt;p&gt;架构设计应预留扩展空间，支持系统随业务需求逐步演进，而非追求 “一步到位” 的完美设计。&lt;/p&gt;
&lt;h1 id=&#34;五-安全代码安全服务安全业务安全等&#34;&gt;五 安全(代码安全，服务安全，业务安全等)&lt;/h1&gt;
&lt;h2 id=&#34;安全性原则security-by-design&#34;&gt;安全性原则（Security by Design）&lt;/h2&gt;
&lt;p&gt;将安全性嵌入架构设计的每个环节，而非事后补丁。&lt;/p&gt;</description>
    </item>
    <item>
      <title>happens-before</title>
      <link>https://duck-dd.github.io/posts/happens-before/</link>
      <pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/happens-before/</guid>
      <description>&lt;p&gt;在并发系统中，用于描述事件执行顺序关系；若事件A &amp;ldquo;happens-before&amp;rdquo; 事件B，则A的执行结果对B可见，且A在逻辑上先于B执行(并不要求在物理时间上A必须先于B执行)。&lt;/p&gt;
&lt;p&gt;所以这其实是一种逻辑关系，在并发系统中，P1 P2 两个过程在逻辑上&amp;quot;同时&amp;quot;在执行，P2过程中的事件B依赖P1过程中的事件A的结果，那么就需要逻辑上的 &amp;ldquo;happens-before&amp;rdquo; 来确保A&amp;amp;B间的依赖关系。&lt;/p&gt;
&lt;p&gt;常见的并发模型 &lt;strong&gt;共享内存&lt;/strong&gt; 和 &lt;strong&gt;消息传递&lt;/strong&gt;，都遵循 &amp;ldquo;happens-before&amp;quot;逻辑，消息传递中的happens-before好理解，消息的传入肯定是在消息的接收之前的，在共享内存模型的并发中，happens-before就是帮助我们在逻辑上自洽，理清楚不同并发单元(线程 协程 等)对某一个共享内存变量的操作顺序。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DNS</title>
      <link>https://duck-dd.github.io/posts/dns/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate>
      <guid>https://duck-dd.github.io/posts/dns/</guid>
      <description>&lt;h1 id=&#34;dns挺好啥是dns&#34;&gt;DNS，挺好，啥是DNS？&lt;/h1&gt;
&lt;h2 id=&#34;一些概念&#34;&gt;一些概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FQDN: Fully Qualified Domain Name，全限定域名，同时带有主机名和域名的名称（通过符号“.”），例如一个FQDN是www.baidu.com，www是主机名，baidu.com是域名。再举例，我是海淀吴彦祖，你是**吴彦祖，但是我们还知道，有个人就叫吴彦祖，这么多吴彦祖我们都没有混淆，因为名字前面加上了地域，也就是域名。从逻辑上看FQDN，就是主机名的完整表达，类似绝对路径，通过一个FQDN我们可以在全网内锁定主机位置。&lt;/li&gt;
&lt;li&gt;cache only DNS server : 有.的zone file的DNS服务器，本身没有任何解析数据，完全靠查询来获取数据源&lt;/li&gt;
&lt;li&gt;forwarding DNS server : 连.的zone file都没有，完全靠向上层查询获取数据；当使用forwarding功能时，即使本身有.的zone file，也不会向.查询，该DNS server还是会将查询完全委托给上层。&lt;/li&gt;
&lt;li&gt;CIDR:Classless Inter-Domain Routing, 无类域间路由，不按固定的字节来划分网络编号，可以使用IP地址中任何相邻位的数字作为网络编号，例如某机构需要2个B类网络大小的空间，那么可以使用前15位作为网络编号，例如127.127.0.0/15
&lt;ul&gt;
&lt;li&gt;A类,B类,C类网络：A类网络以IP地址的第一个字节(前8位)作为网络编号,剩下的24位为主机;B类网络前两个字节为网络编号;C类网络前三个字节为网络编号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns做什么&#34;&gt;DNS做什么&lt;/h2&gt;
&lt;p&gt;ipv4 32bit，ipv6 128bit，即使转成10/16进制也没人记得住，但是人类的头脑善于记录名字，所以可以搞一个名字跟IP对应，名字跟IP的对应关系解析，就是DNS提供的服务。&lt;/p&gt;
&lt;p&gt;主机名的解析有一个发展的过程。&lt;/p&gt;
&lt;p&gt;最初没有DNS人们如何记住各个服务名字跟IP的对应关系呢？就是写在/etc/hosts文件里，自己写麻烦，那就统一写到中心，使用的时候从中心拉取。&lt;/p&gt;
&lt;p&gt;这个中心就是internic，主机名IP对应关系修改时，注册到internic中；用户准备上网之前先去internic把最新的文件拉下来，放在自己的/etc/hosts。&lt;/p&gt;
&lt;p&gt;这种方式问题很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如internic拉取的文件会很大，每次打开电脑先拉个100G的文件然后再开始上网，就算你磁盘扛得住，你的网络不够好也很难受（因为你不能明确说明自己上网需要的主机名，只能拉全量，互联网业务增长该文件会越来越大）&lt;/li&gt;
&lt;li&gt;例如这种方式是静态的，需要用户主动触发更新行为（你总不能让一个人开机默认就去下载100G的文件，他不可能给你授权的）；试想一下，一个网瘾少年下午6点睡眼惺忪的起床，打开电脑先从internic下载了半个小时文件，期间去洗漱吃了早饭，然后开开心心开始打游戏，突然，游戏掉线了，上贴吧一查，大家都说快去重新拉取internic的hosts文件呀，游戏域名被友商攻击换域名了，这还好，少年骂骂咧咧下载个文件就完事了，要是贴吧都上不去就更让人懵逼了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时代的进步总是聪明人推动的。Berkeley一个同学就觉得这种方式不太行，于是他就搞出一套BIND系统提供DNS服务。&lt;/p&gt;
&lt;h2 id=&#34;bindberkeley-internet-name-domain&#34;&gt;BIND，Berkeley Internet Name Domain&lt;/h2&gt;
&lt;h3 id=&#34;bind管理方式&#34;&gt;BIND管理方式&lt;/h3&gt;
&lt;p&gt;BIND是一套阶层式的管理主机名与IP对应关系的系统。&lt;/p&gt;
&lt;p&gt;阶层式？可以简单理解为树状结构的不同层级，下面来简单分析下阶层式。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/dns/1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;以www.baidu.com为例，最上层根服务器，domain name是&amp;quot;.&amp;quot;，然后有三个hostname &amp;ldquo;net com cn&amp;rdquo;，再到第三层，hostname分别是pdd baidu tencent，此时domain name为.com. ，以此类推。。。需要注意的是，不是每一个&amp;quot;.&amp;ldquo;都拆分domain name&amp;amp;hostname，例如上图  video.www.baidu.com ，其中domain name为baidu.com.，hostname为video.www。按照上述方式分层，每一个服务节点（权威）只负责自己的一小撮域名，这就避免了大量数据集中的问题。&lt;/p&gt;
&lt;p&gt;DNS阶层系统的最上方是一个&amp;rdquo;.&amp;quot;，root，是根服务器，本质上讲，这里的&amp;quot;.&amp;ldquo;后面其实是空标签，这是为root保留的；根服务器下一层管理的是Top Level Domains(TLD)，例如com. net. org.等等。&lt;/p&gt;
&lt;p&gt;每个上一层的DNS服务器，所记录的信息，只有下一层的主机名；再下一层，授权给再再下层某个主机管理，这就是分层管理；DNS分层最多到127层(实际上不会用到这么多)，每一层最多63个字符(不包括&amp;rdquo;.&amp;quot;)；同一层内不允许同名，确保唯一性。&lt;/p&gt;
&lt;h3 id=&#34;bind查询流程&#34;&gt;BIND查询流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当浏览器输入 &lt;a href=&#34;https://www.baidu.com&#34;&gt;https://www.baidu.com&lt;/a&gt; ，先查浏览器缓存，再查/etc/hosts文件，都找不到www.baidu.com的解析时，会根据/etc/resolv.conf文件内配置的DNS服务器地址，去进行DNS解析，询问www.baidu.com的A记录&lt;/li&gt;
&lt;li&gt;client第一步找到的DNS服务器通常为运营商提供的local DNS服务器，local DNS作为名称服务器，接收client端的递归查询请求，若local DNS服务器自身没有www.baidu.com的解析结果，则向.DNS服务器发起解析请求，询问www.baidu.com是啥A记录呢？
&lt;ul&gt;
&lt;li&gt;其实递归查询实际过程中，local DNS若未命中缓存，并不是直接查询根服务器，他会寻找已知最近的名称服务器(待实验确认)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;.并不知道www.baidu.com的IP，它会告诉你我只知道.com，IP给你，你去问它吧&lt;/li&gt;
&lt;li&gt;然后local DNS获取到了.com的信息后，开始向.com询问www.baidu.com的解析结果&lt;/li&gt;
&lt;li&gt;.com也不知道www.baidu.com的IP地址，它会说，我只认识baidu.com，你去问它吧
&lt;ul&gt;
&lt;li&gt;.com返回的一般是baidu.com的多个NS域名(及其IP,胶水记录)，如下例图，那么如何选择权威呢？BIND名称服务器使用RTT(roundtrip time)的度量方式来选择对同一区域中的名称服务器进行选择，即选择RTT最小的那个名称服务器(dig +trace抓包并没看到对RTT的探测，现象上看是从ns*.baidu.com里面随机选择的？)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://duck-dd.github.io/images/dns/2.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
